/* UNAME:CDHACTR */
#include <algol68/Asupport.h>

A_PROCEDURE(A68_INT *,A68t31,(A68_INT *,A68_VC ),(A68_INT *,A68_VC ,void *));
typedef struct A68t31  A68_31 ;    /* PROC(REF INT,MODE26) REF INT */

A_PROCEDURE(A68_VOID ,A68t32,(A68_VC ,A68_INT ,A68_VC *),(A68_VC ,A68_INT ,A68_VC *,void *));
typedef struct A68t32  A68_32 ;    /* PROC(REF MODE26,INT) REF MODE26 */

A_PROCEDURE(A68_VOID ,A68t33,(A68_VC ,A68_CHAR ,A68_VC *),(A68_VC ,A68_CHAR ,A68_VC *,void *));
typedef struct A68t33  A68_33 ;    /* PROC(REF MODE26,CHAR) REF MODE26 */

A_PROCEDURE(A68_VOID ,A68t34,(A68_VC ,A68_CHAR ,A68_VC *),(A68_VC ,A68_CHAR ,A68_VC *,void *));
typedef struct A68t34  A68_34 ;    /* PROC(MODE26,CHAR) MODE26 */
struct A68t36 ;

A_PROCEDURE(A68_VOID ,A68t35,(struct A68t36 ,A68_VC *),(struct A68t36 ,A68_VC *,void *));
typedef struct A68t35  A68_35 ;    /* PROC(MODE36) REF MODE26 */
A_VECTOR(A68_VC ,A68t36);
typedef struct A68t36  A68_36 ;    /* VECTOR [] MODE26 */

A_PROCEDURE(A68_INT ,A68t37,(A68_CHAR ,A68_VC ),(A68_CHAR ,A68_VC ,void *));
typedef struct A68t37  A68_37 ;    /* PROC(CHAR,MODE26) INT */

A_PROCEDURE(A68_VOID ,A68t38,(A68_VC ,A68_VC *),(A68_VC ,A68_VC *,void *));
typedef struct A68t38  A68_38 ;    /* PROC(MODE26) REF MODE26 */

A_PROCEDURE(A68_VOID ,A68t39,(A68_VC ,A68_CHAR ),(A68_VC ,A68_CHAR ,void *));
typedef struct A68t39  A68_39 ;    /* PROC(REF MODE26,CHAR) VOID */
A_ISTRUCT(A68_CHAR ,4,A68t40);
typedef struct A68t40  A68_40 ;    /* STRUCT 4 CHAR */

A_PROCEDURE(struct A68t40 ,A68t41,(A68_INT ),(A68_INT ,void *));
typedef struct A68t41  A68_41 ;    /* PROC(INT) MODE40 */

A_PROCEDURE(A68_INT ,A68t42,(A68_INT ,A68_INT ),(A68_INT ,A68_INT ,void *));
typedef struct A68t42  A68_42 ;    /* PROC(INT,INT) INT */

A_PROCEDURE(A68_VOID ,A68t43,(A68_CHAR ,A68_VC ,A68_VC *),(A68_CHAR ,A68_VC ,A68_VC *,void *));
typedef struct A68t43  A68_43 ;    /* PROC(CHAR,REF MODE26) REF MODE26 */

A_PROCEDURE(A68_INT ,A68t44,(A68_VC ),(A68_VC ,void *));
typedef struct A68t44  A68_44 ;    /* PROC(MODE26) INT */

A_PROCEDURE(A68_BITS ,A68t45,(A68_BITS ,A68_BITS ),(A68_BITS ,A68_BITS ,void *));
typedef struct A68t45  A68_45 ;    /* PROC(BITS,BITS) BITS */

A_PROCEDURE(A68_LBITS ,A68t46,(A68_LBITS ,A68_LBITS ),(A68_LBITS ,A68_LBITS ,void *));
typedef struct A68t46  A68_46 ;    /* PROC(LONG BITS,LONG BITS) LONG BITS */

A_PROCEDURE(A68_BITS *,A68t47,(A68_BITS *,A68_BITS ),(A68_BITS *,A68_BITS ,void *));
typedef struct A68t47  A68_47 ;    /* PROC(REF BITS,BITS) REF BITS */

A_PROCEDURE(A68_VOID ,A68t48,(A68_INT ,A68_VC *),(A68_INT ,A68_VC *,void *));
typedef struct A68t48  A68_48 ;    /* PROC(INT) MODE26 */

A_PROCEDURE(A68_VOID ,A68t49,(A68_INT ,A68_INT ,A68_VC *),(A68_INT ,A68_INT ,A68_VC *,void *));
typedef struct A68t49  A68_49 ;    /* PROC(INT,INT) REF MODE26 */

A_PROCEDURE(A68_VOID ,A68t50,(A68_LINT ,A68_INT ,A68_VC *),(A68_LINT ,A68_INT ,A68_VC *,void *));
typedef struct A68t50  A68_50 ;    /* PROC(LONG INT,INT) REF MODE26 */

A_PROCEDURE(A68_BOOL ,A68t51,(A68_CHAR ,A68_INT *,A68_VC ),(A68_CHAR ,A68_INT *,A68_VC ,void *));
typedef struct A68t51  A68_51 ;    /* PROC(CHAR,REF INT,MODE26) BOOL */

A_PROCEDURE(A68_VOID ,A68t52,(A68_LBITS ,A68_INT ,A68_VC *),(A68_LBITS ,A68_INT ,A68_VC *,void *));
typedef struct A68t52  A68_52 ;    /* PROC(LONG BITS,INT) REF MODE26 */

A_PROCEDURE(A68_BOOL ,A68t53,(A68_INT *,A68_VC ),(A68_INT *,A68_VC ,void *));
typedef struct A68t53  A68_53 ;    /* PROC(REF INT,MODE26) BOOL */

A_PROCEDURE(A68_VOID ,A68t54,(A68_BOOL ,A68_VC *),(A68_BOOL ,A68_VC *,void *));
typedef struct A68t54  A68_54 ;    /* PROC(BOOL) MODE26 */

A_PROCEDURE(A68_VOID ,A68t55,(void),(void *));
typedef struct A68t55  A68_55 ;    /* PROC VOID */

A_PROCEDURE(A68_VOID ,A68t56,(struct A68t55 ),(struct A68t55 ,void *));
typedef struct A68t56  A68_56 ;    /* PROC(MODE55) VOID */

A_PROCEDURE(A68_VOID ,A68t57,(A68_VC ),(A68_VC ,void *));
typedef struct A68t57  A68_57 ;    /* PROC(MODE26) VOID */

A_PROCEDURE(A68_VOID ,A68t58,(struct A68t57 ),(struct A68t57 ,void *));
typedef struct A68t58  A68_58 ;    /* PROC(MODE57) VOID */

A_PROCEDURE(A68_VOID ,A68t59,(A68_VC ,A68_VC ),(A68_VC ,A68_VC ,void *));
typedef struct A68t59  A68_59 ;    /* PROC(MODE26,MODE26) VOID */
A_ISTRUCT(A68_CHAR ,57,A68t60);
typedef struct A68t60  A68_60 ;    /* STRUCT 57 CHAR */

A_PROCEDURE(A68_VOID ,A68t61,(A68_INT ,A68_VC *),(A68_INT ,A68_VC *,void *));
typedef struct A68t61  A68_61 ;    /* PROC(INT) REF MODE26 */
A_ISTRUCT(A68_CHAR ,2,A68t62);
typedef struct A68t62  A68_62 ;    /* STRUCT 2 CHAR */
A_ISTRUCT(A68_CHAR ,8,A68t63);
typedef struct A68t63  A68_63 ;    /* STRUCT 8 CHAR */
A_ISTRUCT(A68_CHAR ,5,A68t64);
typedef struct A68t64  A68_64 ;    /* STRUCT 5 CHAR */
A_ISTRUCT(A68_CHAR ,1,A68t65);
typedef struct A68t65  A68_65 ;    /* STRUCT 0 CHAR */
A_ISTRUCT(A68_CHAR ,3,A68t66);
typedef struct A68t66  A68_66 ;    /* STRUCT 3 CHAR */
A_ISTRUCT(A68_CHAR ,7,A68t67);
typedef struct A68t67  A68_67 ;    /* STRUCT 7 CHAR */
A_ISTRUCT(A68_CHAR ,10,A68t68);
typedef struct A68t68  A68_68 ;    /* STRUCT 10 CHAR */
A_ISTRUCT(A68_CHAR ,11,A68t69);
typedef struct A68t69  A68_69 ;    /* STRUCT 11 CHAR */
A_ISTRUCT(A68_CHAR ,9,A68t70);
typedef struct A68t70  A68_70 ;    /* STRUCT 9 CHAR */
A_ISTRUCT(A68_CHAR ,6,A68t71);
typedef struct A68t71  A68_71 ;    /* STRUCT 6 CHAR */
A_ISTRUCT(A68_CHAR ,14,A68t72);
typedef struct A68t72  A68_72 ;    /* STRUCT 14 CHAR */
A_ISTRUCT(A68_CHAR ,16,A68t73);
typedef struct A68t73  A68_73 ;    /* STRUCT 16 CHAR */
A_ISTRUCT(A68_CHAR ,13,A68t74);
typedef struct A68t74  A68_74 ;    /* STRUCT 13 CHAR */
A_ISTRUCT(A68_CHAR ,15,A68t75);
typedef struct A68t75  A68_75 ;    /* STRUCT 15 CHAR */
A_ISTRUCT(A68_CHAR ,17,A68t76);
typedef struct A68t76  A68_76 ;    /* STRUCT 17 CHAR */
A_ISTRUCT(A68_CHAR ,45,A68t77);
typedef struct A68t77  A68_77 ;    /* STRUCT 45 CHAR */
A_ISTRUCT(A68_CHAR ,30,A68t78);
typedef struct A68t78  A68_78 ;    /* STRUCT 30 CHAR */
A_ISTRUCT(A68_CHAR ,19,A68t79);
typedef struct A68t79  A68_79 ;    /* STRUCT 19 CHAR */
A_ISTRUCT(A68_CHAR ,39,A68t80);
typedef struct A68t80  A68_80 ;    /* STRUCT 39 CHAR */
A_ISTRUCT(A68_CHAR ,28,A68t81);
typedef struct A68t81  A68_81 ;    /* STRUCT 28 CHAR */
A_ISTRUCT(A68_CHAR ,26,A68t82);
typedef struct A68t82  A68_82 ;    /* STRUCT 26 CHAR */
A_ISTRUCT(A68_CHAR ,50,A68t83);
typedef struct A68t83  A68_83 ;    /* STRUCT 50 CHAR */
A_ISTRUCT(A68_CHAR ,49,A68t84);
typedef struct A68t84  A68_84 ;    /* STRUCT 49 CHAR */
A_ISTRUCT(A68_CHAR ,32,A68t85);
typedef struct A68t85  A68_85 ;    /* STRUCT 32 CHAR */
A_ISTRUCT(A68_CHAR ,40,A68t86);
typedef struct A68t86  A68_86 ;    /* STRUCT 40 CHAR */
A_ISTRUCT(A68_CHAR ,43,A68t87);
typedef struct A68t87  A68_87 ;    /* STRUCT 43 CHAR */
A_ISTRUCT(A68_CHAR ,22,A68t88);
typedef struct A68t88  A68_88 ;    /* STRUCT 22 CHAR */
A_ISTRUCT(A68_CHAR ,23,A68t89);
typedef struct A68t89  A68_89 ;    /* STRUCT 23 CHAR */
A_ISTRUCT(A68_CHAR ,67,A68t90);
typedef struct A68t90  A68_90 ;    /* STRUCT 67 CHAR */
A_ISTRUCT(A68_CHAR ,72,A68t91);
typedef struct A68t91  A68_91 ;    /* STRUCT 72 CHAR */
A_ISTRUCT(A68_CHAR ,48,A68t92);
typedef struct A68t92  A68_92 ;    /* STRUCT 48 CHAR */
A_ISTRUCT(A68_CHAR ,46,A68t93);
typedef struct A68t93  A68_93 ;    /* STRUCT 46 CHAR */
A_ISTRUCT(A68_CHAR ,52,A68t94);
typedef struct A68t94  A68_94 ;    /* STRUCT 52 CHAR */
A_ISTRUCT(A68_CHAR ,33,A68t95);
typedef struct A68t95  A68_95 ;    /* STRUCT 33 CHAR */
A_ISTRUCT(A68_CHAR ,34,A68t96);
typedef struct A68t96  A68_96 ;    /* STRUCT 34 CHAR */
A_ISTRUCT(A68_CHAR ,37,A68t97);
typedef struct A68t97  A68_97 ;    /* STRUCT 37 CHAR */
A_ISTRUCT(A68_CHAR ,31,A68t98);
typedef struct A68t98  A68_98 ;    /* STRUCT 31 CHAR */
A_ISTRUCT(A68_CHAR ,38,A68t99);
typedef struct A68t99  A68_99 ;    /* STRUCT 38 CHAR */
A_ISTRUCT(A68_CHAR ,35,A68t100);
typedef struct A68t100  A68_100 ;    /* STRUCT 35 CHAR */
A_ISTRUCT(A68_CHAR ,25,A68t101);
typedef struct A68t101  A68_101 ;    /* STRUCT 25 CHAR */
A_ISTRUCT(A68_CHAR ,24,A68t102);
typedef struct A68t102  A68_102 ;    /* STRUCT 24 CHAR */
A_ISTRUCT(A68_CHAR ,54,A68t103);
typedef struct A68t103  A68_103 ;    /* STRUCT 54 CHAR */
A_ISTRUCT(A68_CHAR ,27,A68t104);
typedef struct A68t104  A68_104 ;    /* STRUCT 27 CHAR */
A_ISTRUCT(A68_CHAR ,29,A68t105);
typedef struct A68t105  A68_105 ;    /* STRUCT 29 CHAR */
A_ISTRUCT(A68_CHAR ,41,A68t106);
typedef struct A68t106  A68_106 ;    /* STRUCT 41 CHAR */
A_ISTRUCT(A68_CHAR ,44,A68t107);
typedef struct A68t107  A68_107 ;    /* STRUCT 44 CHAR */
A_ISTRUCT(A68_CHAR ,36,A68t108);
typedef struct A68t108  A68_108 ;    /* STRUCT 36 CHAR */
A_ISTRUCT(A68_CHAR ,18,A68t109);
typedef struct A68t109  A68_109 ;    /* STRUCT 18 CHAR */
A_ISTRUCT(A68_CHAR ,47,A68t110);
typedef struct A68t110  A68_110 ;    /* STRUCT 47 CHAR */
A_ISTRUCT(A68_CHAR ,42,A68t111);
typedef struct A68t111  A68_111 ;    /* STRUCT 42 CHAR */
A_ISTRUCT(A68_CHAR ,20,A68t112);
typedef struct A68t112  A68_112 ;    /* STRUCT 20 CHAR */
A_ISTRUCT(A68_CHAR ,56,A68t113);
typedef struct A68t113  A68_113 ;    /* STRUCT 56 CHAR */
A_ISTRUCT(A68_CHAR ,58,A68t114);
typedef struct A68t114  A68_114 ;    /* STRUCT 58 CHAR */
A_ISTRUCT(A68_CHAR ,69,A68t115);
typedef struct A68t115  A68_115 ;    /* STRUCT 69 CHAR */
A_ISTRUCT(A68_CHAR ,71,A68t116);
typedef struct A68t116  A68_116 ;    /* STRUCT 71 CHAR */
A_ISTRUCT(A68_CHAR ,70,A68t117);
typedef struct A68t117  A68_117 ;    /* STRUCT 70 CHAR */
A_ISTRUCT(A68_CHAR ,62,A68t118);
typedef struct A68t118  A68_118 ;    /* STRUCT 62 CHAR */
A_ISTRUCT(A68_CHAR ,66,A68t119);
typedef struct A68t119  A68_119 ;    /* STRUCT 66 CHAR */
A_ISTRUCT(A68_CHAR ,53,A68t120);
typedef struct A68t120  A68_120 ;    /* STRUCT 53 CHAR */
A_ISTRUCT(A68_CHAR ,68,A68t121);
typedef struct A68t121  A68_121 ;    /* STRUCT 68 CHAR */
A_ISTRUCT(A68_CHAR ,76,A68t122);
typedef struct A68t122  A68_122 ;    /* STRUCT 76 CHAR */
A_ISTRUCT(A68_CHAR ,84,A68t123);
typedef struct A68t123  A68_123 ;    /* STRUCT 84 CHAR */
A_ISTRUCT(A68_CHAR ,59,A68t124);
typedef struct A68t124  A68_124 ;    /* STRUCT 59 CHAR */
A_ISTRUCT(A68_CHAR ,61,A68t125);
typedef struct A68t125  A68_125 ;    /* STRUCT 61 CHAR */
A_ISTRUCT(A68_CHAR ,92,A68t126);
typedef struct A68t126  A68_126 ;    /* STRUCT 92 CHAR */
A_ISTRUCT(A68_CHAR ,80,A68t127);
typedef struct A68t127  A68_127 ;    /* STRUCT 80 CHAR */
A_ISTRUCT(A68_CHAR ,89,A68t128);
typedef struct A68t128  A68_128 ;    /* STRUCT 89 CHAR */
A_ISTRUCT(A68_CHAR ,90,A68t129);
typedef struct A68t129  A68_129 ;    /* STRUCT 90 CHAR */
A_ISTRUCT(A68_CHAR ,81,A68t130);
typedef struct A68t130  A68_130 ;    /* STRUCT 81 CHAR */
A_ISTRUCT(A68_CHAR ,78,A68t131);
typedef struct A68t131  A68_131 ;    /* STRUCT 78 CHAR */
A_ISTRUCT(A68_CHAR ,91,A68t132);
typedef struct A68t132  A68_132 ;    /* STRUCT 91 CHAR */
A_ISTRUCT(A68_CHAR ,77,A68t133);
typedef struct A68t133  A68_133 ;    /* STRUCT 77 CHAR */
A_ISTRUCT(A68_CHAR ,75,A68t134);
typedef struct A68t134  A68_134 ;    /* STRUCT 75 CHAR */
A_ISTRUCT(A68_CHAR ,82,A68t135);
typedef struct A68t135  A68_135 ;    /* STRUCT 82 CHAR */
A_ISTRUCT(A68_CHAR ,73,A68t136);
typedef struct A68t136  A68_136 ;    /* STRUCT 73 CHAR */
A_ISTRUCT(A68_CHAR ,60,A68t137);
typedef struct A68t137  A68_137 ;    /* STRUCT 60 CHAR */
A_ISTRUCT(A68_CHAR ,95,A68t138);
typedef struct A68t138  A68_138 ;    /* STRUCT 95 CHAR */
A_ISTRUCT(A68_CHAR ,88,A68t139);
typedef struct A68t139  A68_139 ;    /* STRUCT 88 CHAR */
A_ISTRUCT(A68_CHAR ,96,A68t140);
typedef struct A68t140  A68_140 ;    /* STRUCT 96 CHAR */
A_ISTRUCT(A68_CHAR ,74,A68t141);
typedef struct A68t141  A68_141 ;    /* STRUCT 74 CHAR */
A_ISTRUCT(A68_CHAR ,51,A68t142);
typedef struct A68t142  A68_142 ;    /* STRUCT 51 CHAR */
A_ISTRUCT(A68_CHAR ,55,A68t143);
typedef struct A68t143  A68_143 ;    /* STRUCT 55 CHAR */

A_PROCEDURE(A68_VOID ,A68t144,(A68_BOOL ),(A68_BOOL ,void *));
typedef struct A68t144  A68_144 ;    /* PROC(BOOL) VOID */

/* --- Imports from a68config --- */
extern A68_VOID  UEAALIB_a68config(A68_VC ,A68_VC );
static A68_VC  A_configinfo;
/* A cheat - pass a REF through the DECS Module restriction via STR */
#define ACONFIG ( A_configinfo.data = (A68_CHAR*)(&A_config), \
                  A_configinfo.upb = (A68_INT)(-777), A_configinfo )

#define LGAALIB_configinfo ACONFIG
/* --- End of imports from a68config --- */


/* --- Imports from usefulops --- */
extern A68_VOID  ROAAOSF_whole(A68_INT ,A68_INT ,A68_VC *);
/* --- End of imports from usefulops --- */


/* --- DECS initialisation functions --- */
extern void BAAALIB(void);   /* a68config */
extern void IKAAOSF(void);   /* usefulops */
/* --- end of DECS initialisation functions --- */
static A68_60   GDHACTR = {"$Id: message.a68,v 1.1.1.1 2001-05-07 10:16:10 sian Exp $"}; 
A_GISVEC(A68_VC ,HDHACTR,GDHACTR,57)
static A68_BOOL  IDHACTR_longlongoption;
static A68_62   NDHACTR = {"] "}; 
A_GISVEC(A68_VC ,ODHACTR,NDHACTR,2)
static A68_63   PDHACTR = {"STRUCT ("}; 
A_GISVEC(A68_VC ,QDHACTR,PDHACTR,8)
static A68_64   RDHACTR = {"PROC "}; 
A_GISVEC(A68_VC ,SDHACTR,RDHACTR,5)
static A68_65   TDHACTR = {""}; 
A_GISVEC(A68_VC ,UDHACTR,TDHACTR,0)
static A68_40   WDHACTR = {"THEN"}; 
A_GISVEC(A68_VC ,XDHACTR,WDHACTR,4)
static A68_62   YDHACTR = {"IN"}; 
A_GISVEC(A68_VC ,ZDHACTR,YDHACTR,2)
static A68_40   AEHACTR = {"ELSE"}; 
A_GISVEC(A68_VC ,BEHACTR,AEHACTR,4)
static A68_66   CEHACTR = {"OUT"}; 
A_GISVEC(A68_VC ,DEHACTR,CEHACTR,3)
static A68_66   FEHACTR = {"END"}; 
A_GISVEC(A68_VC ,GEHACTR,FEHACTR,3)
static A68_62   HEHACTR = {"FI"}; 
A_GISVEC(A68_VC ,IEHACTR,HEHACTR,2)
static A68_40   JEHACTR = {"ESAC"}; 
A_GISVEC(A68_VC ,KEHACTR,JEHACTR,4)
static A68_67   LEHACTR = {"program"}; 
A_GISVEC(A68_VC ,MEHACTR,LEHACTR,7)
static A68_68   OEHACTR = {"!anonymous"}; 
A_GISVEC(A68_VC ,PEHACTR,OEHACTR,10)
static A68_68   QEHACTR = {"!generator"}; 
A_GISVEC(A68_VC ,REHACTR,QEHACTR,10)
static A68_69   SEHACTR = {"!assignment"}; 
A_GISVEC(A68_VC ,TEHACTR,SEHACTR,11)
static A68_70   UEHACTR = {"!straight"}; 
A_GISVEC(A68_VC ,VEHACTR,UEHACTR,9)
static A68_67   WEHACTR = {"!format"}; 
A_GISVEC(A68_VC ,XEHACTR,WEHACTR,7)
static A68_62   ZEHACTR = {"re"}; 
A_GISVEC(A68_VC ,AFHACTR,ZEHACTR,2)
static A68_62   BFHACTR = {"im"}; 
A_GISVEC(A68_VC ,CFHACTR,BFHACTR,2)
static A68_68   DFHACTR = {"collateral"}; 
A_GISVEC(A68_VC ,EFHACTR,DFHACTR,10)
static A68_40   FFHACTR = {"SKIP"}; 
A_GISVEC(A68_VC ,GFHACTR,FFHACTR,4)
static A68_66   HFHACTR = {"NIL"}; 
A_GISVEC(A68_VC ,IFHACTR,HFHACTR,3)
static A68_40   JFHACTR = {"GOTO"}; 
A_GISVEC(A68_VC ,KFHACTR,JFHACTR,4)
static A68_40   LFHACTR = {"VOID"}; 
A_GISVEC(A68_VC ,MFHACTR,LFHACTR,4)
static A68_64   NFHACTR = {"FLEX "}; 
A_GISVEC(A68_VC ,OFHACTR,NFHACTR,5)
static A68_40   PFHACTR = {"BOOL"}; 
A_GISVEC(A68_VC ,QFHACTR,PFHACTR,4)
static A68_40   RFHACTR = {"CHAR"}; 
A_GISVEC(A68_VC ,SFHACTR,RFHACTR,4)
static A68_71   TFHACTR = {"FORMAT"}; 
A_GISVEC(A68_VC ,UFHACTR,TFHACTR,6)
static A68_68   VFHACTR = {"SHORT BITS"}; 
A_GISVEC(A68_VC ,WFHACTR,VFHACTR,10)
static A68_70   XFHACTR = {"LONG BITS"}; 
A_GISVEC(A68_VC ,YFHACTR,XFHACTR,9)
static A68_40   ZFHACTR = {"BITS"}; 
A_GISVEC(A68_VC ,AGHACTR,ZFHACTR,4)
static A68_70   BGHACTR = {"LONG BITS"}; 
A_GISVEC(A68_VC ,CGHACTR,BGHACTR,9)
static A68_68   DGHACTR = {"SHORT BITS"}; 
A_GISVEC(A68_VC ,EGHACTR,DGHACTR,10)
static A68_72   FGHACTR = {"LONG LONG BITS"}; 
A_GISVEC(A68_VC ,GGHACTR,FGHACTR,14)
static A68_73   HGHACTR = {"SHORT SHORT BITS"}; 
A_GISVEC(A68_VC ,IGHACTR,HGHACTR,16)
static A68_70   JGHACTR = {"SHORT INT"}; 
A_GISVEC(A68_VC ,KGHACTR,JGHACTR,9)
static A68_63   LGHACTR = {"LONG INT"}; 
A_GISVEC(A68_VC ,MGHACTR,LGHACTR,8)
static A68_66   NGHACTR = {"INT"}; 
A_GISVEC(A68_VC ,OGHACTR,NGHACTR,3)
static A68_63   PGHACTR = {"LONG INT"}; 
A_GISVEC(A68_VC ,QGHACTR,PGHACTR,8)
static A68_70   RGHACTR = {"SHORT INT"}; 
A_GISVEC(A68_VC ,SGHACTR,RGHACTR,9)
static A68_74   TGHACTR = {"LONG LONG INT"}; 
A_GISVEC(A68_VC ,UGHACTR,TGHACTR,13)
static A68_75   VGHACTR = {"SHORT SHORT INT"}; 
A_GISVEC(A68_VC ,WGHACTR,VGHACTR,15)
static A68_68   XGHACTR = {"SHORT REAL"}; 
A_GISVEC(A68_VC ,YGHACTR,XGHACTR,10)
static A68_70   ZGHACTR = {"LONG REAL"}; 
A_GISVEC(A68_VC ,AHHACTR,ZGHACTR,9)
static A68_40   BHHACTR = {"REAL"}; 
A_GISVEC(A68_VC ,CHHACTR,BHHACTR,4)
static A68_70   DHHACTR = {"LONG REAL"}; 
A_GISVEC(A68_VC ,EHHACTR,DHHACTR,9)
static A68_68   FHHACTR = {"SHORT REAL"}; 
A_GISVEC(A68_VC ,GHHACTR,FHHACTR,10)
static A68_72   HHHACTR = {"LONG LONG REAL"}; 
A_GISVEC(A68_VC ,IHHACTR,HHHACTR,14)
static A68_73   JHHACTR = {"SHORT SHORT REAL"}; 
A_GISVEC(A68_VC ,KHHACTR,JHHACTR,16)
static A68_69   LHHACTR = {"SHORT COMPL"}; 
A_GISVEC(A68_VC ,MHHACTR,LHHACTR,11)
static A68_68   NHHACTR = {"LONG COMPL"}; 
A_GISVEC(A68_VC ,OHHACTR,NHHACTR,10)
static A68_64   PHHACTR = {"COMPL"}; 
A_GISVEC(A68_VC ,QHHACTR,PHHACTR,5)
static A68_68   RHHACTR = {"LONG COMPL"}; 
A_GISVEC(A68_VC ,SHHACTR,RHHACTR,10)
static A68_69   THHACTR = {"SHORT COMPL"}; 
A_GISVEC(A68_VC ,UHHACTR,THHACTR,11)
static A68_75   VHHACTR = {"LONG LONG COMPL"}; 
A_GISVEC(A68_VC ,WHHACTR,VHHACTR,15)
static A68_76   XHHACTR = {"SHORT SHORT COMPL"}; 
A_GISVEC(A68_VC ,YHHACTR,XHHACTR,17)
static A68_40   ZHHACTR = {"REF "}; 
A_GISVEC(A68_VC ,AIHACTR,ZHHACTR,4)
static A68_67   BIHACTR = {"UNION ("}; 
A_GISVEC(A68_VC ,CIHACTR,BIHACTR,7)
static A68_71   DIHACTR = {"PROC ("}; 
A_GISVEC(A68_VC ,EIHACTR,DIHACTR,6)
static A68_64   FIHACTR = {"XTYPE"}; 
A_GISVEC(A68_VC ,GIHACTR,FIHACTR,5)
static A68_64   HIHACTR = {"YTYPE"}; 
A_GISVEC(A68_VC ,IIHACTR,HIHACTR,5)
static A68_68   JIHACTR = {"VECTOR[ ] "}; 
A_GISVEC(A68_VC ,KIHACTR,JIHACTR,10)
static A68_70   LIHACTR = {"STRAIGHT "}; 
A_GISVEC(A68_VC ,MIHACTR,LIHACTR,9)
static A68_71   NIHACTR = {", . . "}; 
A_GISVEC(A68_VC ,OIHACTR,NIHACTR,6)
static A68_65   PIHACTR = {""}; 
A_GISVEC(A68_VC ,QIHACTR,PIHACTR,0)
static A68_77   RIHACTR = {"(101) compilation abandoned - too many errors"}; 
A_GISVEC(A68_VC ,SIHACTR,RIHACTR,45)
static A68_78   TIHACTR = {"(102) character not recognised"}; 
A_GISVEC(A68_VC ,UIHACTR,TIHACTR,30)
static A68_79   VIHACTR = {"(103) illegal radix"}; 
A_GISVEC(A68_VC ,WIHACTR,VIHACTR,19)
static A68_78   XIHACTR = {"(104) string goes over newline"}; 
A_GISVEC(A68_VC ,YIHACTR,XIHACTR,30)
static A68_80   ZIHACTR = {"(105) illegal character in radix string"}; 
A_GISVEC(A68_VC ,AJHACTR,ZIHACTR,39)
static A68_81   BJHACTR = {"(106) illegal symbol after r"}; 
A_GISVEC(A68_VC ,CJHACTR,BJHACTR,28)
static A68_82   DJHACTR = {"(107) missing strop symbol"}; 
A_GISVEC(A68_VC ,EJHACTR,DJHACTR,26)
static A68_83   FJHACTR = {"(108) decs module restriction - no procedure calls"}; 
A_GISVEC(A68_VC ,GJHACTR,FJHACTR,50)
static A68_84   HJHACTR = {"(109) .1 can be united to .2 in more than one way"}; 
A_GISVEC(A68_VC ,IJHACTR,HJHACTR,49)
static A68_85   JJHACTR = {"(110) .1 cannot be coerced to .2"}; 
A_GISVEC(A68_VC ,KJHACTR,JJHACTR,32)
static A68_86   LJHACTR = {"(111) collateral cannot be coerced to .1"}; 
A_GISVEC(A68_VC ,MJHACTR,LJHACTR,40)
static A68_87   NJHACTR = {"(112) end of file inside comment or pragmat"}; 
A_GISVEC(A68_VC ,OJHACTR,NJHACTR,43)
static A68_88   PJHACTR = {"(113) comment mismatch"}; 
A_GISVEC(A68_VC ,QJHACTR,PJHACTR,22)
static A68_76   RJHACTR = {"(114) end of file"}; 
A_GISVEC(A68_VC ,SJHACTR,RJHACTR,17)
static A68_89   TJHACTR = {"(115) .3 not recognised"}; 
A_GISVEC(A68_VC ,UJHACTR,TJHACTR,23)
static A68_89   VJHACTR = {"(116) brackets mismatch"}; 
A_GISVEC(A68_VC ,WJHACTR,VJHACTR,23)
static A68_82   XJHACTR = {"(117) FINISH expected here"}; 
A_GISVEC(A68_VC ,YJHACTR,XJHACTR,26)
static A68_88   ZJHACTR = {"(118) .3 expected here"}; 
A_GISVEC(A68_VC ,AKHACTR,ZJHACTR,22)
static A68_90   BKHACTR = {"(119) decs module cannot access kept object whose mode contains REF"}; 
A_GISVEC(A68_VC ,CKHACTR,BKHACTR,67)
static A68_91   DKHACTR = {"(120) decs module cannot access kept object whose mode contains STRAIGHT"}; 
A_GISVEC(A68_VC ,EKHACTR,DKHACTR,72)
static A68_81   FKHACTR = {"(121) .1 is not a legal mode"}; 
A_GISVEC(A68_VC ,GKHACTR,FKHACTR,28)
static A68_92   HKHACTR = {"(122) object of mode STRAIGHT cannot be assigned"}; 
A_GISVEC(A68_VC ,IKHACTR,HKHACTR,48)
static A68_86   JKHACTR = {"(123) HERE .4 not declared or used twice"}; 
A_GISVEC(A68_VC ,KKHACTR,JKHACTR,40)
static A68_93   LKHACTR = {"(124) module .4 no longer has the same formals"}; 
A_GISVEC(A68_VC ,MKHACTR,LKHACTR,46)
static A68_85   NKHACTR = {"(125) module .4 has changed type"}; 
A_GISVEC(A68_VC ,OKHACTR,NKHACTR,32)
static A68_94   PKHACTR = {"(126) module .4 does not have this number of formals"}; 
A_GISVEC(A68_VC ,QKHACTR,PKHACTR,52)
static A68_95   RKHACTR = {"(127) module .4 does not fit here"}; 
A_GISVEC(A68_VC ,SKHACTR,RKHACTR,33)
static A68_96   TKHACTR = {"(128) .4 is not a formal of module"}; 
A_GISVEC(A68_VC ,UKHACTR,TKHACTR,34)
static A68_81   VKHACTR = {"(129) .4 not accessible here"}; 
A_GISVEC(A68_VC ,WKHACTR,VKHACTR,28)
static A68_97   XKHACTR = {"(130) decs module .4 in wrong context"}; 
A_GISVEC(A68_VC ,YKHACTR,XKHACTR,37)
static A68_85   ZKHACTR = {"(131) identifier .4 not declared"}; 
A_GISVEC(A68_VC ,ALHACTR,ZKHACTR,32)
static A68_78   BLHACTR = {"(132) FINISH not expected here"}; 
A_GISVEC(A68_VC ,CLHACTR,BLHACTR,30)
static A68_94   DLHACTR = {"(133) compilation abandoned - too many syntax errors"}; 
A_GISVEC(A68_VC ,ELHACTR,DLHACTR,52)
static A68_98   FLHACTR = {"(134) unexpected symbol in mode"}; 
A_GISVEC(A68_VC ,GLHACTR,FLHACTR,31)
static A68_98   HLHACTR = {"(135) cannot have zero elements"}; 
A_GISVEC(A68_VC ,ILHACTR,HLHACTR,31)
static A68_95   JLHACTR = {"(136) unexpected symbol in format"}; 
A_GISVEC(A68_VC ,KLHACTR,JLHACTR,33)
static A68_96   LLHACTR = {"(137) replication not allowed here"}; 
A_GISVEC(A68_VC ,MLHACTR,LLHACTR,34)
static A68_89   NLHACTR = {"(138) unexpected symbol"}; 
A_GISVEC(A68_VC ,OLHACTR,NLHACTR,23)
static A68_99   PLHACTR = {"(139) bounds not needed in result mode"}; 
A_GISVEC(A68_VC ,QLHACTR,PLHACTR,38)
static A68_93   RLHACTR = {"(140) BOOL, INT or UNION required here, not .1"}; 
A_GISVEC(A68_VC ,SLHACTR,RLHACTR,46)
static A68_100   TLHACTR = {"(141) bounds required in generators"}; 
A_GISVEC(A68_VC ,ULHACTR,TLHACTR,35)
static A68_92   VLHACTR = {"(142) proc with parameters required here, not .1"}; 
A_GISVEC(A68_VC ,WLHACTR,VLHACTR,48)
static A68_101   XLHACTR = {"(143) too many parameters"}; 
A_GISVEC(A68_VC ,YLHACTR,XLHACTR,25)
static A68_102   ZLHACTR = {"(144) too few parameters"}; 
A_GISVEC(A68_VC ,AMHACTR,ZLHACTR,24)
static A68_88   BMHACTR = {"(145) illegal exponent"}; 
A_GISVEC(A68_VC ,CMHACTR,BMHACTR,22)
static A68_95   DMHACTR = {"(146) more than one version of .3"}; 
A_GISVEC(A68_VC ,EMHACTR,DMHACTR,33)
static A68_99   FMHACTR = {"(147) op .3 not declared for .1 and .2"}; 
A_GISVEC(A68_VC ,GMHACTR,FMHACTR,38)
static A68_98   HMHACTR = {"(148) op .3 not declared for .1"}; 
A_GISVEC(A68_VC ,IMHACTR,HMHACTR,31)
static A68_103   JMHACTR = {"(149) decs module restriction - library operators only"}; 
A_GISVEC(A68_VC ,KMHACTR,JMHACTR,54)
static A68_78   LMHACTR = {"(150) bounds not required here"}; 
A_GISVEC(A68_VC ,MMHACTR,LMHACTR,30)
static A68_87   NMHACTR = {"(151) lhs of assignment must be a reference"}; 
A_GISVEC(A68_VC ,OMHACTR,NMHACTR,43)
static A68_86   PMHACTR = {"(152) selector .4 not defined for struct"}; 
A_GISVEC(A68_VC ,QMHACTR,PMHACTR,40)
static A68_104   RMHACTR = {"(153) .1 cannot be selected"}; 
A_GISVEC(A68_VC ,SMHACTR,RMHACTR,27)
static A68_85   TMHACTR = {"(154) .4 is not a legal modename"}; 
A_GISVEC(A68_VC ,UMHACTR,TMHACTR,32)
static A68_82   VMHACTR = {"(155) .1 cannot be indexed"}; 
A_GISVEC(A68_VC ,WMHACTR,VMHACTR,26)
static A68_105   XMHACTR = {"(156) wrong number of indices"}; 
A_GISVEC(A68_VC ,YMHACTR,XMHACTR,29)
static A68_104   ZMHACTR = {"(157) only one index needed"}; 
A_GISVEC(A68_VC ,ANHACTR,ZMHACTR,27)
static A68_94   BNHACTR = {"(158) straight must be indexed by a single subscript"}; 
A_GISVEC(A68_VC ,CNHACTR,BNHACTR,52)
static A68_86   DNHACTR = {"(159) elements of in-parts must be units"}; 
A_GISVEC(A68_VC ,ENHACTR,DNHACTR,40)
static A68_101   FNHACTR = {"(160) module .4 not found"}; 
A_GISVEC(A68_VC ,GNHACTR,FNHACTR,25)
static A68_86   HNHACTR = {"(161) op .3 not declared for these modes"}; 
A_GISVEC(A68_VC ,INHACTR,HNHACTR,40)
static A68_100   JNHACTR = {"(162) .3 already used at this level"}; 
A_GISVEC(A68_VC ,KNHACTR,JNHACTR,35)
static A68_106   LNHACTR = {"(163) bounds required in mode declaration"}; 
A_GISVEC(A68_VC ,MNHACTR,LNHACTR,41)
static A68_97   NNHACTR = {"(164) mode defined as (ref to) itself"}; 
A_GISVEC(A68_VC ,ONHACTR,NNHACTR,37)
static A68_82   PNHACTR = {"(165) mode .1 not declared"}; 
A_GISVEC(A68_VC ,QNHACTR,PNHACTR,26)
static A68_98   RNHACTR = {"(166) semicolon not needed here"}; 
A_GISVEC(A68_VC ,SNHACTR,RNHACTR,31)
static A68_80   TNHACTR = {"(167) priority must lie between 1 and 9"}; 
A_GISVEC(A68_VC ,UNHACTR,TNHACTR,39)
static A68_107   VNHACTR = {"(168) operator .3 has more than two operands"}; 
A_GISVEC(A68_VC ,WNHACTR,VNHACTR,44)
static A68_100   XNHACTR = {"(169) label not allowed after while"}; 
A_GISVEC(A68_VC ,YNHACTR,XNHACTR,35)
static A68_108   ZNHACTR = {"(170) operator .3 must have operands"}; 
A_GISVEC(A68_VC ,AOHACTR,ZNHACTR,36)
static A68_109   BOHACTR = {"(171) .1 not in .2"}; 
A_GISVEC(A68_VC ,COHACTR,BOHACTR,18)
static A68_108   DOHACTR = {"(172) identifier .4 already declared"}; 
A_GISVEC(A68_VC ,EOHACTR,DOHACTR,36)
static A68_104   FOHACTR = {"(173) HEAP not allowed here"}; 
A_GISVEC(A68_VC ,GOHACTR,FOHACTR,27)
static A68_92   HOHACTR = {"(174) no bounds required in identity declaration"}; 
A_GISVEC(A68_VC ,IOHACTR,HOHACTR,48)
static A68_106   JOHACTR = {"(175) bounds required in name declaration"}; 
A_GISVEC(A68_VC ,KOHACTR,JOHACTR,41)
static A68_106   LOHACTR = {"(176) declaration not allowed after label"}; 
A_GISVEC(A68_VC ,MOHACTR,LOHACTR,41)
static A68_105   NOHACTR = {"(177) label .4 declared twice"}; 
A_GISVEC(A68_VC ,OOHACTR,NOHACTR,29)
static A68_81   POHACTR = {"(178) label not allowed here"}; 
A_GISVEC(A68_VC ,QOHACTR,POHACTR,28)
static A68_98   ROHACTR = {"(179) FORALL not defined for .1"}; 
A_GISVEC(A68_VC ,SOHACTR,ROHACTR,31)
static A68_110   TOHACTR = {"(180) declaration must be followed by semicolon"}; 
A_GISVEC(A68_VC ,UOHACTR,TOHACTR,47)
static A68_111   VOHACTR = {"(181) bounds not allowed in parameter mode"}; 
A_GISVEC(A68_VC ,WOHACTR,VOHACTR,42)
static A68_82   XOHACTR = {"(182) equals required here"}; 
A_GISVEC(A68_VC ,YOHACTR,XOHACTR,26)
static A68_97   ZOHACTR = {"(183) .3 already a mode at this level"}; 
A_GISVEC(A68_VC ,APHACTR,ZOHACTR,37)
static A68_104   BPHACTR = {"(184) label .4 not declared"}; 
A_GISVEC(A68_VC ,CPHACTR,BPHACTR,27)
static A68_112   DPHACTR = {"(185) needs: HERE .4"}; 
A_GISVEC(A68_VC ,EPHACTR,DPHACTR,20)
static A68_95   FPHACTR = {"(186) undeclared .4 used .5 times"}; 
A_GISVEC(A68_VC ,GPHACTR,FPHACTR,33)
static A68_98   HPHACTR = {"(187) selector .4 defined twice"}; 
A_GISVEC(A68_VC ,IPHACTR,HPHACTR,31)
static A68_109   JPHACTR = {"(188) mixed bounds"}; 
A_GISVEC(A68_VC ,KPHACTR,JPHACTR,18)
static A68_109   LPHACTR = {"(189) already kept"}; 
A_GISVEC(A68_VC ,MPHACTR,LPHACTR,18)
static A68_113   NPHACTR = {"(190) objects of mode XTYPE and YTYPE cannot be assigned"}; 
A_GISVEC(A68_VC ,OPHACTR,NPHACTR,56)
static A68_101   PPHACTR = {"(191) .1 cannot be flexed"}; 
A_GISVEC(A68_VC ,QPHACTR,PPHACTR,25)
static A68_99   RPHACTR = {"(192) INT or UNION required after CASE"}; 
A_GISVEC(A68_VC ,SPHACTR,RPHACTR,38)
static A68_81   TPHACTR = {"(193) BOOL required after IF"}; 
A_GISVEC(A68_VC ,UPHACTR,TPHACTR,28)
static A68_114   VPHACTR = {"(194) decs module restriction - label .4 is in outer level"}; 
A_GISVEC(A68_VC ,WPHACTR,VPHACTR,58)
static A68_89   XPHACTR = {"(195) istruct too large"}; 
A_GISVEC(A68_VC ,YPHACTR,XPHACTR,23)
static A68_86   ZPHACTR = {"(196) built-in operators may not be kept"}; 
A_GISVEC(A68_VC ,AQHACTR,ZPHACTR,40)
static A68_78   BQHACTR = {"(197) hole .4 already declared"}; 
A_GISVEC(A68_VC ,CQHACTR,BQHACTR,30)
static A68_82   DQHACTR = {"(198) formal .4 used twice"}; 
A_GISVEC(A68_VC ,EQHACTR,DQHACTR,26)
static A68_101   FQHACTR = {"(199) .4 is a decs module"}; 
A_GISVEC(A68_VC ,GQHACTR,FQHACTR,25)
static A68_87   HQHACTR = {"(200) elements of collaterals must be units"}; 
A_GISVEC(A68_VC ,IQHACTR,HQHACTR,43)
static A68_98   JQHACTR = {"(201) no opening comment symbol"}; 
A_GISVEC(A68_VC ,KQHACTR,JQHACTR,31)
static A68_111   LQHACTR = {"(202) nested mode declarations not allowed"}; 
A_GISVEC(A68_VC ,MQHACTR,LQHACTR,42)
static A68_82   NQHACTR = {"(203) .3 not expected here"}; 
A_GISVEC(A68_VC ,OQHACTR,NQHACTR,26)
static A68_107   PQHACTR = {"(204) priority already defined at this level"}; 
A_GISVEC(A68_VC ,QQHACTR,PQHACTR,44)
static A68_106   RQHACTR = {"(205) label .4 already used as identifier"}; 
A_GISVEC(A68_VC ,SQHACTR,RQHACTR,41)
static A68_112   TQHACTR = {"(206) too many modes"}; 
A_GISVEC(A68_VC ,UQHACTR,TQHACTR,20)
static A68_104   VQHACTR = {"(207) syntax stack overflow"}; 
A_GISVEC(A68_VC ,WQHACTR,VQHACTR,27)
static A68_89   XQHACTR = {"(208) too many brackets"}; 
A_GISVEC(A68_VC ,YQHACTR,XQHACTR,23)
static A68_82   ZQHACTR = {"(209) mode too complicated"}; 
A_GISVEC(A68_VC ,ARHACTR,ZQHACTR,26)
static A68_82   BRHACTR = {"(210) too many identifiers"}; 
A_GISVEC(A68_VC ,CRHACTR,BRHACTR,26)
static A68_89   DRHACTR = {"(211) too many routines"}; 
A_GISVEC(A68_VC ,ERHACTR,DRHACTR,23)
static A68_96   FRHACTR = {"(212) too many library identifiers"}; 
A_GISVEC(A68_VC ,GRHACTR,FRHACTR,34)
static A68_105   HRHACTR = {"(213) BIOP ^a not implemented"}; 
A_GISVEC(A68_VC ,IRHACTR,HRHACTR,29)
static A68_87   JRHACTR = {"(214) Operand MODE not supported by BIOP ^a"}; 
A_GISVEC(A68_VC ,KRHACTR,JRHACTR,43)
static A68_86   LRHACTR = {"(250) The source file could not be found"}; 
A_GISVEC(A68_VC ,MRHACTR,LRHACTR,40)
static A68_71   NRHACTR = {"(251) "}; 
A_GISVEC(A68_VC ,ORHACTR,NRHACTR,6)
static A68_71   PRHACTR = {"(252) "}; 
A_GISVEC(A68_VC ,QRHACTR,PRHACTR,6)
static A68_115   RRHACTR = {"(253) This line is longer than 160 characters - it has been truncated"}; 
A_GISVEC(A68_VC ,SRHACTR,RRHACTR,69)
static A68_71   TRHACTR = {"(254) "}; 
A_GISVEC(A68_VC ,URHACTR,TRHACTR,6)
static A68_71   VRHACTR = {"(255) "}; 
A_GISVEC(A68_VC ,WRHACTR,VRHACTR,6)
static A68_71   XRHACTR = {"(256) "}; 
A_GISVEC(A68_VC ,YRHACTR,XRHACTR,6)
static A68_71   ZRHACTR = {"(257) "}; 
A_GISVEC(A68_VC ,ASHACTR,ZRHACTR,6)
static A68_71   BSHACTR = {"(258) "}; 
A_GISVEC(A68_VC ,CSHACTR,BSHACTR,6)
static A68_71   DSHACTR = {"(259) "}; 
A_GISVEC(A68_VC ,ESHACTR,DSHACTR,6)
static A68_71   FSHACTR = {"(260) "}; 
A_GISVEC(A68_VC ,GSHACTR,FSHACTR,6)
static A68_106   HSHACTR = {"(261) Invalid module keeplist information"}; 
A_GISVEC(A68_VC ,ISHACTR,HSHACTR,41)
static A68_116   JSHACTR = {"(262) An existing version of module '^a' has invalid module information"}; 
A_GISVEC(A68_VC ,KSHACTR,JSHACTR,71)
static A68_117   LSHACTR = {"(263) Call of PROC ^a has ^a parameters, ^a with possible side effects"}; 
A_GISVEC(A68_VC ,MSHACTR,LSHACTR,70)
static A68_92   NSHACTR = {"(264) Trimscript of ^a has possible side effects"}; 
A_GISVEC(A68_VC ,OSHACTR,NSHACTR,48)
static A68_82   PSHACTR = {"(270) Bad trace level - ^a"}; 
A_GISVEC(A68_VC ,QSHACTR,PSHACTR,26)
static A68_85   RSHACTR = {"(271) Unrecognised option - \"^a\""}; 
A_GISVEC(A68_VC ,SSHACTR,RSHACTR,32)
static A68_81   TSHACTR = {"(272) Invalid qualifier - ^a"}; 
A_GISVEC(A68_VC ,USHACTR,TSHACTR,28)
static A68_82   VSHACTR = {"(273) Missing keyword - ^a"}; 
A_GISVEC(A68_VC ,WSHACTR,VSHACTR,26)
static A68_96   XSHACTR = {"(274) Usage: a68toc [options] file"}; 
A_GISVEC(A68_VC ,YSHACTR,XSHACTR,34)
static A68_108   ZSHACTR = {"(275) Out of range buffer_limit - ^a"}; 
A_GISVEC(A68_VC ,ATHACTR,ZSHACTR,36)
static A68_86   BTHACTR = {"(276) Option \"^a\" is not yet implemented"}; 
A_GISVEC(A68_VC ,CTHACTR,BTHACTR,40)
static A68_98   DTHACTR = {"(277) Non-numeric argument - ^a"}; 
A_GISVEC(A68_VC ,ETHACTR,DTHACTR,31)
static A68_76   FTHACTR = {"(278) Null string"}; 
A_GISVEC(A68_VC ,GTHACTR,FTHACTR,17)
static A68_98   HTHACTR = {"(279) Unspecified (debug_)level"}; 
A_GISVEC(A68_VC ,ITHACTR,HTHACTR,31)
static A68_80   JTHACTR = {"(280) Unknown debug module \"^a\" ignored"}; 
A_GISVEC(A68_VC ,KTHACTR,JTHACTR,39)
static A68_98   LTHACTR = {"(281) Unspecified debug_modules"}; 
A_GISVEC(A68_VC ,MTHACTR,LTHACTR,31)
static A68_118   NTHACTR = {"(282) Staredit flag \"^a\" (from A68_STAREDIT) not in [0-9][A-Z]"}; 
A_GISVEC(A68_VC ,OTHACTR,NTHACTR,62)
static A68_119   PTHACTR = {"(283) Staredit flag \"^a\" (from -staredit option) not in [0-9][A-Z]"}; 
A_GISVEC(A68_VC ,QTHACTR,PTHACTR,66)
static A68_110   RTHACTR = {"(284) Staredit flags \"^a\" found in A68_STAREDIT"}; 
A_GISVEC(A68_VC ,STHACTR,RTHACTR,47)
static A68_80   TTHACTR = {"(285) Unrecognised C stream policy \"^a\""}; 
A_GISVEC(A68_VC ,UTHACTR,TTHACTR,39)
static A68_100   VTHACTR = {"(286) Invalid unique name seed \"^a\""}; 
A_GISVEC(A68_VC ,WTHACTR,VTHACTR,35)
static A68_110   XTHACTR = {"(300) Invalid program ( detected by translator)"}; 
A_GISVEC(A68_VC ,YTHACTR,XTHACTR,47)
static A68_105   ZTHACTR = {"(301) Bits denotation too big"}; 
A_GISVEC(A68_VC ,AUHACTR,ZTHACTR,29)
static A68_81   BUHACTR = {"(302) Int denotation too big"}; 
A_GISVEC(A68_VC ,CUHACTR,BUHACTR,28)
static A68_105   DUHACTR = {"(303) Real denotation too big"}; 
A_GISVEC(A68_VC ,EUHACTR,DUHACTR,29)
static A68_77   FUHACTR = {"(304) Real denotation too small, zero assumed"}; 
A_GISVEC(A68_VC ,GUHACTR,FUHACTR,45)
static A68_96   HUHACTR = {"(305) Radix string element too big"}; 
A_GISVEC(A68_VC ,IUHACTR,HUHACTR,34)
static A68_120   JUHACTR = {"(306) Ref mode cannot be coerced to ref struct 1 mode"}; 
A_GISVEC(A68_VC ,KUHACTR,JUHACTR,53)
static A68_93   LUHACTR = {"(307) Skip used for a value of a non-void mode"}; 
A_GISVEC(A68_VC ,MUHACTR,LUHACTR,46)
static A68_86   NUHACTR = {"(308) Bool voided, ':=' mistyped perhaps"}; 
A_GISVEC(A68_VC ,OUHACTR,NUHACTR,40)
static A68_116   PUHACTR = {"(309) Proc with parameters voided, parameters of call forgotten perhaps"}; 
A_GISVEC(A68_VC ,QUHACTR,PUHACTR,71)
static A68_100   RUHACTR = {"(310) A result has been voided here"}; 
A_GISVEC(A68_VC ,SUHACTR,RUHACTR,35)
static A68_103   TUHACTR = {"(311) Too many dimensions in a row, system limit is 15"}; 
A_GISVEC(A68_VC ,UUHACTR,TUHACTR,54)
static A68_83   VUHACTR = {"(312) Alien of this mode not supported by compiler"}; 
A_GISVEC(A68_VC ,WUHACTR,VUHACTR,50)
static A68_112   XUHACTR = {"(313) Vector too big"}; 
A_GISVEC(A68_VC ,YUHACTR,XUHACTR,20)
static A68_76   ZUHACTR = {"(314) Row too big"}; 
A_GISVEC(A68_VC ,AVHACTR,ZUHACTR,17)
static A68_90   BVHACTR = {"(315) Selecting implied OUT SKIP will result in an error at runtime"}; 
A_GISVEC(A68_VC ,CVHACTR,BVHACTR,67)
static A68_121   DVHACTR = {"(316) Selecting implied ELSE SKIP will result in an error at runtime"}; 
A_GISVEC(A68_VC ,EVHACTR,DVHACTR,68)
static A68_122   FVHACTR = {"(317) A case clause with no OUT-part is required to deliver a non-void value"}; 
A_GISVEC(A68_VC ,GVHACTR,FVHACTR,76)
static A68_123   HVHACTR = {"(318) A conditional clause with no ELSE-part is required to deliver a non-void value"}; 
A_GISVEC(A68_VC ,IVHACTR,HVHACTR,84)
static A68_92   JVHACTR = {"(319) Compatible with previous version of module"}; 
A_GISVEC(A68_VC ,KVHACTR,JVHACTR,48)
static A68_83   LVHACTR = {"(320) Incompatible with previous version of module"}; 
A_GISVEC(A68_VC ,MVHACTR,LVHACTR,50)
static A68_87   NVHACTR = {"(321) Previous version is not a DECS module"}; 
A_GISVEC(A68_VC ,OVHACTR,NVHACTR,43)
static A68_80   PVHACTR = {"(322) Previous version is a DECS module"}; 
A_GISVEC(A68_VC ,QVHACTR,PVHACTR,39)
static A68_83   RVHACTR = {"(323) '^a' not found in previous version of module"}; 
A_GISVEC(A68_VC ,SVHACTR,RVHACTR,50)
static A68_92   TVHACTR = {"(324) '^a' ^a incompatible with previous version"}; 
A_GISVEC(A68_VC ,UVHACTR,TVHACTR,48)
static A68_99   VVHACTR = {"(325) FORALL array bounds do not match"}; 
A_GISVEC(A68_VC ,WVHACTR,VVHACTR,38)
static A68_83   XVHACTR = {"(326) Incorrect dimension number in bound operator"}; 
A_GISVEC(A68_VC ,YVHACTR,XVHACTR,50)
static A68_110   ZVHACTR = {"(327) Previous version is a partial composition"}; 
A_GISVEC(A68_VC ,AWHACTR,ZVHACTR,47)
static A68_85   BWHACTR = {"(328) Keeplist order has changed"}; 
A_GISVEC(A68_VC ,CWHACTR,BWHACTR,32)
static A68_103   DWHACTR = {"(329) Previous version has a different number of holes"}; 
A_GISVEC(A68_VC ,EWHACTR,DWHACTR,54)
static A68_65   FWHACTR = {""}; 
A_GISVEC(A68_VC ,GWHACTR,FWHACTR,0)
static A68_65   HWHACTR = {""}; 
A_GISVEC(A68_VC ,IWHACTR,HWHACTR,0)
static A68_65   JWHACTR = {""}; 
A_GISVEC(A68_VC ,KWHACTR,JWHACTR,0)
static A68_65   LWHACTR = {""}; 
A_GISVEC(A68_VC ,MWHACTR,LWHACTR,0)
static A68_124   NWHACTR = {"(334) Local context does not match that of previous version"}; 
A_GISVEC(A68_VC ,OWHACTR,NWHACTR,59)
static A68_125   PWHACTR = {"(335) Prelude context does not match that of previous version"}; 
A_GISVEC(A68_VC ,QWHACTR,PWHACTR,61)
static A68_80   RWHACTR = {"(336) module '^a' found in segment '^a'"}; 
A_GISVEC(A68_VC ,SWHACTR,RWHACTR,39)
static A68_92   TWHACTR = {"(337) module name does not match source filename"}; 
A_GISVEC(A68_VC ,UWHACTR,TWHACTR,48)
static A68_92   VWHACTR = {"(338) Attempting to find Algol68 module '^a'^/^a"}; 
A_GISVEC(A68_VC ,WWHACTR,VWHACTR,48)
static A68_65   XWHACTR = {""}; 
A_GISVEC(A68_VC ,YWHACTR,XWHACTR,0)
static A68_77   ZWHACTR = {"(340) Program result cannot be a dynamic mode"}; 
A_GISVEC(A68_VC ,AXHACTR,ZWHACTR,45)
static A68_96   BXHACTR = {"(341) Decs module in wrong context"}; 
A_GISVEC(A68_VC ,CXHACTR,BXHACTR,34)
static A68_106   DXHACTR = {"(342) Decs module in incompatible context"}; 
A_GISVEC(A68_VC ,EXHACTR,DXHACTR,41)
static A68_124   FXHACTR = {"(343) module '^a' context incompatible with prelude context"}; 
A_GISVEC(A68_VC ,GXHACTR,FXHACTR,59)
static A68_60   HXHACTR = {"(344) module '^a' context incompatible with local context"}; 
A_GISVEC(A68_VC ,IXHACTR,HXHACTR,57)
static A68_93   JXHACTR = {"(345) Previous version is a compilation module"}; 
A_GISVEC(A68_VC ,KXHACTR,JXHACTR,46)
static A68_65   LXHACTR = {""}; 
A_GISVEC(A68_VC ,MXHACTR,LXHACTR,0)
static A68_101   NXHACTR = {"(347) Struct mode too big"}; 
A_GISVEC(A68_VC ,OXHACTR,NXHACTR,25)
static A68_82   PXHACTR = {"(348) Istruct mode too big"}; 
A_GISVEC(A68_VC ,QXHACTR,PXHACTR,26)
static A68_65   RXHACTR = {""}; 
A_GISVEC(A68_VC ,SXHACTR,RXHACTR,0)
static A68_126   TXHACTR = {"(350) The symbol table is too large to add a name properly, PROBE may not be able to find it"}; 
A_GISVEC(A68_VC ,UXHACTR,TXHACTR,92)
static A68_107   VXHACTR = {"(351) IS test will always deliver FALSE here"}; 
A_GISVEC(A68_VC ,WXHACTR,VXHACTR,44)
static A68_87   XXHACTR = {"(352) IS test will always deliver TRUE here"}; 
A_GISVEC(A68_VC ,YXHACTR,XXHACTR,43)
static A68_93   ZXHACTR = {"(353) ISNT test will always deliver FALSE here"}; 
A_GISVEC(A68_VC ,AYHACTR,ZXHACTR,46)
static A68_77   BYHACTR = {"(354) ISNT test will always deliver TRUE here"}; 
A_GISVEC(A68_VC ,CYHACTR,BYHACTR,45)
static A68_97   DYHACTR = {"(355) Stack frame required is too big"}; 
A_GISVEC(A68_VC ,EYHACTR,DYHACTR,37)
static A68_74   FYHACTR = {"ROUTINE BEGIN"}; 
A_GISVEC(A68_VC ,GYHACTR,FYHACTR,13)
static A68_40   HYHACTR = {"DECS"}; 
A_GISVEC(A68_VC ,IYHACTR,HYHACTR,4)
static A68_62   JYHACTR = {"IF"}; 
A_GISVEC(A68_VC ,KYHACTR,JYHACTR,2)
static A68_40   LYHACTR = {"CASE"}; 
A_GISVEC(A68_VC ,MYHACTR,LYHACTR,4)
static A68_76   NYHACTR = {"CASE {conformity}"}; 
A_GISVEC(A68_VC ,OYHACTR,NYHACTR,17)
static A68_64   PYHACTR = {"BEGIN"}; 
A_GISVEC(A68_VC ,QYHACTR,PYHACTR,5)
static A68_66   SYHACTR = {"FOR"}; 
A_GISVEC(A68_VC ,TYHACTR,SYHACTR,3)
static A68_71   UYHACTR = {"FORALL"}; 
A_GISVEC(A68_VC ,VYHACTR,UYHACTR,6)
static A68_40   WYHACTR = {"THEN"}; 
A_GISVEC(A68_VC ,XYHACTR,WYHACTR,4)
static A68_62   YYHACTR = {"IN"}; 
A_GISVEC(A68_VC ,ZYHACTR,YYHACTR,2)
static A68_75   AZHACTR = {"IN {conformity}"}; 
A_GISVEC(A68_VC ,BZHACTR,AZHACTR,15)
static A68_64   CZHACTR = {"COMMA"}; 
A_GISVEC(A68_VC ,DZHACTR,CZHACTR,5)
static A68_109   EZHACTR = {"COMMA {conformity}"}; 
A_GISVEC(A68_VC ,FZHACTR,EZHACTR,18)
static A68_40   GZHACTR = {"EXIT"}; 
A_GISVEC(A68_VC ,HZHACTR,GZHACTR,4)
static A68_66   IZHACTR = {"OUT"}; 
A_GISVEC(A68_VC ,JZHACTR,IZHACTR,3)
static A68_73   KZHACTR = {"OUT {conformity}"}; 
A_GISVEC(A68_VC ,LZHACTR,KZHACTR,16)
static A68_40   MZHACTR = {"ELSE"}; 
A_GISVEC(A68_VC ,NZHACTR,MZHACTR,4)
static A68_62   QZHACTR = {"DO"}; 
A_GISVEC(A68_VC ,RZHACTR,QZHACTR,2)
static A68_64   SZHACTR = {"WHILE"}; 
A_GISVEC(A68_VC ,TZHACTR,SZHACTR,5)
static A68_62   UZHACTR = {"FI"}; 
A_GISVEC(A68_VC ,VZHACTR,UZHACTR,2)
static A68_40   WZHACTR = {"ESAC"}; 
A_GISVEC(A68_VC ,XZHACTR,WZHACTR,4)
static A68_76   YZHACTR = {"ESAC {conformity}"}; 
A_GISVEC(A68_VC ,ZZHACTR,YZHACTR,17)
static A68_66   AAIACTR = {"END"}; 
A_GISVEC(A68_VC ,BAIACTR,AAIACTR,3)
static A68_62   DAIACTR = {"OD"}; 
A_GISVEC(A68_VC ,EAIACTR,DAIACTR,2)
static A68_69   FAIACTR = {"ROUTINE END"}; 
A_GISVEC(A68_VC ,GAIACTR,FAIACTR,11)
static A68_71   HAIACTR = {"FINISH"}; 
A_GISVEC(A68_VC ,IAIACTR,HAIACTR,6)
static A68_65   JAIACTR = {""}; 
A_GISVEC(A68_VC ,KAIACTR,JAIACTR,0)
static A68_65   LAIACTR = {""}; 
A_GISVEC(A68_VC ,MAIACTR,LAIACTR,0)
static A68_65   NAIACTR = {""}; 
A_GISVEC(A68_VC ,OAIACTR,NAIACTR,0)
static A68_65   PAIACTR = {""}; 
A_GISVEC(A68_VC ,QAIACTR,PAIACTR,0)
static A68_65   RAIACTR = {""}; 
A_GISVEC(A68_VC ,SAIACTR,RAIACTR,0)
static A68_65   TAIACTR = {""}; 
A_GISVEC(A68_VC ,UAIACTR,TAIACTR,0)
static A68_65   VAIACTR = {""}; 
A_GISVEC(A68_VC ,WAIACTR,VAIACTR,0)
static A68_65   XAIACTR = {""}; 
A_GISVEC(A68_VC ,YAIACTR,XAIACTR,0)
static A68_65   ZAIACTR = {""}; 
A_GISVEC(A68_VC ,ABIACTR,ZAIACTR,0)
static A68_65   BBIACTR = {""}; 
A_GISVEC(A68_VC ,CBIACTR,BBIACTR,0)
static A68_65   DBIACTR = {""}; 
A_GISVEC(A68_VC ,EBIACTR,DBIACTR,0)
static A68_65   FBIACTR = {""}; 
A_GISVEC(A68_VC ,GBIACTR,FBIACTR,0)
static A68_65   HBIACTR = {""}; 
A_GISVEC(A68_VC ,IBIACTR,HBIACTR,0)
static A68_65   JBIACTR = {""}; 
A_GISVEC(A68_VC ,KBIACTR,JBIACTR,0)
static A68_65   LBIACTR = {""}; 
A_GISVEC(A68_VC ,MBIACTR,LBIACTR,0)
static A68_65   NBIACTR = {""}; 
A_GISVEC(A68_VC ,OBIACTR,NBIACTR,0)
static A68_65   PBIACTR = {""}; 
A_GISVEC(A68_VC ,QBIACTR,PBIACTR,0)
static A68_65   RBIACTR = {""}; 
A_GISVEC(A68_VC ,SBIACTR,RBIACTR,0)
static A68_65   TBIACTR = {""}; 
A_GISVEC(A68_VC ,UBIACTR,TBIACTR,0)
static A68_65   VBIACTR = {""}; 
A_GISVEC(A68_VC ,WBIACTR,VBIACTR,0)
static A68_65   XBIACTR = {""}; 
A_GISVEC(A68_VC ,YBIACTR,XBIACTR,0)
static A68_64   ZBIACTR = {"PROC "}; 
A_GISVEC(A68_VC ,ACIACTR,ZBIACTR,5)
static A68_64   BCIACTR = {"PROC("}; 
A_GISVEC(A68_VC ,CCIACTR,BCIACTR,5)
static A68_71   DCIACTR = {"UNION("}; 
A_GISVEC(A68_VC ,ECIACTR,DCIACTR,6)
static A68_67   FCIACTR = {"STRUCT("}; 
A_GISVEC(A68_VC ,GCIACTR,FCIACTR,7)
static A68_67   HCIACTR = {"STRUCT "}; 
A_GISVEC(A68_VC ,ICIACTR,HCIACTR,7)
static A68_63   KCIACTR = {"VECTOR ["}; 
A_GISVEC(A68_VC ,LCIACTR,KCIACTR,8)
static A68_71   MCIACTR = {"FLEX ["}; 
A_GISVEC(A68_VC ,NCIACTR,MCIACTR,6)
static A68_74   OCIACTR = {"FLEX VECTOR ["}; 
A_GISVEC(A68_VC ,PCIACTR,OCIACTR,13)
static A68_70   QCIACTR = {"STRAIGHT "}; 
A_GISVEC(A68_VC ,RCIACTR,QCIACTR,9)
static A68_62   SCIACTR = {") "}; 
A_GISVEC(A68_VC ,TCIACTR,SCIACTR,2)
static A68_65   UCIACTR = {""}; 
A_GISVEC(A68_VC ,VCIACTR,UCIACTR,0)
static A68_65   WCIACTR = {""}; 
A_GISVEC(A68_VC ,XCIACTR,WCIACTR,0)
static A68_65   YCIACTR = {""}; 
A_GISVEC(A68_VC ,ZCIACTR,YCIACTR,0)
static A68_65   ADIACTR = {""}; 
A_GISVEC(A68_VC ,BDIACTR,ADIACTR,0)
static A68_65   CDIACTR = {""}; 
A_GISVEC(A68_VC ,DDIACTR,CDIACTR,0)
static A68_65   EDIACTR = {""}; 
A_GISVEC(A68_VC ,FDIACTR,EDIACTR,0)
static A68_65   GDIACTR = {""}; 
A_GISVEC(A68_VC ,HDIACTR,GDIACTR,0)
static A68_65   IDIACTR = {""}; 
A_GISVEC(A68_VC ,JDIACTR,IDIACTR,0)
static A68_65   KDIACTR = {""}; 
A_GISVEC(A68_VC ,LDIACTR,KDIACTR,0)
static A68_65   MDIACTR = {""}; 
A_GISVEC(A68_VC ,NDIACTR,MDIACTR,0)
static A68_65   ODIACTR = {""}; 
A_GISVEC(A68_VC ,PDIACTR,ODIACTR,0)
static A68_65   QDIACTR = {""}; 
A_GISVEC(A68_VC ,RDIACTR,QDIACTR,0)
static A68_65   SDIACTR = {""}; 
A_GISVEC(A68_VC ,TDIACTR,SDIACTR,0)
static A68_65   UDIACTR = {""}; 
A_GISVEC(A68_VC ,VDIACTR,UDIACTR,0)
static A68_65   WDIACTR = {""}; 
A_GISVEC(A68_VC ,XDIACTR,WDIACTR,0)
static A68_65   YDIACTR = {""}; 
A_GISVEC(A68_VC ,ZDIACTR,YDIACTR,0)
static A68_65   AEIACTR = {""}; 
A_GISVEC(A68_VC ,BEIACTR,AEIACTR,0)
static A68_65   CEIACTR = {""}; 
A_GISVEC(A68_VC ,DEIACTR,CEIACTR,0)
static A68_65   EEIACTR = {""}; 
A_GISVEC(A68_VC ,FEIACTR,EEIACTR,0)
static A68_65   GEIACTR = {""}; 
A_GISVEC(A68_VC ,HEIACTR,GEIACTR,0)
static A68_65   IEIACTR = {""}; 
A_GISVEC(A68_VC ,JEIACTR,IEIACTR,0)
static A68_65   KEIACTR = {""}; 
A_GISVEC(A68_VC ,LEIACTR,KEIACTR,0)
static A68_65   MEIACTR = {""}; 
A_GISVEC(A68_VC ,NEIACTR,MEIACTR,0)
static A68_65   OEIACTR = {""}; 
A_GISVEC(A68_VC ,PEIACTR,OEIACTR,0)
static A68_65   QEIACTR = {""}; 
A_GISVEC(A68_VC ,REIACTR,QEIACTR,0)
static A68_65   SEIACTR = {""}; 
A_GISVEC(A68_VC ,TEIACTR,SEIACTR,0)
static A68_65   UEIACTR = {""}; 
A_GISVEC(A68_VC ,VEIACTR,UEIACTR,0)
static A68_65   WEIACTR = {""}; 
A_GISVEC(A68_VC ,XEIACTR,WEIACTR,0)
static A68_65   YEIACTR = {""}; 
A_GISVEC(A68_VC ,ZEIACTR,YEIACTR,0)
static A68_65   AFIACTR = {""}; 
A_GISVEC(A68_VC ,BFIACTR,AFIACTR,0)
static A68_65   CFIACTR = {""}; 
A_GISVEC(A68_VC ,DFIACTR,CFIACTR,0)
static A68_65   EFIACTR = {""}; 
A_GISVEC(A68_VC ,FFIACTR,EFIACTR,0)
static A68_65   GFIACTR = {""}; 
A_GISVEC(A68_VC ,HFIACTR,GFIACTR,0)
static A68_65   IFIACTR = {""}; 
A_GISVEC(A68_VC ,JFIACTR,IFIACTR,0)
static A68_65   KFIACTR = {""}; 
A_GISVEC(A68_VC ,LFIACTR,KFIACTR,0)
static A68_65   MFIACTR = {""}; 
A_GISVEC(A68_VC ,NFIACTR,MFIACTR,0)
static A68_65   OFIACTR = {""}; 
A_GISVEC(A68_VC ,PFIACTR,OFIACTR,0)
static A68_127   QFIACTR = {"(600) Compiler error: SHELL (next imperative) - illegal stream imperative (load)"}; 
A_GISVEC(A68_VC ,RFIACTR,QFIACTR,80)
static A68_128   SFIACTR = {"(601) Compiler error: SHELL (next imperative) - illegal stream imperative (miscellaneous)"}; 
A_GISVEC(A68_VC ,TFIACTR,SFIACTR,89)
static A68_129   UFIACTR = {"(602) Compiler error: TRANSLATOR (look ahead) - more than one stream 'lookahead' attempted"}; 
A_GISVEC(A68_VC ,VFIACTR,UFIACTR,90)
static A68_65   WFIACTR = {""}; 
A_GISVEC(A68_VC ,XFIACTR,WFIACTR,0)
static A68_65   YFIACTR = {""}; 
A_GISVEC(A68_VC ,ZFIACTR,YFIACTR,0)
static A68_71   AGIACTR = {"(605) "}; 
A_GISVEC(A68_VC ,BGIACTR,AGIACTR,6)
static A68_130   CGIACTR = {"(606) Compiler error: TRANSLATOR (enclosed clause) - routinend in enclosed clause"}; 
A_GISVEC(A68_VC ,DGIACTR,CGIACTR,81)
static A68_131   EGIACTR = {"(607) Compiler error: TRANSLATOR (enclosed clause) - finish in enclosed clause"}; 
A_GISVEC(A68_VC ,FGIACTR,EGIACTR,78)
static A68_129   GGIACTR = {"(608) Compiler error: TRANSLATOR (enclosed clause) - illegal stream imperative (separator)"}; 
A_GISVEC(A68_VC ,HGIACTR,GGIACTR,90)
static A68_132   IGIACTR = {"(609) Compiler error: TRANSLATOR (enclosed clause) - illegal stream imperative (terminator)"}; 
A_GISVEC(A68_VC ,JGIACTR,IGIACTR,91)
static A68_71   KGIACTR = {"(610) "}; 
A_GISVEC(A68_VC ,LGIACTR,KGIACTR,6)
static A68_71   MGIACTR = {"(611) "}; 
A_GISVEC(A68_VC ,NGIACTR,MGIACTR,6)
static A68_71   OGIACTR = {"(612) "}; 
A_GISVEC(A68_VC ,PGIACTR,OGIACTR,6)
static A68_71   QGIACTR = {"(613) "}; 
A_GISVEC(A68_VC ,RGIACTR,QGIACTR,6)
static A68_71   SGIACTR = {"(614) "}; 
A_GISVEC(A68_VC ,TGIACTR,SGIACTR,6)
static A68_71   UGIACTR = {"(615) "}; 
A_GISVEC(A68_VC ,VGIACTR,UGIACTR,6)
static A68_71   WGIACTR = {"(616) "}; 
A_GISVEC(A68_VC ,XGIACTR,WGIACTR,6)
static A68_71   YGIACTR = {"(617) "}; 
A_GISVEC(A68_VC ,ZGIACTR,YGIACTR,6)
static A68_71   AHIACTR = {"(618) "}; 
A_GISVEC(A68_VC ,BHIACTR,AHIACTR,6)
static A68_71   CHIACTR = {"(619) "}; 
A_GISVEC(A68_VC ,DHIACTR,CHIACTR,6)
static A68_71   EHIACTR = {"(620) "}; 
A_GISVEC(A68_VC ,FHIACTR,EHIACTR,6)
static A68_71   GHIACTR = {"(621) "}; 
A_GISVEC(A68_VC ,HHIACTR,GHIACTR,6)
static A68_71   IHIACTR = {"(622) "}; 
A_GISVEC(A68_VC ,JHIACTR,IHIACTR,6)
static A68_71   KHIACTR = {"(623) "}; 
A_GISVEC(A68_VC ,LHIACTR,KHIACTR,6)
static A68_71   MHIACTR = {"(624) "}; 
A_GISVEC(A68_VC ,NHIACTR,MHIACTR,6)
static A68_71   OHIACTR = {"(625) "}; 
A_GISVEC(A68_VC ,PHIACTR,OHIACTR,6)
static A68_71   QHIACTR = {"(626) "}; 
A_GISVEC(A68_VC ,RHIACTR,QHIACTR,6)
static A68_71   SHIACTR = {"(627) "}; 
A_GISVEC(A68_VC ,THIACTR,SHIACTR,6)
static A68_133   UHIACTR = {"(628) Compiler error: TRANSLATOR (module) - cc module compiled as proc module"}; 
A_GISVEC(A68_VC ,VHIACTR,UHIACTR,77)
static A68_118   WHIACTR = {"(629) Compiler error: IDENTIFIERS (labdec) - setting non label"}; 
A_GISVEC(A68_VC ,XHIACTR,WHIACTR,62)
static A68_134   YHIACTR = {"(630) Compiler error: MODES (initialise mode) - invalid mode in REF [] MDES"}; 
A_GISVEC(A68_VC ,ZHIACTR,YHIACTR,75)
static A68_135   AIIACTR = {"(631) Compiler error: MODES (finalise mode) - 'unset' length invalid for mode type"}; 
A_GISVEC(A68_VC ,BIIACTR,AIIACTR,82)
static A68_136   CIIACTR = {"(632) Compiler error: MODES (deref) - attempt to dereference non-REF mode"}; 
A_GISVEC(A68_VC ,DIIACTR,CIIACTR,73)
static A68_137   EIIACTR = {"(633) Compiler error: LOAD (chars to L bits) - invalid radix"}; 
A_GISVEC(A68_VC ,FIIACTR,EIIACTR,60)
static A68_71   GIIACTR = {"(634) "}; 
A_GISVEC(A68_VC ,HIIACTR,GIIACTR,6)
static A68_71   IIIACTR = {"(635) "}; 
A_GISVEC(A68_VC ,JIIACTR,IIIACTR,6)
static A68_71   KIIACTR = {"(636) "}; 
A_GISVEC(A68_VC ,LIIACTR,KIIACTR,6)
static A68_71   MIIACTR = {"(637) "}; 
A_GISVEC(A68_VC ,NIIACTR,MIIACTR,6)
static A68_71   OIIACTR = {"(638) "}; 
A_GISVEC(A68_VC ,PIIACTR,OIIACTR,6)
static A68_71   QIIACTR = {"(639) "}; 
A_GISVEC(A68_VC ,RIIACTR,QIIACTR,6)
static A68_71   SIIACTR = {"(640) "}; 
A_GISVEC(A68_VC ,TIIACTR,SIIACTR,6)
static A68_71   UIIACTR = {"(641) "}; 
A_GISVEC(A68_VC ,VIIACTR,UIIACTR,6)
static A68_71   WIIACTR = {"(642) "}; 
A_GISVEC(A68_VC ,XIIACTR,WIIACTR,6)
static A68_71   YIIACTR = {"(643) "}; 
A_GISVEC(A68_VC ,ZIIACTR,YIIACTR,6)
static A68_65   AJIACTR = {""}; 
A_GISVEC(A68_VC ,BJIACTR,AJIACTR,0)
static A68_138   CJIACTR = {"(645) Compiler error: BIOP IDENTIFIER (biop identifier) - biop identifier value not implemented"}; 
A_GISVEC(A68_VC ,DJIACTR,CJIACTR,95)
static A68_71   EJIACTR = {"(646) "}; 
A_GISVEC(A68_VC ,FJIACTR,EJIACTR,6)
static A68_71   GJIACTR = {"(647) "}; 
A_GISVEC(A68_VC ,HJIACTR,GJIACTR,6)
static A68_92   IJIACTR = {"(648) Compiler error: internal assertion failure"}; 
A_GISVEC(A68_VC ,JJIACTR,IJIACTR,48)
static A68_108   KJIACTR = {"(649) Compiler error: table overflow"}; 
A_GISVEC(A68_VC ,LJIACTR,KJIACTR,36)
static A68_115   MJIACTR = {"(650) Compiler error: (Various evaluation procs) - Only opers allowed"}; 
A_GISVEC(A68_VC ,NJIACTR,MJIACTR,69)
static A68_65   OJIACTR = {""}; 
A_GISVEC(A68_VC ,PJIACTR,OJIACTR,0)
static A68_130   QJIACTR = {"(652) Compiler error: VALUES (add deref) - cannot add deref to this type of value"}; 
A_GISVEC(A68_VC ,RJIACTR,QJIACTR,81)
static A68_122   SJIACTR = {"(653) Compiler error: ADDRESS (address simple) - address should contain abit"}; 
A_GISVEC(A68_VC ,TJIACTR,SJIACTR,76)
static A68_134   UJIACTR = {"(654) Compiler error: ADDRESS (address simple) - unknown high level pointer"}; 
A_GISVEC(A68_VC ,VJIACTR,UJIACTR,75)
static A68_136   WJIACTR = {"(655) Compiler error: CLAUSES (choice begin) - illegal starter for choice"}; 
A_GISVEC(A68_VC ,XJIACTR,WJIACTR,73)
static A68_139   YJIACTR = {"(656) Compiler error: TRANSLATOR (serial clause) - invalid imperative in <serial clause>"}; 
A_GISVEC(A68_VC ,ZJIACTR,YJIACTR,88)
static A68_139   AKIACTR = {"(657) Compiler error: TRANSLATOR (choice clause) - invalid imperative in <choice clause>"}; 
A_GISVEC(A68_VC ,BKIACTR,AKIACTR,88)
static A68_140   CKIACTR = {"(658) Compiler error: TRANSLATOR (collateral clause) - invalid imperative in <collateral clause>"}; 
A_GISVEC(A68_VC ,DKIACTR,CKIACTR,96)
static A68_128   EKIACTR = {"(659) Compiler error: CLAUSES (evaluate result) - enquiry result does not contain ENQUIRY"}; 
A_GISVEC(A68_VC ,FKIACTR,EKIACTR,89)
static A68_71   GKIACTR = {"(660) "}; 
A_GISVEC(A68_VC ,HKIACTR,GKIACTR,6)
static A68_118   IKIACTR = {"(661) Compiler error: ENVIRONMENT (ASSERT) - assertion failure"}; 
A_GISVEC(A68_VC ,JKIACTR,IKIACTR,62)
static A68_71   KKIACTR = {"(662) "}; 
A_GISVEC(A68_VC ,LKIACTR,KKIACTR,6)
static A68_71   MKIACTR = {"(663) "}; 
A_GISVEC(A68_VC ,NKIACTR,MKIACTR,6)
static A68_71   OKIACTR = {"(664) "}; 
A_GISVEC(A68_VC ,PKIACTR,OKIACTR,6)
static A68_116   QKIACTR = {"(665) Compiler error: TRANSLATOR - invalid separator in <choice clause>"}; 
A_GISVEC(A68_VC ,RKIACTR,QKIACTR,71)
static A68_117   SKIACTR = {"(666) Compiler error: TRANSLATOR - invalid imperative in <loop clause>"}; 
A_GISVEC(A68_VC ,TKIACTR,SKIACTR,70)
static A68_71   UKIACTR = {"(667) "}; 
A_GISVEC(A68_VC ,VKIACTR,UKIACTR,6)
static A68_129   WKIACTR = {"(668) Compiler error: TRANSLATOR (uchoice imperative) - UCHOICE expected after IN or COMMA"}; 
A_GISVEC(A68_VC ,XKIACTR,WKIACTR,90)
static A68_126   YKIACTR = {"(669) Compiler error: TRANSLATOR (transiddec imperative) - TRANSIDDEC expected after UCHOICE"}; 
A_GISVEC(A68_VC ,ZKIACTR,YKIACTR,92)
static A68_141   ALIACTR = {"(670) Compiler error: TRANSLATOR (phrase) - unexpected UCHOICE in <phrase>"}; 
A_GISVEC(A68_VC ,BLIACTR,ALIACTR,74)
static A68_128   CLIACTR = {"(671) Compiler error: CLAUSES (optbool oper) - extra of optbool value must be REF OPTBOOL"}; 
A_GISVEC(A68_VC ,DLIACTR,CLIACTR,89)
static A68_123   ELIACTR = {"(672) Compiler error: IDENTIFIERS (initialise ids) - identifier table size exceeded)"}; 
A_GISVEC(A68_VC ,FLIACTR,ELIACTR,84)
static A68_130   GLIACTR = {"(673) Compiler error: IDENTIFIERS (initialise ids) - routine table size exceeded)"}; 
A_GISVEC(A68_VC ,HLIACTR,GLIACTR,81)
static A68_97   ILIACTR = {"(700) Cannot create modinfo file - ^a"}; 
A_GISVEC(A68_VC ,JLIACTR,ILIACTR,37)
static A68_71   KLIACTR = {"(701) "}; 
A_GISVEC(A68_VC ,LLIACTR,KLIACTR,6)
static A68_98   MLIACTR = {"(702) Cannot create stream - ^a"}; 
A_GISVEC(A68_VC ,NLIACTR,MLIACTR,31)
static A68_108   OLIACTR = {"(703) Cannot create c body file - ^a"}; 
A_GISVEC(A68_VC ,PLIACTR,OLIACTR,36)
static A68_106   QLIACTR = {"(704) Cannot open stream for reading - ^a"}; 
A_GISVEC(A68_VC ,RLIACTR,QLIACTR,41)
static A68_106   SLIACTR = {"(705) Non-numeric cedit /^a/ in stream ^a"}; 
A_GISVEC(A68_VC ,TLIACTR,SLIACTR,41)
static A68_71   ULIACTR = {"(706) "}; 
A_GISVEC(A68_VC ,VLIACTR,ULIACTR,6)
static A68_92   WLIACTR = {"(707) Out of range stream number ^a in stream ^a"}; 
A_GISVEC(A68_VC ,XLIACTR,WLIACTR,48)
static A68_93   YLIACTR = {"(708) Cannot read from uninitialised stream ^a"}; 
A_GISVEC(A68_VC ,ZLIACTR,YLIACTR,46)
static A68_81   AMIACTR = {"(709) write error on ^a \"^a\""}; 
A_GISVEC(A68_VC ,BMIACTR,AMIACTR,28)
static A68_98   CMIACTR = {"(710) init coutput called twice"}; 
A_GISVEC(A68_VC ,DMIACTR,CMIACTR,31)
static A68_80   EMIACTR = {"(711) (^a) - init not called previously"}; 
A_GISVEC(A68_VC ,FMIACTR,EMIACTR,39)
static A68_108   GMIACTR = {"(712) (^a) - close called previously"}; 
A_GISVEC(A68_VC ,HMIACTR,GMIACTR,36)
static A68_104   IMIACTR = {"(713) illegal c output data"}; 
A_GISVEC(A68_VC ,JMIACTR,IMIACTR,27)
static A68_97   KMIACTR = {"(714) write error on stream file \"^a\""}; 
A_GISVEC(A68_VC ,LMIACTR,KMIACTR,37)
static A68_82   MMIACTR = {"(715) illegal modinfo data"}; 
A_GISVEC(A68_VC ,NMIACTR,MMIACTR,26)
static A68_108   OMIACTR = {"(716) read error on stream file \"^a\""}; 
A_GISVEC(A68_VC ,PMIACTR,OMIACTR,36)
static A68_142   QMIACTR = {"(720) Bad case conformity - two choices for mode ^a"}; 
A_GISVEC(A68_VC ,RMIACTR,QMIACTR,51)
static A68_104   SMIACTR = {"(750) Output file full - ^a"}; 
A_GISVEC(A68_VC ,TMIACTR,SMIACTR,27)
static A68_96   UMIACTR = {"(751) Unexpected end of file in ^a"}; 
A_GISVEC(A68_VC ,VMIACTR,UMIACTR,34)
static A68_110   WMIACTR = {"(799) Value stack has more than one value on it"}; 
A_GISVEC(A68_VC ,XMIACTR,WMIACTR,47)
static A68_81   YMIACTR = {"(800) Unique name wraparound"}; 
A_GISVEC(A68_VC ,ZMIACTR,YMIACTR,28)
static A68_142   ANIACTR = {"(801) Cannot open unique name seed file for reading"}; 
A_GISVEC(A68_VC ,BNIACTR,ANIACTR,51)
static A68_142   CNIACTR = {"(802) Cannot open unique name seed file for writing"}; 
A_GISVEC(A68_VC ,DNIACTR,CNIACTR,51)
static A68_87   ENIACTR = {"(803) Invalid character in unique name seed"}; 
A_GISVEC(A68_VC ,FNIACTR,ENIACTR,43)
static A68_120   GNIACTR = {"(804) ctrans restriction: module must be CONTEXT VOID"}; 
A_GISVEC(A68_VC ,HNIACTR,GNIACTR,53)
static A68_92   INIACTR = {"(805) ctrans restriction: closures not supported"}; 
A_GISVEC(A68_VC ,JNIACTR,INIACTR,48)
static A68_142   KNIACTR = {"(806) ctrans restriction: composition not supported"}; 
A_GISVEC(A68_VC ,LNIACTR,KNIACTR,51)
static A68_77   MNIACTR = {"(807) ctrans restriction: holes not supported"}; 
A_GISVEC(A68_VC ,NNIACTR,MNIACTR,45)
static A68_93   ONIACTR = {"(808) ctrans restriction: FORMAT not supported"}; 
A_GISVEC(A68_VC ,PNIACTR,ONIACTR,46)
static A68_94   QNIACTR = {"(809) ctrans restriction: PROC modules not supported"}; 
A_GISVEC(A68_VC ,RNIACTR,QNIACTR,52)
static A68_96   SNIACTR = {"(810) uninitialised reference name"}; 
A_GISVEC(A68_VC ,TNIACTR,SNIACTR,34)
static A68_87   UNIACTR = {"(811) up to date - no translation necessary"}; 
A_GISVEC(A68_VC ,VNIACTR,UNIACTR,43)
static A68_143   WNIACTR = {"(812) Cannot open existing C file for reading name seed"}; 
A_GISVEC(A68_VC ,XNIACTR,WNIACTR,55)
static A68_95   YNIACTR = {"(813) Using unique name \"AAAAAAA\""}; 
A_GISVEC(A68_VC ,ZNIACTR,YNIACTR,33)
static A68_99   AOIACTR = {"(814) Invalid unique name in seed file"}; 
A_GISVEC(A68_VC ,BOIACTR,AOIACTR,38)
static A68_85   COIACTR = {"(815) Unrecognised C file header"}; 
A_GISVEC(A68_VC ,DOIACTR,COIACTR,32)
static A68_106   EOIACTR = {"(816) Cannot open ^a as library directory"}; 
A_GISVEC(A68_VC ,FOIACTR,EOIACTR,41)
static A68_143   GOIACTR = {"(817) Cannot read ^a as library module information file"}; 
A_GISVEC(A68_VC ,HOIACTR,GOIACTR,55)
static A68_111   IOIACTR = {"(900) Goto in proc context not implemented"}; 
A_GISVEC(A68_VC ,JOIACTR,IOIACTR,42)
static A68_83   KOIACTR = {"(901) Goto in non-void context not yet implemented"}; 
A_GISVEC(A68_VC ,LOIACTR,KOIACTR,50)
static A68_142   MOIACTR = {"(902) Parameter of code insert is not an identifier"}; 
A_GISVEC(A68_VC ,NOIACTR,MOIACTR,51)
static A68_79   OOIACTR = {"(903) result voided"}; 
A_GISVEC(A68_VC ,POIACTR,OOIACTR,19)
static A68_137   QOIACTR = {"(904) no C definition supplied for \"^a\" in ALIEN declaration"}; 
A_GISVEC(A68_VC ,ROIACTR,QOIACTR,60)
static A68_76   SOIACTR = {") UNKNOWN MESSAGE"}; 
A_GISVEC(A68_VC ,VOIACTR,SOIACTR,17)
typedef struct   /* env of non-global proc */
{
A68_VC  WOIACTR_mess;
} APIACTR_generator;

A68_VOID  KDHACTR_message(A68_INT  Messagenumber, A68_VC  *ReturnedValue);

A_STATIC A68_VOID  ZOIACTR_generator(A68_BOOL  XOIACTR_anonymous, A68_VC  *ReturnedValue, void *NonLocals);

A68_VOID  GPIACTR_initialisemessages(A68_BOOL  Lloption);

A_STATIC A68_VOID  ZOIACTR_generator(A68_BOOL  XOIACTR_anonymous, A68_VC  *ReturnedValue, void *NonLocals)
#define NL(x) (((APIACTR_generator *)NonLocals)->x)
{ 
A68_VC  BPIACTR;  /* clause result */
A68_VC  CPIACTR;  /* OPERATORS - dynamic generator */
{ 
CPIACTR.upb = NL(WOIACTR_mess).upb ;
( XOIACTR_anonymous? A_VLOC(A68_CHAR ,CPIACTR): A_VHEAP(A68_CHAR ,CPIACTR) );
BPIACTR = CPIACTR;
} 
*ReturnedValue = (BPIACTR);
return;
} 
#undef NL

A68_VOID  KDHACTR_message(A68_INT  Messagenumber, A68_VC  *ReturnedValue)
{ 
A68_VC  LDHACTR;  /* clause result */
A68_VC  MDHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  VDHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  EEHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  NEHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  YEHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  RYHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  OZHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  PZHACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  CAIACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  JCIACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  TOIACTR;  /* OPERATORS - scalar -> [] or VEC[] */
A68_VC  UOIACTR;  /* avoid structure result */
A68_VC  WOIACTR_mess;
A68_54  YOIACTR_generator;   /* proc value of non-global proc */
A68_VC  DPIACTR;  /* clause result */
A68_VC  EPIACTR;  /* avoid structure result */
A_PROC_ENTRY(message);
 /* line 47: */
 /* line 49: */
{ 
 /* line 50: */
 /* line 51: */
switch ( (Messagenumber-42) )
{ 
case 1: 
 /* line 52: */
LDHACTR = A_HVEC(MDHACTR,'[',A68_CHAR );
break;
case 2: 
 /* line 53: */
LDHACTR = ODHACTR;
break;
case 3: 
 /* line 54: */
LDHACTR = QDHACTR;
break;
case 4: 
 /* line 55: */
LDHACTR = SDHACTR;
break;
case 5: 
 /* line 56: */
LDHACTR = UDHACTR;
break;
case 6: 
 /* line 57: */
LDHACTR = A_HVEC(VDHACTR,'!',A68_CHAR );
break;
case 7: 
 /* line 58: */
LDHACTR = XDHACTR;
break;
case 8: 
 /* line 59: */
LDHACTR = ZDHACTR;
break;
case 9: 
 /* line 60: */
LDHACTR = BEHACTR;
break;
case 10: 
 /* line 61: */
LDHACTR = DEHACTR;
break;
case 11: 
 /* line 62: */
LDHACTR = A_HVEC(EEHACTR,')',A68_CHAR );
break;
case 12: 
 /* line 63: */
LDHACTR = GEHACTR;
break;
case 13: 
 /* line 64: */
LDHACTR = IEHACTR;
break;
case 14: 
 /* line 65: */
LDHACTR = KEHACTR;
break;
case 15: 
 /* line 66: */
LDHACTR = MEHACTR;
break;
case 16: 
 /* line 67: */
LDHACTR = A_HVEC(NEHACTR,'$',A68_CHAR );
break;
case 17: 
 /* line 68: */
LDHACTR = PEHACTR;
break;
case 18: 
 /* line 69: */
LDHACTR = REHACTR;
break;
case 19: 
 /* line 70: */
LDHACTR = TEHACTR;
break;
case 20: 
 /* line 71: */
LDHACTR = VEHACTR;
break;
case 21: 
 /* line 72: */
LDHACTR = XEHACTR;
break;
case 22: 
 /* line 73: */
LDHACTR = A_HVEC(YEHACTR,' ',A68_CHAR );
break;
case 23: 
 /* line 74: */
LDHACTR = AFHACTR;
break;
case 24: 
 /* line 75: */
LDHACTR = CFHACTR;
break;
case 25: 
 /* line 76: */
LDHACTR = EFHACTR;
break;
case 26: 
 /* line 77: */
LDHACTR = GFHACTR;
break;
case 27: 
 /* line 78: */
LDHACTR = IFHACTR;
break;
case 28: 
 /* line 79: */
LDHACTR = KFHACTR;
break;
case 29: 
 /* line 80: */
LDHACTR = MFHACTR;
break;
case 30: 
 /* line 81: */
LDHACTR = OFHACTR;
break;
case 31: 
 /* line 82: */
LDHACTR = QFHACTR;
break;
case 32: 
 /* line 83: */
LDHACTR = SFHACTR;
break;
case 33: 
 /* line 84: */
LDHACTR = UFHACTR;
break;
case 34: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = WFHACTR;
} 
else
{ 
 /* line 85: */
LDHACTR = YFHACTR;
} 
break;
case 35: 
 /* line 86: */
LDHACTR = AGHACTR;
break;
case 36: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = CGHACTR;
} 
else
{ 
 /* line 87: */
LDHACTR = EGHACTR;
} 
break;
case 37: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = GGHACTR;
} 
else
{ 
 /* line 88: */
LDHACTR = IGHACTR;
} 
break;
case 38: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = KGHACTR;
} 
else
{ 
 /* line 89: */
LDHACTR = MGHACTR;
} 
break;
case 39: 
 /* line 90: */
LDHACTR = OGHACTR;
break;
case 40: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = QGHACTR;
} 
else
{ 
 /* line 91: */
LDHACTR = SGHACTR;
} 
break;
case 41: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = UGHACTR;
} 
else
{ 
 /* line 92: */
LDHACTR = WGHACTR;
} 
break;
case 42: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = YGHACTR;
} 
else
{ 
 /* line 93: */
LDHACTR = AHHACTR;
} 
break;
case 43: 
 /* line 94: */
LDHACTR = CHHACTR;
break;
case 44: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = EHHACTR;
} 
else
{ 
 /* line 95: */
LDHACTR = GHHACTR;
} 
break;
case 45: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = IHHACTR;
} 
else
{ 
 /* line 96: */
LDHACTR = KHHACTR;
} 
break;
case 46: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = MHHACTR;
} 
else
{ 
 /* line 97: */
LDHACTR = OHHACTR;
} 
break;
case 47: 
 /* line 98: */
LDHACTR = QHHACTR;
break;
case 48: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = SHHACTR;
} 
else
{ 
 /* line 99: */
LDHACTR = UHHACTR;
} 
break;
case 49: 
if ( IDHACTR_longlongoption )
{ 
LDHACTR = WHHACTR;
} 
else
{ 
 /* line 100: */
LDHACTR = YHHACTR;
} 
break;
case 50: 
 /* line 101: */
LDHACTR = AIHACTR;
break;
case 51: 
 /* line 102: */
LDHACTR = CIHACTR;
break;
case 52: 
 /* line 103: */
LDHACTR = EIHACTR;
break;
case 53: 
 /* line 104: */
LDHACTR = GIHACTR;
break;
case 54: 
 /* line 105: */
LDHACTR = IIHACTR;
break;
case 55: 
 /* line 106: */
LDHACTR = KIHACTR;
break;
case 56: 
 /* line 107: */
LDHACTR = MIHACTR;
break;
case 57: 
 /* line 108: */
LDHACTR = OIHACTR;
break;
case 58: 
 /* line 109: */
LDHACTR = QIHACTR;
break;
case 59: 
 /* line 110: */
LDHACTR = SIHACTR;
break;
case 60: 
 /* line 111: */
LDHACTR = UIHACTR;
break;
case 61: 
 /* line 112: */
LDHACTR = WIHACTR;
break;
case 62: 
 /* line 113: */
LDHACTR = YIHACTR;
break;
case 63: 
 /* line 114: */
LDHACTR = AJHACTR;
break;
case 64: 
 /* line 115: */
LDHACTR = CJHACTR;
break;
case 65: 
 /* line 116: */
LDHACTR = EJHACTR;
break;
case 66: 
 /* line 117: */
LDHACTR = GJHACTR;
break;
case 67: 
 /* line 118: */
LDHACTR = IJHACTR;
break;
case 68: 
 /* line 119: */
LDHACTR = KJHACTR;
break;
case 69: 
 /* line 120: */
LDHACTR = MJHACTR;
break;
case 70: 
 /* line 121: */
LDHACTR = OJHACTR;
break;
case 71: 
 /* line 122: */
LDHACTR = QJHACTR;
break;
case 72: 
 /* line 123: */
LDHACTR = SJHACTR;
break;
case 73: 
 /* line 124: */
LDHACTR = UJHACTR;
break;
case 74: 
 /* line 125: */
LDHACTR = WJHACTR;
break;
case 75: 
 /* line 126: */
LDHACTR = YJHACTR;
break;
case 76: 
 /* line 127: */
LDHACTR = AKHACTR;
break;
case 77: 
 /* line 128: */
LDHACTR = CKHACTR;
break;
case 78: 
 /* line 129: */
LDHACTR = EKHACTR;
break;
case 79: 
 /* line 130: */
LDHACTR = GKHACTR;
break;
case 80: 
 /* line 131: */
LDHACTR = IKHACTR;
break;
case 81: 
 /* line 132: */
LDHACTR = KKHACTR;
break;
case 82: 
 /* line 133: */
LDHACTR = MKHACTR;
break;
case 83: 
 /* line 134: */
LDHACTR = OKHACTR;
break;
case 84: 
 /* line 135: */
LDHACTR = QKHACTR;
break;
case 85: 
 /* line 136: */
LDHACTR = SKHACTR;
break;
case 86: 
 /* line 137: */
LDHACTR = UKHACTR;
break;
case 87: 
 /* line 138: */
LDHACTR = WKHACTR;
break;
case 88: 
 /* line 139: */
LDHACTR = YKHACTR;
break;
case 89: 
 /* line 140: */
LDHACTR = ALHACTR;
break;
case 90: 
 /* line 141: */
LDHACTR = CLHACTR;
break;
case 91: 
 /* line 142: */
LDHACTR = ELHACTR;
break;
case 92: 
 /* line 143: */
LDHACTR = GLHACTR;
break;
case 93: 
 /* line 144: */
LDHACTR = ILHACTR;
break;
case 94: 
 /* line 145: */
LDHACTR = KLHACTR;
break;
case 95: 
 /* line 146: */
LDHACTR = MLHACTR;
break;
case 96: 
 /* line 147: */
LDHACTR = OLHACTR;
break;
case 97: 
 /* line 148: */
LDHACTR = QLHACTR;
break;
case 98: 
 /* line 149: */
LDHACTR = SLHACTR;
break;
case 99: 
 /* line 150: */
LDHACTR = ULHACTR;
break;
case 100: 
 /* line 151: */
LDHACTR = WLHACTR;
break;
case 101: 
 /* line 152: */
LDHACTR = YLHACTR;
break;
case 102: 
 /* line 153: */
LDHACTR = AMHACTR;
break;
case 103: 
 /* line 154: */
LDHACTR = CMHACTR;
break;
case 104: 
 /* line 155: */
LDHACTR = EMHACTR;
break;
case 105: 
 /* line 156: */
LDHACTR = GMHACTR;
break;
case 106: 
 /* line 157: */
LDHACTR = IMHACTR;
break;
case 107: 
 /* line 158: */
LDHACTR = KMHACTR;
break;
case 108: 
 /* line 159: */
LDHACTR = MMHACTR;
break;
case 109: 
 /* line 160: */
LDHACTR = OMHACTR;
break;
case 110: 
 /* line 161: */
LDHACTR = QMHACTR;
break;
case 111: 
 /* line 162: */
LDHACTR = SMHACTR;
break;
case 112: 
 /* line 163: */
LDHACTR = UMHACTR;
break;
case 113: 
 /* line 164: */
LDHACTR = WMHACTR;
break;
case 114: 
 /* line 165: */
LDHACTR = YMHACTR;
break;
case 115: 
 /* line 166: */
LDHACTR = ANHACTR;
break;
case 116: 
 /* line 167: */
LDHACTR = CNHACTR;
break;
case 117: 
 /* line 168: */
LDHACTR = ENHACTR;
break;
case 118: 
 /* line 169: */
LDHACTR = GNHACTR;
break;
case 119: 
 /* line 170: */
LDHACTR = INHACTR;
break;
case 120: 
 /* line 171: */
LDHACTR = KNHACTR;
break;
case 121: 
 /* line 172: */
LDHACTR = MNHACTR;
break;
case 122: 
 /* line 173: */
LDHACTR = ONHACTR;
break;
case 123: 
 /* line 174: */
LDHACTR = QNHACTR;
break;
case 124: 
 /* line 175: */
LDHACTR = SNHACTR;
break;
case 125: 
 /* line 176: */
LDHACTR = UNHACTR;
break;
case 126: 
 /* line 177: */
LDHACTR = WNHACTR;
break;
case 127: 
 /* line 178: */
LDHACTR = YNHACTR;
break;
case 128: 
 /* line 179: */
LDHACTR = AOHACTR;
break;
case 129: 
 /* line 180: */
LDHACTR = COHACTR;
break;
case 130: 
 /* line 181: */
LDHACTR = EOHACTR;
break;
case 131: 
 /* line 182: */
LDHACTR = GOHACTR;
break;
case 132: 
 /* line 185: */
LDHACTR = IOHACTR;
break;
case 133: 
 /* line 186: */
LDHACTR = KOHACTR;
break;
case 134: 
 /* line 187: */
LDHACTR = MOHACTR;
break;
case 135: 
 /* line 188: */
LDHACTR = OOHACTR;
break;
case 136: 
 /* line 189: */
LDHACTR = QOHACTR;
break;
case 137: 
 /* line 190: */
LDHACTR = SOHACTR;
break;
case 138: 
 /* line 191: */
LDHACTR = UOHACTR;
break;
case 139: 
 /* line 192: */
LDHACTR = WOHACTR;
break;
case 140: 
 /* line 193: */
LDHACTR = YOHACTR;
break;
case 141: 
 /* line 194: */
LDHACTR = APHACTR;
break;
case 142: 
 /* line 195: */
LDHACTR = CPHACTR;
break;
case 143: 
 /* line 196: */
LDHACTR = EPHACTR;
break;
case 144: 
 /* line 197: */
LDHACTR = GPHACTR;
break;
case 145: 
 /* line 198: */
LDHACTR = IPHACTR;
break;
case 146: 
 /* line 199: */
LDHACTR = KPHACTR;
break;
case 147: 
 /* line 200: */
LDHACTR = MPHACTR;
break;
case 148: 
 /* line 201: */
LDHACTR = OPHACTR;
break;
case 149: 
 /* line 202: */
LDHACTR = QPHACTR;
break;
case 150: 
 /* line 203: */
LDHACTR = SPHACTR;
break;
case 151: 
 /* line 204: */
LDHACTR = UPHACTR;
break;
case 152: 
 /* line 205: */
LDHACTR = WPHACTR;
break;
case 153: 
 /* line 206: */
LDHACTR = YPHACTR;
break;
case 154: 
 /* line 207: */
LDHACTR = AQHACTR;
break;
case 155: 
 /* line 208: */
LDHACTR = CQHACTR;
break;
case 156: 
 /* line 209: */
LDHACTR = EQHACTR;
break;
case 157: 
 /* line 210: */
LDHACTR = GQHACTR;
break;
case 158: 
 /* line 211: */
LDHACTR = IQHACTR;
break;
case 159: 
 /* line 212: */
LDHACTR = KQHACTR;
break;
case 160: 
 /* line 213: */
LDHACTR = MQHACTR;
break;
case 161: 
 /* line 214: */
LDHACTR = OQHACTR;
break;
case 162: 
 /* line 215: */
LDHACTR = QQHACTR;
break;
case 163: 
 /* line 216: */
LDHACTR = SQHACTR;
break;
case 164: 
 /* line 217: */
LDHACTR = UQHACTR;
break;
case 165: 
 /* line 218: */
LDHACTR = WQHACTR;
break;
case 166: 
 /* line 219: */
LDHACTR = YQHACTR;
break;
case 167: 
 /* line 220: */
LDHACTR = ARHACTR;
break;
case 168: 
 /* line 221: */
LDHACTR = CRHACTR;
break;
case 169: 
 /* line 222: */
LDHACTR = ERHACTR;
break;
case 170: 
 /* line 223: */
LDHACTR = GRHACTR;
break;
case 171: 
 /* line 225: */
LDHACTR = IRHACTR;
break;
case 172: 
LDHACTR = KRHACTR;
break;
default: 
 /* line 226: */
 /* line 227: */
switch ( (Messagenumber-249) )
{ 
case 1: 
 /* line 228: */
LDHACTR = MRHACTR;
break;
case 2: 
 /* line 229: */
LDHACTR = ORHACTR;
break;
case 3: 
 /* line 230: */
LDHACTR = QRHACTR;
break;
case 4: 
 /* line 231: */
LDHACTR = SRHACTR;
break;
case 5: 
 /* line 232: */
LDHACTR = URHACTR;
break;
case 6: 
 /* line 233: */
LDHACTR = WRHACTR;
break;
case 7: 
 /* line 234: */
LDHACTR = YRHACTR;
break;
case 8: 
 /* line 235: */
LDHACTR = ASHACTR;
break;
case 9: 
 /* line 236: */
LDHACTR = CSHACTR;
break;
case 10: 
 /* line 237: */
LDHACTR = ESHACTR;
break;
case 11: 
 /* line 238: */
LDHACTR = GSHACTR;
break;
case 12: 
 /* line 239: */
LDHACTR = ISHACTR;
break;
case 13: 
 /* line 240: */
LDHACTR = KSHACTR;
break;
case 14: 
 /* line 242: */
LDHACTR = MSHACTR;
break;
case 15: 
LDHACTR = OSHACTR;
break;
default: 
 /* line 243: */
 /* line 245: */
switch ( (Messagenumber-269) )
{ 
case 1: 
 /* line 246: */
LDHACTR = QSHACTR;
break;
case 2: 
 /* line 247: */
LDHACTR = SSHACTR;
break;
case 3: 
 /* line 248: */
LDHACTR = USHACTR;
break;
case 4: 
 /* line 249: */
LDHACTR = WSHACTR;
break;
case 5: 
 /* line 250: */
LDHACTR = YSHACTR;
break;
case 6: 
 /* line 251: */
LDHACTR = ATHACTR;
break;
case 7: 
 /* line 252: */
LDHACTR = CTHACTR;
break;
case 8: 
 /* line 253: */
LDHACTR = ETHACTR;
break;
case 9: 
 /* line 254: */
LDHACTR = GTHACTR;
break;
case 10: 
 /* line 255: */
LDHACTR = ITHACTR;
break;
case 11: 
 /* line 256: */
LDHACTR = KTHACTR;
break;
case 12: 
 /* line 257: */
LDHACTR = MTHACTR;
break;
case 13: 
 /* line 258: */
LDHACTR = OTHACTR;
break;
case 14: 
 /* line 259: */
LDHACTR = QTHACTR;
break;
case 15: 
 /* line 260: */
LDHACTR = STHACTR;
break;
case 16: 
 /* line 262: */
LDHACTR = UTHACTR;
break;
case 17: 
LDHACTR = WTHACTR;
break;
default: 
 /* line 263: */
 /* line 264: */
switch ( (Messagenumber-299) )
{ 
case 1: 
 /* line 265: */
LDHACTR = YTHACTR;
break;
case 2: 
 /* line 266: */
LDHACTR = AUHACTR;
break;
case 3: 
 /* line 267: */
LDHACTR = CUHACTR;
break;
case 4: 
 /* line 268: */
LDHACTR = EUHACTR;
break;
case 5: 
 /* line 269: */
LDHACTR = GUHACTR;
break;
case 6: 
 /* line 270: */
LDHACTR = IUHACTR;
break;
case 7: 
 /* line 271: */
LDHACTR = KUHACTR;
break;
case 8: 
 /* line 272: */
LDHACTR = MUHACTR;
break;
case 9: 
 /* line 273: */
LDHACTR = OUHACTR;
break;
case 10: 
 /* line 274: */
LDHACTR = QUHACTR;
break;
case 11: 
 /* line 275: */
LDHACTR = SUHACTR;
break;
case 12: 
 /* line 276: */
LDHACTR = UUHACTR;
break;
case 13: 
 /* line 277: */
LDHACTR = WUHACTR;
break;
case 14: 
 /* line 278: */
LDHACTR = YUHACTR;
break;
case 15: 
 /* line 279: */
LDHACTR = AVHACTR;
break;
case 16: 
 /* line 280: */
LDHACTR = CVHACTR;
break;
case 17: 
 /* line 281: */
LDHACTR = EVHACTR;
break;
case 18: 
 /* line 282: */
LDHACTR = GVHACTR;
break;
case 19: 
 /* line 283: */
LDHACTR = IVHACTR;
break;
case 20: 
 /* line 284: */
LDHACTR = KVHACTR;
break;
case 21: 
 /* line 285: */
LDHACTR = MVHACTR;
break;
case 22: 
 /* line 286: */
LDHACTR = OVHACTR;
break;
case 23: 
 /* line 287: */
LDHACTR = QVHACTR;
break;
case 24: 
 /* line 288: */
LDHACTR = SVHACTR;
break;
case 25: 
 /* line 289: */
LDHACTR = UVHACTR;
break;
case 26: 
 /* line 290: */
LDHACTR = WVHACTR;
break;
case 27: 
 /* line 291: */
LDHACTR = YVHACTR;
break;
case 28: 
 /* line 292: */
LDHACTR = AWHACTR;
break;
case 29: 
 /* line 293: */
LDHACTR = CWHACTR;
break;
case 30: 
 /* line 294: */
LDHACTR = EWHACTR;
break;
case 31: 
 /* line 295: */
LDHACTR = GWHACTR;
break;
case 32: 
 /* line 296: */
LDHACTR = IWHACTR;
break;
case 33: 
 /* line 297: */
LDHACTR = KWHACTR;
break;
case 34: 
 /* line 298: */
LDHACTR = MWHACTR;
break;
case 35: 
 /* line 299: */
LDHACTR = OWHACTR;
break;
case 36: 
 /* line 300: */
LDHACTR = QWHACTR;
break;
case 37: 
 /* line 301: */
LDHACTR = SWHACTR;
break;
case 38: 
 /* line 302: */
LDHACTR = UWHACTR;
break;
case 39: 
 /* line 303: */
LDHACTR = WWHACTR;
break;
case 40: 
 /* line 304: */
LDHACTR = YWHACTR;
break;
case 41: 
 /* line 305: */
LDHACTR = AXHACTR;
break;
case 42: 
 /* line 306: */
LDHACTR = CXHACTR;
break;
case 43: 
 /* line 307: */
LDHACTR = EXHACTR;
break;
case 44: 
 /* line 308: */
LDHACTR = GXHACTR;
break;
case 45: 
 /* line 309: */
LDHACTR = IXHACTR;
break;
case 46: 
 /* line 310: */
LDHACTR = KXHACTR;
break;
case 47: 
 /* line 311: */
LDHACTR = MXHACTR;
break;
case 48: 
 /* line 312: */
LDHACTR = OXHACTR;
break;
case 49: 
 /* line 313: */
LDHACTR = QXHACTR;
break;
case 50: 
 /* line 314: */
LDHACTR = SXHACTR;
break;
case 51: 
 /* line 315: */
LDHACTR = UXHACTR;
break;
case 52: 
 /* line 316: */
LDHACTR = WXHACTR;
break;
case 53: 
 /* line 317: */
LDHACTR = YXHACTR;
break;
case 54: 
 /* line 318: */
LDHACTR = AYHACTR;
break;
case 55: 
 /* line 320: */
LDHACTR = CYHACTR;
break;
case 56: 
LDHACTR = EYHACTR;
break;
default: 
 /* line 321: */
 /* line 322: */
switch ( (Messagenumber-500) )
{ 
case 1: 
 /* line 323: */
LDHACTR = GYHACTR;
break;
case 2: 
 /* line 324: */
LDHACTR = IYHACTR;
break;
case 3: 
 /* line 325: */
LDHACTR = KYHACTR;
break;
case 4: 
 /* line 326: */
LDHACTR = MYHACTR;
break;
case 5: 
 /* line 327: */
LDHACTR = OYHACTR;
break;
case 6: 
 /* line 328: */
LDHACTR = QYHACTR;
break;
case 7: 
 /* line 329: */
LDHACTR = A_HVEC(RYHACTR,'(',A68_CHAR );
break;
case 8: 
 /* line 330: */
LDHACTR = TYHACTR;
break;
case 9: 
 /* line 331: */
LDHACTR = VYHACTR;
break;
case 10: 
 /* line 332: */
LDHACTR = XYHACTR;
break;
case 11: 
 /* line 333: */
LDHACTR = ZYHACTR;
break;
case 12: 
 /* line 334: */
LDHACTR = BZHACTR;
break;
case 13: 
 /* line 335: */
LDHACTR = DZHACTR;
break;
case 14: 
 /* line 336: */
LDHACTR = FZHACTR;
break;
case 15: 
 /* line 337: */
LDHACTR = HZHACTR;
break;
case 16: 
 /* line 338: */
LDHACTR = JZHACTR;
break;
case 17: 
 /* line 339: */
LDHACTR = LZHACTR;
break;
case 18: 
 /* line 340: */
LDHACTR = NZHACTR;
break;
case 19: 
 /* line 341: */
LDHACTR = A_HVEC(OZHACTR,',',A68_CHAR );
break;
case 20: 
 /* line 342: */
LDHACTR = A_HVEC(PZHACTR,';',A68_CHAR );
break;
case 21: 
 /* line 343: */
LDHACTR = RZHACTR;
break;
case 22: 
 /* line 344: */
LDHACTR = TZHACTR;
break;
case 23: 
 /* line 345: */
LDHACTR = VZHACTR;
break;
case 24: 
 /* line 346: */
LDHACTR = XZHACTR;
break;
case 25: 
 /* line 347: */
LDHACTR = ZZHACTR;
break;
case 26: 
 /* line 348: */
LDHACTR = BAIACTR;
break;
case 27: 
 /* line 349: */
LDHACTR = A_HVEC(CAIACTR,')',A68_CHAR );
break;
case 28: 
 /* line 350: */
LDHACTR = EAIACTR;
break;
case 29: 
 /* line 351: */
LDHACTR = GAIACTR;
break;
case 30: 
 /* line 352: */
LDHACTR = IAIACTR;
break;
case 31: 
 /* line 353: */
LDHACTR = KAIACTR;
break;
case 32: 
 /* line 354: */
LDHACTR = MAIACTR;
break;
case 33: 
 /* line 355: */
LDHACTR = OAIACTR;
break;
case 34: 
 /* line 356: */
LDHACTR = QAIACTR;
break;
case 35: 
 /* line 357: */
LDHACTR = SAIACTR;
break;
case 36: 
 /* line 358: */
LDHACTR = UAIACTR;
break;
case 37: 
 /* line 359: */
LDHACTR = WAIACTR;
break;
case 38: 
 /* line 360: */
LDHACTR = YAIACTR;
break;
case 39: 
 /* line 361: */
LDHACTR = ABIACTR;
break;
case 40: 
 /* line 362: */
LDHACTR = CBIACTR;
break;
case 41: 
 /* line 363: */
LDHACTR = EBIACTR;
break;
case 42: 
 /* line 364: */
LDHACTR = GBIACTR;
break;
case 43: 
 /* line 365: */
LDHACTR = IBIACTR;
break;
case 44: 
 /* line 366: */
LDHACTR = KBIACTR;
break;
case 45: 
 /* line 367: */
LDHACTR = MBIACTR;
break;
case 46: 
 /* line 368: */
LDHACTR = OBIACTR;
break;
case 47: 
 /* line 369: */
LDHACTR = QBIACTR;
break;
case 48: 
 /* line 370: */
LDHACTR = SBIACTR;
break;
case 49: 
 /* line 372: */
LDHACTR = UBIACTR;
break;
case 50: 
 /* line 373: */
LDHACTR = WBIACTR;
break;
case 51: 
 /* line 374: */
LDHACTR = YBIACTR;
break;
case 52: 
 /* line 375: */
LDHACTR = ACIACTR;
break;
case 53: 
 /* line 376: */
LDHACTR = CCIACTR;
break;
case 54: 
 /* line 377: */
LDHACTR = ECIACTR;
break;
case 55: 
 /* line 378: */
LDHACTR = GCIACTR;
break;
case 56: 
 /* line 379: */
LDHACTR = ICIACTR;
break;
case 57: 
 /* line 380: */
LDHACTR = A_HVEC(JCIACTR,'[',A68_CHAR );
break;
case 58: 
 /* line 381: */
LDHACTR = LCIACTR;
break;
case 59: 
 /* line 382: */
LDHACTR = NCIACTR;
break;
case 60: 
 /* line 383: */
LDHACTR = PCIACTR;
break;
case 61: 
 /* line 384: */
LDHACTR = RCIACTR;
break;
case 62: 
 /* line 385: */
LDHACTR = TCIACTR;
break;
case 63: 
 /* line 386: */
LDHACTR = VCIACTR;
break;
case 64: 
 /* line 387: */
LDHACTR = XCIACTR;
break;
case 65: 
 /* line 388: */
LDHACTR = ZCIACTR;
break;
case 66: 
 /* line 389: */
LDHACTR = BDIACTR;
break;
case 67: 
 /* line 390: */
LDHACTR = DDIACTR;
break;
case 68: 
 /* line 391: */
LDHACTR = FDIACTR;
break;
case 69: 
 /* line 392: */
LDHACTR = HDIACTR;
break;
case 70: 
 /* line 393: */
LDHACTR = JDIACTR;
break;
case 71: 
 /* line 394: */
LDHACTR = LDIACTR;
break;
case 72: 
 /* line 395: */
LDHACTR = NDIACTR;
break;
case 73: 
 /* line 396: */
LDHACTR = PDIACTR;
break;
case 74: 
 /* line 397: */
LDHACTR = RDIACTR;
break;
case 75: 
 /* line 398: */
LDHACTR = TDIACTR;
break;
case 76: 
 /* line 399: */
LDHACTR = VDIACTR;
break;
case 77: 
 /* line 400: */
LDHACTR = XDIACTR;
break;
case 78: 
 /* line 401: */
LDHACTR = ZDIACTR;
break;
case 79: 
 /* line 402: */
LDHACTR = BEIACTR;
break;
case 80: 
 /* line 403: */
LDHACTR = DEIACTR;
break;
case 81: 
 /* line 404: */
LDHACTR = FEIACTR;
break;
case 82: 
 /* line 405: */
LDHACTR = HEIACTR;
break;
case 83: 
 /* line 406: */
LDHACTR = JEIACTR;
break;
case 84: 
 /* line 407: */
LDHACTR = LEIACTR;
break;
case 85: 
 /* line 408: */
LDHACTR = NEIACTR;
break;
case 86: 
 /* line 409: */
LDHACTR = PEIACTR;
break;
case 87: 
 /* line 410: */
LDHACTR = REIACTR;
break;
case 88: 
 /* line 411: */
LDHACTR = TEIACTR;
break;
case 89: 
 /* line 412: */
LDHACTR = VEIACTR;
break;
case 90: 
 /* line 413: */
LDHACTR = XEIACTR;
break;
case 91: 
 /* line 414: */
LDHACTR = ZEIACTR;
break;
case 92: 
 /* line 415: */
LDHACTR = BFIACTR;
break;
case 93: 
 /* line 416: */
LDHACTR = DFIACTR;
break;
case 94: 
 /* line 417: */
LDHACTR = FFIACTR;
break;
case 95: 
 /* line 418: */
LDHACTR = HFIACTR;
break;
case 96: 
 /* line 419: */
LDHACTR = JFIACTR;
break;
case 97: 
 /* line 420: */
LDHACTR = LFIACTR;
break;
case 98: 
 /* line 421: */
LDHACTR = NFIACTR;
break;
case 99: 
 /* line 422: */
LDHACTR = PFIACTR;
break;
case 100: 
 /* line 423: */
LDHACTR = RFIACTR;
break;
case 101: 
 /* line 424: */
LDHACTR = TFIACTR;
break;
case 102: 
 /* line 425: */
LDHACTR = VFIACTR;
break;
case 103: 
 /* line 426: */
LDHACTR = XFIACTR;
break;
case 104: 
 /* line 427: */
LDHACTR = ZFIACTR;
break;
case 105: 
 /* line 428: */
LDHACTR = BGIACTR;
break;
case 106: 
 /* line 429: */
LDHACTR = DGIACTR;
break;
case 107: 
 /* line 430: */
LDHACTR = FGIACTR;
break;
case 108: 
 /* line 431: */
LDHACTR = HGIACTR;
break;
case 109: 
 /* line 432: */
LDHACTR = JGIACTR;
break;
case 110: 
 /* line 433: */
LDHACTR = LGIACTR;
break;
case 111: 
 /* line 434: */
LDHACTR = NGIACTR;
break;
case 112: 
 /* line 435: */
LDHACTR = PGIACTR;
break;
case 113: 
 /* line 436: */
LDHACTR = RGIACTR;
break;
case 114: 
 /* line 437: */
LDHACTR = TGIACTR;
break;
case 115: 
 /* line 438: */
LDHACTR = VGIACTR;
break;
case 116: 
 /* line 439: */
LDHACTR = XGIACTR;
break;
case 117: 
 /* line 440: */
LDHACTR = ZGIACTR;
break;
case 118: 
 /* line 441: */
LDHACTR = BHIACTR;
break;
case 119: 
 /* line 442: */
LDHACTR = DHIACTR;
break;
case 120: 
 /* line 443: */
LDHACTR = FHIACTR;
break;
case 121: 
 /* line 444: */
LDHACTR = HHIACTR;
break;
case 122: 
 /* line 445: */
LDHACTR = JHIACTR;
break;
case 123: 
 /* line 446: */
LDHACTR = LHIACTR;
break;
case 124: 
 /* line 447: */
LDHACTR = NHIACTR;
break;
case 125: 
 /* line 448: */
LDHACTR = PHIACTR;
break;
case 126: 
 /* line 449: */
LDHACTR = RHIACTR;
break;
case 127: 
 /* line 450: */
LDHACTR = THIACTR;
break;
case 128: 
 /* line 451: */
LDHACTR = VHIACTR;
break;
case 129: 
 /* line 452: */
LDHACTR = XHIACTR;
break;
case 130: 
 /* line 453: */
LDHACTR = ZHIACTR;
break;
case 131: 
 /* line 454: */
LDHACTR = BIIACTR;
break;
case 132: 
 /* line 455: */
LDHACTR = DIIACTR;
break;
case 133: 
 /* line 456: */
LDHACTR = FIIACTR;
break;
case 134: 
 /* line 457: */
LDHACTR = HIIACTR;
break;
case 135: 
 /* line 458: */
LDHACTR = JIIACTR;
break;
case 136: 
 /* line 459: */
LDHACTR = LIIACTR;
break;
case 137: 
 /* line 460: */
LDHACTR = NIIACTR;
break;
case 138: 
 /* line 461: */
LDHACTR = PIIACTR;
break;
case 139: 
 /* line 462: */
LDHACTR = RIIACTR;
break;
case 140: 
 /* line 463: */
LDHACTR = TIIACTR;
break;
case 141: 
 /* line 464: */
LDHACTR = VIIACTR;
break;
case 142: 
 /* line 465: */
LDHACTR = XIIACTR;
break;
case 143: 
 /* line 466: */
LDHACTR = ZIIACTR;
break;
case 144: 
 /* line 467: */
LDHACTR = BJIACTR;
break;
case 145: 
 /* line 468: */
LDHACTR = DJIACTR;
break;
case 146: 
 /* line 469: */
LDHACTR = FJIACTR;
break;
case 147: 
 /* line 470: */
LDHACTR = HJIACTR;
break;
case 148: 
 /* line 471: */
LDHACTR = JJIACTR;
break;
case 149: 
 /* line 472: */
LDHACTR = LJIACTR;
break;
case 150: 
 /* line 473: */
LDHACTR = NJIACTR;
break;
case 151: 
 /* line 474: */
LDHACTR = PJIACTR;
break;
case 152: 
 /* line 475: */
LDHACTR = RJIACTR;
break;
case 153: 
 /* line 476: */
LDHACTR = TJIACTR;
break;
case 154: 
 /* line 477: */
LDHACTR = VJIACTR;
break;
case 155: 
 /* line 478: */
LDHACTR = XJIACTR;
break;
case 156: 
 /* line 479: */
LDHACTR = ZJIACTR;
break;
case 157: 
 /* line 480: */
LDHACTR = BKIACTR;
break;
case 158: 
 /* line 481: */
LDHACTR = DKIACTR;
break;
case 159: 
 /* line 482: */
LDHACTR = FKIACTR;
break;
case 160: 
 /* line 483: */
LDHACTR = HKIACTR;
break;
case 161: 
 /* line 484: */
LDHACTR = JKIACTR;
break;
case 162: 
 /* line 485: */
LDHACTR = LKIACTR;
break;
case 163: 
 /* line 486: */
LDHACTR = NKIACTR;
break;
case 164: 
 /* line 487: */
LDHACTR = PKIACTR;
break;
case 165: 
 /* line 488: */
LDHACTR = RKIACTR;
break;
case 166: 
 /* line 489: */
LDHACTR = TKIACTR;
break;
case 167: 
 /* line 490: */
LDHACTR = VKIACTR;
break;
case 168: 
 /* line 491: */
LDHACTR = XKIACTR;
break;
case 169: 
 /* line 492: */
LDHACTR = ZKIACTR;
break;
case 170: 
 /* line 493: */
LDHACTR = BLIACTR;
break;
case 171: 
 /* line 494: */
LDHACTR = DLIACTR;
break;
case 172: 
 /* line 496: */
LDHACTR = FLIACTR;
break;
case 173: 
LDHACTR = HLIACTR;
break;
default: 
 /* line 497: */
 /* line 498: */
switch ( (Messagenumber-699) )
{ 
case 1: 
 /* line 499: */
LDHACTR = JLIACTR;
break;
case 2: 
 /* line 500: */
LDHACTR = LLIACTR;
break;
case 3: 
 /* line 501: */
LDHACTR = NLIACTR;
break;
case 4: 
 /* line 502: */
LDHACTR = PLIACTR;
break;
case 5: 
 /* line 503: */
LDHACTR = RLIACTR;
break;
case 6: 
 /* line 504: */
LDHACTR = TLIACTR;
break;
case 7: 
 /* line 505: */
LDHACTR = VLIACTR;
break;
case 8: 
 /* line 506: */
LDHACTR = XLIACTR;
break;
case 9: 
 /* line 507: */
LDHACTR = ZLIACTR;
break;
case 10: 
 /* line 508: */
LDHACTR = BMIACTR;
break;
case 11: 
 /* line 509: */
LDHACTR = DMIACTR;
break;
case 12: 
 /* line 510: */
LDHACTR = FMIACTR;
break;
case 13: 
 /* line 511: */
LDHACTR = HMIACTR;
break;
case 14: 
 /* line 512: */
LDHACTR = JMIACTR;
break;
case 15: 
 /* line 513: */
LDHACTR = LMIACTR;
break;
case 16: 
 /* line 515: */
LDHACTR = NMIACTR;
break;
case 17: 
LDHACTR = PMIACTR;
break;
default: 
 /* line 516: */
 /* line 518: */
switch ( (Messagenumber-719) )
{ 
case 1: 
LDHACTR = RMIACTR;
break;
default: 
 /* line 519: */
 /* line 520: */
switch ( (Messagenumber-749) )
{ 
case 1: 
 /* line 522: */
LDHACTR = TMIACTR;
break;
case 2: 
LDHACTR = VMIACTR;
break;
default: 
 /* line 523: */
 /* line 524: */
switch ( (Messagenumber-798) )
{ 
case 1: 
 /* line 525: */
LDHACTR = XMIACTR;
break;
case 2: 
 /* line 526: */
LDHACTR = ZMIACTR;
break;
case 3: 
 /* line 527: */
LDHACTR = BNIACTR;
break;
case 4: 
 /* line 528: */
LDHACTR = DNIACTR;
break;
case 5: 
 /* line 529: */
LDHACTR = FNIACTR;
break;
case 6: 
 /* line 530: */
LDHACTR = HNIACTR;
break;
case 7: 
 /* line 531: */
LDHACTR = JNIACTR;
break;
case 8: 
 /* line 532: */
LDHACTR = LNIACTR;
break;
case 9: 
 /* line 533: */
LDHACTR = NNIACTR;
break;
case 10: 
 /* line 534: */
LDHACTR = PNIACTR;
break;
case 11: 
 /* line 537: */
LDHACTR = RNIACTR;
break;
case 12: 
 /* line 538: */
LDHACTR = TNIACTR;
break;
case 13: 
 /* line 539: */
LDHACTR = VNIACTR;
break;
case 14: 
 /* line 540: */
LDHACTR = XNIACTR;
break;
case 15: 
 /* line 541: */
LDHACTR = ZNIACTR;
break;
case 16: 
 /* line 542: */
LDHACTR = BOIACTR;
break;
case 17: 
 /* line 543: */
LDHACTR = DOIACTR;
break;
case 18: 
 /* line 545: */
LDHACTR = FOIACTR;
break;
case 19: 
LDHACTR = HOIACTR;
break;
default: 
 /* line 546: */
 /* line 547: */
switch ( (Messagenumber-899) )
{ 
case 1: 
 /* line 548: */
LDHACTR = JOIACTR;
break;
case 2: 
 /* line 549: */
LDHACTR = LOIACTR;
break;
case 3: 
 /* line 550: */
LDHACTR = NOIACTR;
break;
case 4: 
 /* line 552: */
LDHACTR = POIACTR;
break;
case 5: 
 /* line 553: */
LDHACTR = ROIACTR;
break;
default: 
 /* line 554: */
ROAAOSF_whole( Messagenumber, 0, &UOIACTR );
LDHACTR = A_VC_PLUS(A_VC_PLUS(A_HVEC(TOIACTR,'(',A68_CHAR ),UOIACTR),VOIACTR);
break;
} 
break;
} 
break;
} 
break;
} 
break;
} 
break;
} 
break;
} 
break;
} 
break;
} 
break;
} 
WOIACTR_mess = LDHACTR;
 /* line 556: */
A_CLOSURE( YOIACTR_generator, ZOIACTR_generator, APIACTR_generator );
(( APIACTR_generator * ) ( YOIACTR_generator.nonlocals )) -> WOIACTR_mess = WOIACTR_mess;
 /* line 557: */
A_CALLPROC(YOIACTR_generator,(A68_FALSE, &EPIACTR),(A68_FALSE, &EPIACTR,(YOIACTR_generator).nonlocals));
A_VASSIGN2(WOIACTR_mess,EPIACTR,A68_CHAR ) ;
DPIACTR = EPIACTR;
} 
A_PROC_EXIT(message);
*ReturnedValue = (DPIACTR);
return;
} 
#undef NL

A68_VOID  GPIACTR_initialisemessages(A68_BOOL  Lloption)
{ 
A_PROC_ENTRY(initialisemessages);
IDHACTR_longlongoption = Lloption;
A_PROC_EXIT(initialisemessages);
return;
} 
#undef NL
 /* line 2: */
 /* line 5: */
void DDHACTR(void)   /* initialise DECS message */
{ 
static A68_BOOL A_invoked = A68_FALSE;

/* --- Configuration information for this module */
static char *A_config_arguments[] = {"/home/neil/Algol-68RS/algol68toc-1.20/src/a68toc","-v","-uname","seedfile","-staredit","59LR","-lib","/home/neil/Algol-68RS/algol68toc-1.20/a68config","-dir","/home/neil/Algol-68RS/algol68toc-1.20/a68config","-dir","/home/neil/Algol-68RS/algol68toc-1.20/liba68prel","-dir",".","message.a68",""};
static char *A_config_environment[] = {"A68_LIB=/home/neil/Algol-68RS/algol68toc-1.20/a68config","A68_CDIR=","A68_DIR=","A68_STAREDIT=","A68_NAMESEED=nameseed","CTRANS_NAMESEED=",""};
static char *A_config_modinfo_files[] = {"/home/neil/Algol-68RS/algol68toc-1.20/a68config/a68config.m","/home/neil/Algol-68RS/algol68toc-1.20/liba68prel/usefulops.m",""};
static A_CONFIG_INFO A_config;
/* --- end of configuration information */
if( A_invoked ) return;
A_invoked = A68_TRUE;
BAAALIB();   /* USE a68config */
IKAAOSF();   /* USE usefulops */
/* --- Initialise configuration information */
A_config.source_file = "/home/neil/Algol-68RS/algol68toc-1.20/src/message.a68";
A_config.translation_time = "Sun Apr 18 20:07:52 2021";
A_config.ctrans_version = "Ctrans_34.6";
A_config.name_seed = "CDHACTR (from seed file) ";
A_config.spec_change_time = "Sun Apr 18 20:07:52 2021";
A_config.arguments = A_config_arguments;
A_config.environment = A_config_environment;
A_config.modinfo_files = A_config_modinfo_files;
A_PROC_ENTRY(DECS message);
UEAALIB_a68config(LGAALIB_configinfo, HDHACTR);
 /* line 44: */
IDHACTR_longlongoption = A68_FALSE;
 /* line 46: */
 /* line 560: */
 /* line 562: */
 /* line 564: */
 /* line 566: */
/*SKIP*/;
A_PROC_EXIT(DECS message);
} 
#undef NL
/* end of translation of message.a68 */
