DECS  compiler  CONTEXT VOID  USE
*L    usefulops,
      centities, clauses, common, entryandreturn, environ, environment,
      identifiers, incimperatives, incoperfn, incvalue,  initialiser, loads,
      loops, incmode, modes, modules, moduletracer, oper, uniquenameserver,
      coutput, values:

configinfo A68CONFIG "$Id: compiler.a68,v 1.1.1.1 2001-05-07 10:16:10 sian Exp $";


COMMENT 
    ************************************************************************
    This Program is the property of the Secretary of State for Defence
    (United Kingdom) acting through the Defence Research Agency (DRA). Use,
    reproduction, production of amended versions and/or transfer of this
    Program is permitted provided that:

  (a)  this legend be preserved on any such reproduction and amended version,
  (b)  any amended version of this Program be clearly marked to show the
       nature of the amendment and of the name of the amending organisation,
  and
  (c)  any recipient  of such reproduction or amended version accept the
       conditions set out in this legend.

                         Crown Copyright, (c)   1993

                             All rights reserved.

    The Secretary of State for Defence (United Kingdom) acting through his
    Defence Research Agency (DRA) gives no warranty that any element of the
    Software is suitable for any purpose and he shall not be liable for any
    loss or damage including loss or damage resulting in injury or death
    howsoever caused which results from the use of the Software, or any
    developments adaptions modifications translations and enhancements
    thereof.

    The original authors may be contacted via email on ella@dra.hmg.gb or by
    writing to ELLA Office, DRA, St Andrews Road, Malvern, Worcs WR14 3PS, UK.
    ************************************************************************

25:08:94  33.001  ELLA  NewConFig Entered in new config system previous version
                                  number 2.7 
29:03:95  34.002  ELLA  Modcprght Change copyright header
??:??:??   ?.???  ????
COMMENT

{
        This module contains the translator which translates the stream
        generated by compilations, calling semantic routines to produce the C
        code required to construct the C output files. Unless a compilation
	error has been detected,
        'close coutput' is called to collate the C streams and output the C
        source (.c) and, for DECS modules, the C header (.h) and modinfo files.
        Otherwise, 'purge c output files' is called to tidy up.
}                                                   

PROC translator = (
	PROC IMPERATIVE next stream imperative,
	REF XSIZES xsizes,
	REF [] INT kept decnos
) VOID:
BEGIN

IMPERATIVE	current imperative := EMPTY,
		next imperative := EMPTY;

PROC	read = VOID:
{
	Reads the next imperative into 'current imperative', either from
	'next imperative' (which is then set EMPTY), or from stream if
	'next imperative' is EMPTY.
}
CASE	next imperative
IN
	(VOID): current imperative := next stream imperative
OUT
	current imperative := next imperative;
	next imperative    := EMPTY
ESAC;

PROC	lookahead = VOID:
{
	Reads the 'next stream imperative' into 'next imperative', unless
	'next imperative' is not EMPTY, only one call of 'lookahead' being
	permitted between calls of 'read'.
}
CASE	next imperative
IN
	(VOID): next imperative := next stream imperative
OUT
	terminal error (602 { more than one stream 'lookahead' attempted })
ESAC;

PROC	composition module = VOID:
{
	Processes a <composition module>, where
	<composition module> ::= externalmodule* <closure>* finish
	<closure> ::= [closure | synthetic module]* <closure>
}
	"Composition modules not supported" ASSERT FALSE;


PROC	module =
( REF VECTOR []CHAR module name,
  BOOL decs module, prelude
) VOID:
{
Processes the entire <cc module> or <decs module>; a <cc module> is equivalent
to a PROC VOID routine, other than in the case of a procedural module, the
syntactic convenience used to permit complete programs to accept parameters
and deliver results.

<module> ::= <cc module> | <decs module>
<decs module> ::= <serial clause with keeplist> finish
<cc module> ::= [<complex clause> | <choice clause> | <collateral clause> |
		 <simple loop clause> | <simple phrase>] finish
<complex clause> ::= {a closed clause containing ";" other than in a routine}
<simple loop clause> ::= {a loop clause containing no ";" other than in a routine}
<simple phrase> ::= <simple primary> [<simple primary>]*
<simple primary> ::= load | oper | labdec | <routine>
}
BEGIN
	PROC( BOOL, ANSWER, BOOL )VOID phrase_;
	{ 'phrase' is mutually recursive with 'serial clause',
	  'enquiry clause, and 'routine'
	}

	PROC	skip routine = VOID:
	{ Skips an entire stream language <routine>, where
	  <routine> ::= routine <phrase> routinend
	}
	WHILE	read; { the next imperative of the <phrase> }
		CASE	current imperative	IN
		(ROUTINE):	( skip routine; TRUE ),
	 	(TERMINATOR t): fn OF t /= routinend fn
		OUT		TRUE
		ESAC
	DO
		SKIP
	OD;

	PROC	routine = (ROUTINE routine) VOID:
	{
	 Called by 'phrase' to process a <routine>, where
	 <routine> ::= routine <phrase> routinend
	}
	BEGIN
		ENVIRON environ := environ OF ids [maxname OF routine];

		WHILE	look ahead;
			CASE next imperative	IN
			(LABDEC label):
			BEGIN
				labdec( label );
				ENVIRON label environ =
					environ of label( labno OF label);
				IF	label environ ISNEWERTHAN environ
				THEN	environ := label environ
				FI;
				read;	TRUE
			END,

			(ROUTINE r):
				IF	mode type (mode OF routine) = procp
				THEN	{ skip formal generator routines }
					"generator routine"
					ASSERT	name OF r = "!generator";
					read; { from 'next imperative' }
					skip routine;
					TRUE
				ELSE	FALSE
				FI
			OUT	FALSE
			ESAC
		DO
			SKIP
		OD;

		INT	result type := routine result;
		VALUE	result;
		REF LABEL end of routine;

		start new level( rdenno OF routine ); { new declaration level }

		PROCINFO proc = proc info( mode OF routine );
		INT param count = parameters OF proc;
		REF VECTOR [] INT null list = HEAP VECTOR [0] INT;
		REF VECTOR [] INT param modes,
				  param decnos;
				  
		IF param count > 0
		THEN
			param modes := parameters( mode OF routine );
			param decnos := HEAP VECTOR [param count] INT;
			FOR i TO param count
			DO
				read;
				CASE current imperative IN
				( TRANSIDDEC id ):
				BEGIN
		   		     	"COMPILER: fdec expected" ASSERT
					type OF id = 3; { formal parameter }
					"COMPILER: fdec has unexpected mode"
 	 				ASSERT find deflex mode (mode OF id) = find deflex mode (param modes[i]);
					param decnos[i] := decno OF id;
					iddec( id, NIL )
				END
				OUT
					"COMPILER: TRANSIDDEC (fdec) expected here"
					ASSERT FALSE
				ESAC
			OD
		ELSE
			param decnos := null list
		FI;
		           
		start routine
		( routine,
		  environ,                                               
		  param decnos,
		  result OF proc,
		  result
		);
		{ !!! The return of 'start routine' appears to corrupt
		  the stack frame of the caller of 'routine' ('phrase')
		  This must be investigated at some point !!! }

		phrase_
		( props OF routine >= ccbit,
		  ( result, end of routine, result type ),
		  FALSE
		);
		{ !!! The same comments apply here !!! }

		end routine( routine, result );
		revert to previous level 
	END;

	PROC	serial clause =( PROPERTIES properties, ANSWER answer )VOID:
	{
	 Processes the <serial clause>s of an <enclosed clause>
	 or <decs module>, where
	 <serial clause> ::= <phrase> [<separator> <phrase>]*
	 <separator>::= semi | exit
	}
	BEGIN
		REF LABEL end of series := end OF answer;
		BOOL	discard level activated := FALSE, { in this series }
			first exit := TRUE; { in this series }

		start series
		( properties,
		  end of series,
		  discard level activated
		);

		ANSWER series answer =
			(value OF answer, end of series, type OF answer);

		WHILE	phrase_ (FALSE, series answer, FALSE);

			CASE	current imperative	IN
			(SEPARATOR s):
			BEGIN
				BOOL dont pull bit set =
					props OF s >= dont pull bit;
				IF	fn OF s = semi fn
				THEN	semi
					( (props OF s AND dybits) /= 2r0,
					  dont pull bit set
					);
					TRUE
				ELIF	fn OF s = exit fn
				THEN	"end OF answer ISNT NIL"
					ASSERT (end OF answer ISNT NIL);
					exit
					( dont pull bit set,
					  first exit,
					  series answer
					);
					first exit := FALSE;
					TRUE
				ELSE	end series
					( properties,
					  answer,
					  end of series,
					  discard level activated,
					  dont pull bit set,
					  NOT first exit
					);
					FALSE
				FI
			END,

			(TERMINATOR t):
			BEGIN
				end series
				( ( block OF properties,
				    dynamic result OF properties,
				    discarded dynamic result OF properties,
				    fn OF t + terminator offset
				  ),
				  answer,
				  end of series,
				  discard level activated, 
				  NOT props OF t >= dont pull bit,
		  		  NOT first exit
				);
				FALSE
			END
			OUT	{invalid imperative in <serial clause>}
				terminal error (656); 
				FALSE
			ESAC
		DO
			SKIP
		OD
	END;

	PROC	enquiry clause = (ANSWER answer) VOID:
	{
	 Processes the <enquiry clause> of a <choice clause> or <loop clause>,
	 where
	 <enquiry clause> ::= phrase [semi <phrase>]*
	 Enquiry clauses can be optimised if the clause is a 'simple' phrase,
	 ie contains no semi-colons, in this case the result is returned in
	 'answer' instead of being assigned to a temporary and the temporary
	 returned.
	}
	BEGIN
		BOOL simple := TRUE;
		WHILE	phrase_ (FALSE, answer, simple);
			CASE	current imperative	IN
			(SEPARATOR s):
				IF	fn OF s = semi fn
				THEN	semi
					( (props OF s AND dybits) /= 2r0,
					  props OF s >= dont pull bit
					);
					TRUE
				ELSE	"exit not permitted in <enquiry clause>"
					ASSERT fn OF s /= exit fn;
					FALSE
				FI
			OUT	FALSE
			ESAC
		DO
			simple := FALSE;
			SKIP
		OD
	END;

	PROC	phrase = (BOOL body, ANSWER answer, BOOL simple) VOID:
	{
	 Called by 'module', 'routine', 'serial clause' and 'enquiry clause'
	 to process their constituent phrases.

	 <phrase> ::= <primary> [<primary>]*
	 <primary> ::=
		load | oper | transiddec | labdec | formatx |
		<routine> | warn | <enclosed clause>
	 On exit 'current imperative' is a <separator> or <terminator>.
	}
	BEGIN
	REF VALUELIST value stack := NIL;

	PROC	enclosed clause =
	( STARTER starter,
	  BOOL body,
	  ANSWER answer,
	  REF VALUELIST new value
	) VOID:
	{
		Constructs the ANSWER for an <enclosed clause> and passes
		this to the appropriate routine for processing the body
		of the clause. The normal action is to add 'new value'
		to 'value stack', with 'value OF value stack' being referred
		to by the ANSWER. However, if the <enclosed clause> is the
		'body' of a module or routine, or its result is also the
		result of the surrounding series ('mode OF starter < 0'),
		then in certain circumstances (dependant on the particular
		'starter'), 'answer' can be passed on with consequent
		optimisation.

		<enclosed clause> ::=
			<closed clause> |
			<choice clause> |
			<collateral clause> |
			<loop clause> |
			<forall clause>
	}
	BEGIN

		PROC	closed clause =
		( STARTER starter,
		  BOOL body,
		  ANSWER answer
		) VOID:
		{
			<closed clause> ::= begin <serial clause> end
			N.B. a <serial clause> containing EXITs occurs only
			in a <closed clause>
		}
		BEGIN
			PROPERTIES properties =
			( ( props OF starter >= decbit ) AND NOT body,
			  dynamic (ABS result mode OF starter),
			  ( props OF starter AND dybits ) /= 2r0,
			  fn OF starter
			);
			ANSWER cc answer := answer;
			BOOL series contains exit = 
				props OF starter >= exit bit;
			IF	series contains exit
			THEN
				end OF cc answer := HEAP LABEL :=
				    ( new unique name, TRUE )
			FI;
			begin( props OF starter >= lab bit, body );
			serial clause( properties, cc answer );
			end
			( dynamic result OF properties,
			  series contains exit,
			  body,
			  end OF cc answer
			)
		END;

		PROC	choice clause =
		( STARTER starter,
		  BOOL body,
		  ANSWER answer
		) VOID:
		{	<choice clause> ::=
				if   <enquiry clause>
				then <serial clause>
				[else <serial clause>] fi |
				case <enquiry clause>
				in   <serial clause> [comma <serial clause>]*
				[out <serial clause>] esac |
				caseu <enquiry clause>
				in    <serial clause> [commau <serial clause>]*
				[outu <serial clause>] esacu
		}
		BEGIN

			UCHOICE uchoice;
			{ set by 'read uchoice imperative'
			  for 'inu' and 'commau'
			}

			PROC	read uchoice imperative = VOID:
			{
			  Called by 'inu' and 'commau' to read the next UCHOICE
			  imperative from stream into 'uchoice'.
			  N.B. LABDECs for the following series may preceed the
			  UCHOICE, and are dealt with here.
			}
			WHILE
				read;
				CASE	current imperative	IN
				(UCHOICE u):	(uchoice := u; FALSE),
				(LABDEC l):	(labdec (l); TRUE)
				OUT	{ UCHOICE expected after IN/COMMA }
					terminal error (668);
					FALSE
				ESAC
			DO	SKIP
			OD;

			PROC	iddec imperative = TRANSIDDEC:
			{
			  Returns the next (TRANSIDDEC) imperative from stream.
			}
			BEGIN	read;
				CASE	current imperative	IN
				(TRANSIDDEC iddec):	iddec
				OUT	{ TRANSIDDEC expected after UCHOICE }
					terminal error( 669 );	SKIP
				ESAC
			END;

			INT	result mode = ABS result mode OF starter;
			BOOL	discard level activated := FALSE;
			INT	enquiry type;
			VALUE	enquiry;
			REF [] BOOL case;
			REF LABEL end of choice clause := end OF answer;
			BOOL 	else part := FALSE,
				out part := FALSE;

			IF	fn OF starter = if fn
			THEN	enquiry := ( bool mode, default info, EMPTY );
				enquiry type := enquiry result

			ELIF	fn OF starter = case fn
			THEN	enquiry := ( int mode, default info, EMPTY );
				enquiry type := enquiry result

			ELSE	"fn OF starter = caseu fn" ASSERT fn OF starter = caseu fn;
				INT umode = ABS mode OF starter;
				enquiry := ( umode, default info, EMPTY );
				enquiry type := enquiry result
				{ N.B. need to force copy }
			FI;

			enquiry clause ((enquiry, NIL, enquiry type));

			ANSWER series answer =
			( value OF answer,
			  end of choice clause,
			  type OF answer         
			);
			PROPERTIES series properties;

			WHILE	CASE	current imperative	IN
				(SEPARATOR s):
				( CASE	fn OF s
				  IN
					{then}
					(
					  else part := param OF s = 2;
					  then( enquiry )
					),

					{in}
					(
					  out part := param OF s < 0;
					  case in( enquiry )
					),

					{inu}
					( 
					  out part := param OF s < 0;
					  read uchoice imperative;
					  REF VECTOR [] INT cons = constituents(mode OF enquiry);
					  case := LOC
					  [UPB cons]BOOL;
					  FORALL c IN case
					  DO c := FALSE OD;
					  inu
					  ( uchoice, 
					    enquiry,
					    case 
					  );
					  IF	props OF uchoice >= dec bit
					  THEN	ccdec
					  ( iddec imperative,
					    enquiry,
					    param OF uchoice
					  )
					  FI
					),                  

					{comma}
					comma( param OF s ),
                                        
					BEGIN	{commau}
						read uchoice imperative;
						commau
						( uchoice,
						  enquiry,
						  case
						);
						IF	props OF uchoice >= dec bit
						THEN	ccdec
						  	( iddec imperative,
							  enquiry,
							  param OF uchoice
							)
						FI
					END,

					{invalid separator in <choice clause>}
					{exit} terminal error (665 ),

					out,

					outu,

					else

			  	  OUT	{invalid separator in <choice clause>}
					terminal error (665)
			  	  ESAC;

			  	  series properties :=   
  			  	  ( props OF s >= decbit,
			    	    dynamic (ABS mode OF s),
			    	    (props OF s AND dybits) /= 2r0,
			    	    fn OF s + separator offset
			  	  );
			  	  TRUE
				),

				(TERMINATOR t):
				( IF fn OF t = esacu fn
			 	  THEN
					esacu( out part, answer )
			 	  ELIF fn OF t = esac fn
			 	  THEN
					esac( out part, answer )
			 	  ELSE { fn OF t = fi fn }
				  	fi( else part, answer )
			 	  FI;

			 	  FALSE
				)
				OUT	{illegal imperative in <choice clause>}
					terminal error (657 );
					FALSE
				ESAC
			DO
				serial clause (series properties, series answer)
			OD
		END;

		PROC	collateral clause =( STARTER starter, ANSWER answer)VOID:
		{
			<collateral clause> ::=
				coll begin <phrase> [coll comma <phrase>]*
		}
		BEGIN
			PROC collateral unit assignee = 
			(
			  CFRAGMENT temp, 
			  UNION( REF STRUCTFIELD, INT, VOID ) selector
			) CFRAGMENT :
			{
			Constructs a CFRAGMENT representing the element
			or field of the collateral temporary 'temp',
			which the result of the next collateral unit
			will be assigned to.
			} 
			CASE	selector  IN
			( REF STRUCTFIELD sf ):
				{ structure } temp +"."+ cfieldname( sf ),
			( INT i ):
				{ istruct } temp +".data["+ whole(i-1,0) +"]",
                        ( VOID ):  { void } ""
			OUT	"compiler:collateral clause - unknown selector"
				ASSERT FALSE; ""
			ESAC;

			INT result mode = ABS result mode OF starter;
			INT result type = mode type( result mode );
			BOOL structure = result type = struct;
			BOOL istruct = result type = istruct;
			BOOL void = result mode = void mode;

			"compiler: collateral clause result is neither "
			"struct nor istruct nor void"
			ASSERT ( structure OR istruct OR void );

			REF VECTOR [] STRUCTFIELD fields;
			IF	structure
			THEN	fields := struct fields (result mode)
			FI;

			REF VALUE collateral value = value OF answer;

			{ 'collateral temp' is the temporary to hold the
			  result of the row or structure display.
			  If not already declared, declare it.  Void 
			  collateral clause don't have or need a temporary. }

			CFRAGMENT collateral temp = 
		    		IF	mode OF collateral value = void mode
				THEN    ""
				ELSE    CASE extra OF collateral value IN
					( VOID ): extra OF collateral value :=
						declare c temporary
						( mode OF collateral value,
						  "collateral clause result"
						)
					OUT     SKIP
					ESAC;
					GETCFRAGMENT collateral value
				FI;
			
			{ value for first 'phrase' of collateral clause }
			VALUE phrase value := 
			( ABS mode OF starter,
			  default info,
			  collateral unit assignee
			  ( collateral temp,
			    ( structure | fields[1]
			    |: istruct  | 1
			    | { void } EMPTY
			    )
			  )
			);

			LABEL end of phrase := unset label;

			ANSWER phrase answer =
				(phrase value, end of phrase, type OF answer);

			FOR i
			WHILE	phrase (FALSE, phrase answer, FALSE);
				CASE	current imperative	IN
				(SEPARATOR s):
				BEGIN	"fn OF s = coll comma fn"
					ASSERT	fn OF s = coll comma fn;
					{ value for next 'phrase' of collateral}
					phrase value :=
					( ABS mode OF s,
					  default info,
			  		  collateral unit assignee
					  ( collateral temp,
					    ( structure | fields[param OF s]
					    |: istruct  | param OF s
					    | { void } EMPTY
					    )
					  )
					);
					TRUE
				END,

				(TERMINATOR t):
				BEGIN	"fn OF t = end coll fn"
					ASSERT	fn OF t = end coll fn;
					FALSE
				END
				OUT	{illegal imperative in <collateral clause>}
					terminal error (658 );
					FALSE
				ESAC
			DO
				SKIP
			OD
		END;

		PROC	loop body =
		( BOOL body,
		  ANSWER answer
		) VOID:
		{                          
			<loop body> ::= [while <enquiry clause>]
			do <serial clause> od
		}
		BEGIN
			LABEL end of series := unset label;
			read;
			CASE	current imperative	IN
			(SEPARATOR while or do):
			BEGIN	PROPERTIES loop properties =
				( (props OF while or do >= decbit) AND NOT body,
				  FALSE,
				  (props OF while or do AND dybits) /= 2r0,
				  fn OF while or do + separator offset
				);

				IF	fn OF while or do = while fn
				THEN	
					VALUE enquiry := ( boolmode, default info, EMPTY );
					while;  {CME not needed}
					enquiry clause
					      ((enquiry, NIL, enquiry result));
					while do( enquiry );

				CASE	current imperative	IN
				(SEPARATOR s):
				BEGIN	"fn OF s = do fn"
					ASSERT fn OF s = do fn;
					PROPERTIES series properties =
					( (props OF s >= decbit)
					  AND NOT block OF loop properties,
					  FALSE,
					  (props OF s AND dybits) /= 2r0,
					  fn OF s + separator offset
					);
					serial clause
					( series properties,
					  (value OF answer, end of series, void result)
					)
				END
				OUT	{invalid separator in <loop body>}
					terminal error (666)
				ESAC;

				while od

			ELSE	{fn OF while or do = do fn}
				serial clause
				( loop properties,
				  (value OF answer, end of series, void result)
				);
				od
			FI
		END
		OUT	{invalid imperative in <loop body>}
			terminal error (666)
		ESAC
		END;

		PROC	loop clause =
		( STARTER starter,
		  BOOL body,
		  ANSWER answer,
		  REF REF VALUELIST frobyt list
		) VOID:
		{
		 <loop clause> ::= [phrase] [phrase] [phrase] for [transiddec] <loop body>
		}
		BEGIN
			LABEL start of loop := unset label;
			REF LABEL end of loop := end OF answer;
			VALUE control := skip value,
				step  := skip value;
                        
			FORLOOP loop :=
			( control, step,
			  props OF starter >= for part bit,
			  props OF starter >= from part bit,
			  props OF starter >= by part bit,
			  props OF starter >= to part bit
			);

			IF	for part OF loop
			THEN	read;
				CASE current imperative	IN
				(TRANSIDDEC id):
				(	iddec (id, NIL);
		      			control := 
						(  mode OF ids [decno OF id],
						   default info,
						   (IDENTIFIER iden;
						    idno OF iden := decno OF id;
						    iden)
						)
				)
				OUT	{invalid imperative in <loop clause>}
					terminal error (666)                
				ESAC
			FI;

			for( loop, result mode OF starter, frobyt list );
			loop body( body, answer )
		END;

		PROC	forall clause =
		( STARTER starter,
		  BOOL body,
		  ANSWER answer,
		  REF REF VALUELIST forall list
		) VOID:
		{
		 <forall clause> ::= [phrase]* forall [transiddec]* <loop body>
		}
		BEGIN
			LABEL start of loop := unset label;
			REF LABEL end of loop := end OF answer;
			INT control count = result mode OF starter;
			VECTOR [control count] FORALLCONTROL controls;

			REF REF VALUELIST this forall list := forall list;
			
			FORALL control IN controls
			DO
				read;
				CASE	current imperative  IN
				(TRANSIDDEC id):
				BEGIN
					{
					We may change the mode of the forall control variable
					in iddec but need the mode OF value OF forall list (for this iddec)
					Therefore we have 'thisforalllist'.
					}

					iddec( id, this forall list );
					this forall list := rest OF this forall list;

					ident OF control :=
						(  mode OF ids [decno OF id],
						   default info,
						   (IDENTIFIER iden;
						    idno OF iden := decno OF id;
						    iden)
					 	)
				END
				OUT	{invalid imperative in <loop clause>}
					terminal error( 666 )
				ESAC
			OD;

			forall	 ( controls, forall list );                
			loop body( body, answer )
		END;
	
		{ enclosed clause( starter, body, answer, new value ): }

		LABEL end of clause := unset label;

		IF	fn OF starter = begin fn
		THEN	IF	(mode OF starter > 0) AND NOT body
			THEN	INT result mode = ABS result mode OF starter;
				INT type := no particular result;

				value stack := new value :=
				( ( result mode, default info, EMPTY ), value stack );

				closed clause
				( starter,
				  body,
				  ( value OF value stack,
				    end of clause,
				    type OF answer {CE is this the right type??}
				  )
				)
			ELSE	"no closed clause OPTBOOL results"
				ASSERT	type OF answer /= optbool result;
				closed clause
				( starter,
				  body,
				  ( value OF answer,
				    ( end OF answer IS NIL
				    | end of clause
				    | end OF answer
				    ),
				    ( props OF starter >= exit bit
				    | ABS type OF answer
				    | type OF answer
				    )
				  )
				)
			FI
		ELIF	fn OF starter = coll begin fn
		THEN	INT result mode = ABS result mode OF starter;
			BOOL new answer = ( mode OF starter > 0 );

			IF	new answer
			OR	(type OF answer = routine result)
			THEN	value stack := new value :=
				( ( result mode,
				    default info,
				    EMPTY
				  ),
				  value stack
				);
				collateral clause
				( starter,
				  ( value OF value stack,
				    NIL, no particular result)
		  		)              
			ELSE	{type OF answer = any old thing CME}       
				collateral clause
				( starter,
				  ( value OF answer, 
				    NIL, no particular result )
				)
			FI
		ELIF	fn OF starter = for fn
		OR	fn OF starter = forall fn
		THEN	REF VALUELIST value list := value stack;

			TO	result mode OF starter {number of values}
			DO	value stack := rest OF value stack
			OD;

			value stack := new value :=
			((void mode, default info, EMPTY), value stack);

			( fn OF starter = for fn
			| loop clause
			| forall clause
			) ( starter,
			    body,
			    ( value OF value stack, end of clause, void result),
			    value list
			  )

		ELIF	{fn OF starter = 'choice begin'}
			( mode OF starter > 0 ) AND NOT body
		THEN
			INT result mode = ABS result mode OF starter;

			value stack := new value :=
			( ( result mode, default info, EMPTY ), value stack);

			choice clause
			( starter,
			  body,
			  ( value OF value stack,
			    end of clause,
			    memory result
			  )
			)
		ELSE	"no choice clause OPTBOOL results"
			ASSERT type OF answer /= optbool result;
			choice clause
			( starter,
			  body,
			  ( value OF answer,
			    ( end OF answer IS NIL
			    | end of clause
			    | end OF answer
			    ),
			    ABS type OF answer
			  )
			)
		FI
	END;

	PROC	optbool expression = (INT warn) VOID:
	{
	 <optbool expression> ::= <phrase> WARN <phrase> OPTBOOL OPER
	}
	BEGIN
		REF VALUE operand = value OF value stack;
		BOOL orel = (warn = orel warn);
		optbool warning( orel, operand );
		{ reuse 'operand' for the result of the following phrase: }
		phrase
		( FALSE,
		  (operand, NIL, no particular result),
		  FALSE
		);
		optbool oper                        
	END;

	{ phrase (body, answer, simple): }

	BOOL simple enquiry := simple;
	WHILE	read;
		CASE current imperative	IN
		(PRIMARY p):
		BEGIN	CASE p	IN
			(LOAD l):
				value stack := LOC VALUELIST :=
				( load (l), value stack ),
			(OPER op):
				oper( op, value stack, LOC VALUELIST ),
			(TRANSIDDEC id):
				iddec( id, value stack ),

			(CODEX c):
			BEGIN
				REF VALUELIST	visible := nil valuelist;
				FOR i	TO number OF c
				DO	visible := LOC VALUELIST :=
					( value OF value stack, visible );
					value stack := rest OF value stack
				OD;
				TEMPORARY temp =
				  code insert( insert OF c,mode OF c,visible );
				( mode OF c /= void mode
				| value stack := LOC VALUELIST :=
				  ( ( mode OF c, default info, temp ), value stack )
				)
			END,
			(FORMATX format):
			BEGIN	{stack text and depth of collections:}
				value stack := LOC VALUELIST :=
				( load
				  ( STRINGDENOTATION
				    ( format mode, text OF format
				    )
				  ),
				  LOC VALUELIST :=
				  ( load
				    ( NUMERICDENOTATION
				      ( int mode, LENG(BIN w OF info OF format)
				      )
				    ),
				    value stack
				  )
			 	);
			 	{treat format as 'format fn' oper:}
				 oper
				 ( OPER
				   ( format fn,
				     format mode,
				     nocases OF info OF format
				   ),
				   value stack,
				   LOC VALUELIST
				 )
			END,

			(ROUTINE r):
			{
			!!! 'savedr' below is used to make a copy
			of 'r', which is corrupted by the actions
			of 'routine' and procedures it calls -
			more precisely, the return of procedures
			'start module' and 'phrase'.
			This VMS compiler bug should be investigated at 
			some point, the code below is merely a 
			circumvention !!!
			}
			BEGIN	
				ROUTINE savedr := r;
				routine (r);
				IF	props OF savedr >= valbit
				THEN	value stack := LOC VALUELIST :=
					( load (rdenno OF savedr), value stack )
				FI
			END,

			(WARN w):
				 IF	w OF w = orel warn
				 OR	w OF w = andth warn
				 THEN	optbool expression (w OF w)
				 FI,

			(LABDEC l):
				labdec (l),

			(UCHOICE u):
				{ unexpected UCHOICE in 'phrase' }
				terminal error (670 ),

			(CALLMODULE c):
				"PROC modules not supported" ASSERT FALSE

			ESAC;
			TRUE
		END,

		(SEPARATOR s):
		BEGIN	IF	value stack ISNT nil valuelist
			THEN	"rest OF value stack IS nil value list"
				ASSERT (rest OF value stack IS nil value list);
				IF	fn OF s = semi fn
				THEN	evaluate no result( value stack )
				ELIF	type OF answer = enquiry result
					ANDTH simple enquiry
				THEN	evaluate simple enquiry
						( value stack, answer )
				ELSE	evaluate result( value stack, answer )
				FI
			FI;
			FALSE
		END,

		(TERMINATOR):
		BEGIN	IF	value stack ISNT nil valuelist
			THEN	evaluate result (value stack, answer)
			FI;
			FALSE
		END,

		(STARTER s):
		BEGIN	enclosed clause (s, body, answer, LOC VALUELIST);
			simple enquiry := FALSE;
			TRUE
		END

		OUT	"invalid imperative in 'phrase'" ASSERT FALSE;
			FALSE
		ESAC
	DO
		SKIP
	OD

	END; {of 'phrase'}

	phrase_ := phrase;


	{ module: }

	REF LABEL end of module;
	REF VALUE result;

	lookahead; { now, to ensure initial statement map entry is output }

	IF	decs module
	THEN
		PROPERTIES properties = (FALSE, FALSE, TRUE, decs fn);

		start decs module( uname OF current module,module name);

		result := LOC VALUE := ( voidmode, default info, EMPTY );

		serial clause( properties,
				( result,end of module,void result));
                                                                
		end decs module( module name )
	ELIF
		CASE	next imperative	IN
		(TRANSIDDEC id):
		(	initial dummy dec (id);	 read;  lookahead;
			( next imperative
			| (ROUTINE r): name OF r = message( 59 {!anonymous} )
			| FALSE
			)
		),
		(ROUTINE r):
			name OF r = message( 59 {!anonymous} )
		OUT	FALSE
		ESAC
	THEN
		{proc module}
		read;
		ROUTINE routine =
		( current imperative
		| (ROUTINE r): r
		| "module: ROUTINE" ASSERT FALSE; SKIP
		);

		IF	mode type (mode OF routine) = procp
		THEN
			{ skip formal parameter generator routines }
			WHILE
				lookahead;
				CASE next imperative
				IN
				(ROUTINE r):
				(	"generator routine"
					ASSERT name OF r = "!generator";
					read; { from 'next imperative' }
					skip routine;
					TRUE
				)
				OUT	FALSE
				ESAC
			DO
				SKIP
			OD
		FI;

		start proc module
		( routine,
		  uname OF current module,
		  module name,
		  result
		);

		IF	dynamic( mode OF result )
		THEN	error (340 {no dynamic results of modules})
		FI;

		phrase
		( props OF routine >= ccbit,
		  (result, end of module, routine result),
		  FALSE
		);
		end module;

		{ check for 'cc module' compiled as 'proc module': }
		read; {void or call}
		IF	mode type (mode OF routine) = proc
		AND	mode OF result /= void mode
		THEN	read {void (result)}
		FI;
		read; {finish}
		IF	( current imperative
			| (TERMINATOR t): fn OF t /= finish fn
			| TRUE
			)
		THEN	terminal error (628 {cc module compiled as proc module})
		FI
	ELSE
		{cc module}
		start module( uname OF current module,module name);
		result := LOC VALUE := ( void mode, default info, EMPTY );
		phrase
		( FALSE,
		  ( result,
		    end of module,
		    void result
		  ),
		  FALSE
		);
		end module
	FI
END; {of 'module'}

{ translator: }

REF VECTOR [] CHAR module name = " " SCANTO name OF current modinfo;

BOOL decs module = type OF current modinfo = -1,
	context void = level OF l OF current modinfo = 0;

initialise( xsizes, current imperative, kept decnos );

IF	composition
THEN
	terminal error( 806 {composition not supported})
ELSE
	initialise unames;
	module (module name, decs module, context void)
FI

END

KEEP
	translator
FINISH

{
Local Variables:
mode:text
auto-fill-hook:nil
End:
}
