DECS  idtable  CONTEXT VOID  USE
*L    usefulops,
      centities, environment, incenviron, incid, incinstallation, incvalue,
      moduletracer:

configinfo A68CONFIG "$Id: idtable.a68,v 1.1.1.1 2001-05-07 10:16:10 sian Exp $";


COMMENT 
    ************************************************************************
    This Program is the property of the Secretary of State for Defence
    (United Kingdom) acting through the Defence Research Agency (DRA). Use,
    reproduction, production of amended versions and/or transfer of this
    Program is permitted provided that:

  (a)  this legend be preserved on any such reproduction and amended version,
  (b)  any amended version of this Program be clearly marked to show the
       nature of the amendment and of the name of the amending organisation,
  and
  (c)  any recipient  of such reproduction or amended version accept the
       conditions set out in this legend.

                         Crown Copyright, (c)   1993

                             All rights reserved.

    The Secretary of State for Defence (United Kingdom) acting through his
    Defence Research Agency (DRA) gives no warranty that any element of the
    Software is suitable for any purpose and he shall not be liable for any
    loss or damage including loss or damage resulting in injury or death
    howsoever caused which results from the use of the Software, or any
    developments adaptions modifications translations and enhancements
    thereof.

    The original authors may be contacted via email on ella@dra.hmg.gb or by
    writing to ELLA Office, DRA, St Andrews Road, Malvern, Worcs WR14 3PS, UK.
    ************************************************************************

25:08:94  33.001  ELLA  NewConFig Entered in new config system previous version
                                  number 2.10 
29:03:95  34.002  ELLA  Modcprght Change copyright header
??:??:??   ?.???  ????
COMMENT

{
$Log: idtable.a68,v $
Revision 1.1.1.1  2001-05-07 10:16:10  sian
Import of Ctrans v1.0.4

Revision 1.2  2000/08/23 16:33:20  sian
Ready for Debianising

Revision 1.1.1.1  1999/10/07 14:43:46  sian
Original Ctrans from ELLA

# Revision 34.2  1995/03/29  13:01:55  ella
# Change copyright header
#
# Revision 33.1  1994/08/25  12:43:11  snell
# Entered in new config system previous version number 2.10
#
Revision 2.10  1993/11/17  11:26:40  aap
Added 'id force use flag' to cope with kept declarations appearing on RHS of
kept identities.

Revision 2.9  1993/11/05  12:05:17  aap
DCT's OSIF changes merged in.
externs for imported declarations suppressed if not actually referenced.
spurious "result voided" warnings eliminated.

Revision 2.8  1993/09/15  15:33:48  aap
Prelude library modules in separate directory.
Fix for bug concerning bad stream output for libids.

Revision 2.7  1993/07/21  11:25:59  aap
Fix for "multiple GOTOs bug".

Revision 2.6  1993/05/18  14:07:06  aap
ANSI function protoypes.  No unique names on parameters.

Revision 2.5  1993/05/10  11:00:25  aap
Library lookup mechanism implemented, controlled by '-lib' and '-nolib' options.

Revision 2.4  1993/02/12  10:18:36  aap
Modes fix (Ctrans_2_4_modes) merged in.
Use of stdprel removed except for coutput.
stdprelsup is now redundant.

Revision 2.3  1993/01/21  15:54:58  aap
ALIEN extension; no header files generated

}


MODE   IDINFO = STRUCT
		( INT mode, 			 { Algol68 mode }
		  INT c variable type,		 { C type }
		  ENVIRON environ,
		  REF VECTOR [] CHAR name,	 { Algol68 name }
		  REF VECTOR [] CHAR c_name,     { C name, usually prefix_name }
		  UNAME prefix,			 { C unique prefix }
		  BITS  flags,			 { see below for values }
		  REF VECTOR [] CHAR definition, { for identities }
        REF VECTOR [] CHAR rhs         { for ALIENs }
		),
	RDINFO = STRUCT
		( INT mode,
		  INT result mode,		{ Algol68 mode of result }
		  INT declevel,			{ level of routine declaration }
		  ENVIRON environ,		{ of external id with smallest scope }
		  REF VECTOR [] CHAR name,
		  UNAME prefix,			{ global ? fn   : procvalue }
			fn prefix,		{ global ? null : fn        }
			env prefix,		{ global ? null : env type  }
		  BITS flags                                                
		),                                 
	LABELINFO = STRUCT
		( LABEL label,			{ contains jmp_buf prefix }
	       	  ENVIRON environ,
		  REF VECTOR [] CHAR name,	{ a68 name }
		  UNAME prefix,                 { c label unique prefix }
		  BITS flags,
                  INT alias                     { non-zero => label for which this label is alias }
		);

{ 
  ALIENs

  'alienidinfo' represents the C extern generated by loading XALIEN.  It is
  written to by 'load' (loads.a68) and read by 'opt identity' (identifiers.a68)

  An ALIEN string may consist of one or two parts separated by spaces 
  -  the name of the C extern
  -  a C "definition" of the external entity.
  The C definition, if present, is copied verbatim to the output C file. Typically
  it will be an #include of a standard header, but may be a #define or an extern
  declaration.  If no definition is present, a suitable extern declaration is generated.
  The ALIEN string is parsed by 'alien' (loads.a68) which sets 'name OF alienidinfo' to
  the first part, and 'alien definition' to the second part (or NIL if not present).
}

IDINFO	alienidinfo; { represents the C extern generated by loading XALIEN }
INT	alien idno = -1;

{ identifier tables }

REF [] IDINFO ids;             
REF [] RDINFO rds;
REF [] IDINFO library ids;
REF [] LABELINFO labels;

{ flag values for IDINFO }

BITS	id no flags	 = 16r0,
	id identity flag = 16r1,	{ id is from an xiddec		}
	id kept flag	 = 16r2,	{ id appears in current keeplist}
	id ccdec flag	 = 16r4,	{ id is a ccdec			}
	id forall flag	 = 16r8,	{ id is a forall control	}
	id for flag	 = 16r10,	{ id is a for control		}
	id formal flag	 = 16r20,	{ id is a formal parameter	}
	id optimised flag= 16r40,	{ iddec has been #defined	}
	id op flag	 = 16r80,	{ OP(mde)mde id[:]= (mde)mde: ...;}
	id gproc flag	 = 16r100,      { id is a brief global proc from
				 	  a used module or an ALIEN proc }
	id kept genproc flag = 16r200,  { id is a kept generator proc }
        id loaded flag   = 16r400,      { id is loaded (ie used) in current module }
        id force use flag = 16r800;     { possible implied usage of imported id in identity }

BITS	id preset flags	 = id kept flag OR id kept genproc flag;
	{ flags that are already set when 'newidinfo' called }

{ flag values for RDINFO }

BITS	rd no flags	   = 16r0,
	rd kept flag	   = 16r2,	{ id appears in current keeplist     } 
	rd non locals flag = 16r4,	{ routine uses non-global non-locals }
	rd global flag	   = 16r8,	{ routine is global - no proc value  }
	rd op flag	   = 16r10,	{ part of brief operator declaration }
        rd loaded flag     = 16r20;     { rd is loaded (ie used) in current module }
                                         
{ flag values for LABELINFO }                             

BITS	lab no flags		= 16r0,
	lab declared flag	= 16r1,
	lab buffer emitted flag	= 16r2;

PROC get_idinfo = (INT decno) REF IDINFO:
 IF decno <= max id no
 THEN ids[decno] 
 ELIF (decno >= min libid) ANDTH (decno <= max libid)
 THEN library ids[decno]
 ELSE "id info: out of range decno" ASSERT FALSE; SKIP
 FI;

PROC	debug message	= ( VECTOR [] CHAR m ) VOID:
{
 	For debugging only.
}
	IF	TRACELEVEL "identifiers" /= 0
	THEN	list( "IDTABLE: "+m )
	FI;

PROC	id name = ( INT id no ) CFRAGMENT:
{                                
	returns the ALGOL68 identifier corresponding to 'id no'
}
IF	id no = alien idno
THEN	name OF alien idinfo
ELIF	id no = no id no OR id no > min op id no
THEN	""
ELIF	id no <= max id no
THEN	name OF ids[ id no ]
ELIF	id no <= max rd no
THEN	name OF rds[ id no ]
ELIF	id no <= max libid
THEN	name OF library ids[ id no ]
ELSE	name OF labels [ id no - min lab ]
FI;           

OP AFTERBANG = ( REF VECTOR [] CHAR name ) VECTOR [] CHAR:
( 	INT upb = UPB name;
  	( upb>0 ANDTH name[1]="!"| ( upb>1 | name[2:] | "" ) | name )
);
			
PROC	rd select name = ( INT prefix, rdenno ) CFRAGMENT:
BEGIN
     	REF RDINFO rd = rds[rdenno];
	CASE prefix
	IN
		prefix OF rd,
		fn prefix OF rd,
		env prefix OF rd
	OUT
		"IDTABLE: rd select name: invalid prefix number"
		ASSERT FALSE; ""
	ESAC + "_" + 
		( flags OF rd >= rd op flag
		| ""
		| AFTERBANG name OF rd
		)
END;

PROC	label full name = ( INT labno ) CFRAGMENT:
{
	This gives the actual c label name not jmp_buf name
}
BEGIN	REF LABELINFO labinfo = labels[ labno ];
	prefix OF labinfo +"_"+ name OF labinfo
END;

PROC	label buffer name = ( INT labno ) CFRAGMENT:
{
	This gives the name of the buffer used for setjmp/longjmp.
}
BEGIN                                         
	REF LABELINFO labinfo = labels[ labno ];
	name OF label OF labinfo +"_"+ name OF labinfo
END;

PROC	label is set = ( INT labno ) BOOL:
	set OF label OF labels[ labno ];

PROC	label is declared = ( INT labno ) BOOL:
	lab declared flag <= flags OF labels[ labno ];

PROC	label environ = ( INT labno ) ENVIRON:
	environ OF labels[ labno ];

PROC	id full name = ( INT id no ) CFRAGMENT:
BEGIN
CO
	returns the C identifier corresponding to 'id no'
CO                                                       
	IF	id no = alien idno
	THEN	name OF alien idinfo
	ELIF	id no = no id no OR id no > min op id no
		{ a direct op code since others do not get into values }
	THEN	""

	ELIF	id no <= max id no
	THEN    REF IDINFO id = ids[id no];                      
		c_name OF id

	ELIF	id no <= max rd no
	THEN	rd select name( 1, id no )

	ELIF	id no <= max libid
	THEN    REF IDINFO id = library ids[id no];                      
		c_name OF id

	ELSE    { This gives the jmp_buf name }
		label buffer name( id no - min lab )
	FI
END;

PROC	rd fn name = ( INT rdenno ) CFRAGMENT:
	IF 	rdenno >= min rd no
	AND 	rdenno <= max rd no
	THEN    rd select name( 2 { fn prefix }, rdenno )
	ELSE    "IDTABLE: rd fn name: invalid rdenno" ASSERT FALSE; ""
	FI;

PROC	rd env name = ( INT rdenno ) CFRAGMENT:
	IF 	rdenno >= min rd no
	AND 	rdenno <= max rd no
	THEN    rd select name( 3 { env prefix }, rdenno )
	ELSE    "IDTABLE: rd fn name: invalid rdenno" ASSERT FALSE; ""
	FI;

PROC	standop sym = ( VECTOR [] CHAR id name ) BOOL:
{
	Returns true if id name is an Algol68 standard operator symbol.
}
IF	UPB id name <= 0
THEN	"IDTABLE: standop sym: null id name"
	ASSERT FALSE; FALSE
ELSE
    	char in string( idname[1], LOC INT, "%&+-*/:<=>?" )
FI;

PROC	initialise ids =
(	INT no_decnos, no_libinds, no_labels, no_rdennos,
	REF [] INT kept decnos
)	VOID:
BEGIN
	ids	    := HEAP [ global id no : no_decnos		      ] IDINFO;
	rds	    := HEAP [ min rd no    : min rd no-1 + no_rdennos ] RDINFO;
	library ids := HEAP [ min libid    : min libid-1 + no_libinds ] IDINFO;
	labels	    := HEAP [ 1            : no_labels		   ] LABELINFO;

	FORALL id IN ids DO flags OF id := id no flags OD;
	FORALL rd IN rds DO flags OF rd := rd no flags OD;
	FORALL id IN library ids DO flags OF id := id no flags OD;
	FORALL lab IN labels DO flags OF lab := lab no flags OD;

{	ids [global id no] and ids [min id no] are used to scope the module
	and global routines, respectively.
	N.B. these will be equal (and global id no = min id no) when '0 level'
	routines are introduced.    
}

	IF	kept decnos ISNT REF [] INT(NIL)
	THEN
		debug message( "kept identifiers are:");

		FORALL	decno IN kept decnos
		DO
			debug message( whole(decno,0) );
	        	IF	decno <= max id no
			THEN	flags OF ids[decno] := id kept flag
			ELIF	decno <= max rd no
			THEN	flags OF rds[decno] := rd kept flag
			ELIF	decno <= max libid
			THEN	flags OF library ids[decno] := id kept flag
			ELIF	decno <= max kept generator proc
			THEN
				decno -:= kept generator proc correction;
				flags OF ids[decno] := id kept flag OR
							id kept genproc flag
			ELSE	"IDTABLE: kept decno is a label" ASSERT FALSE
			FI                     
		OD
	FI;
                     
	environ OF ids [ global id no ] := ( 0, 0 );
	environ OF ids [    min id no ] := ( 0, 0 )  {CME no longer need both }
END;
                                         
PROC
(	REF VECTOR [] CHAR,
	UNAME, INT, INT, BOOL, BOOL, BOOL, BOOL, BOOL, REF VECTOR [] CHAR, REF VECTOR [] CHAR
)   	VOID	external dec;

PROC (INT) VOID external c dec;

SKIP

KEEP	IDINFO, RDINFO, LABELINFO, get_idinfo, AFTERBANG(REF VECTOR [] CHAR),
	alien idno, alien idinfo, external dec, external c dec,
	ids, rds, library ids, labels, label is set, label full name,
	initialise ids, id name, id full name, label buffer name,
	id no flags, id identity flag, id kept flag, id ccdec flag,
       	id forall flag, id for flag, id formal flag, id optimised flag,
	id op flag, id gproc flag, id kept genproc flag, id loaded flag, id force use flag,
	id preset flags,
	rd env name, rd fn name, rd op flag,
	rd no flags, rd kept flag, rd global flag, rd non locals flag, rd loaded flag,
	standop sym,
	label environ, lab no flags, lab declared flag, label is declared,
	lab buffer emitted flag
FINISH

{
Local Variables:
eval: (auto-fill-mode 0)
End:
}
