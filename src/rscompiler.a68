DECS rscompiler CONTEXT VOID
%4   USE  incid,  incinstallation :
*4 :

configinfo A68CONFIG "$Id: rscompiler.a68,v 1.1.1.1 2001-05-07 10:16:10 sian Exp $";


COMMENT 
    ************************************************************************
    This Program is the property of the Secretary of State for Defence
    (United Kingdom) acting through the Defence Research Agency (DRA). Use,
    reproduction, production of amended versions and/or transfer of this
    Program is permitted provided that:

  (a)  this legend be preserved on any such reproduction and amended version,
  (b)  any amended version of this Program be clearly marked to show the
       nature of the amendment and of the name of the amending organisation,
  and
  (c)  any recipient  of such reproduction or amended version accept the
       conditions set out in this legend.

                         Crown Copyright, (c)   1985

                             All rights reserved.

    The Secretary of State for Defence (United Kingdom) acting through his
    Defence Research Agency (DRA) gives no warranty that any element of the
    Software is suitable for any purpose and he shall not be liable for any
    loss or damage including loss or damage resulting in injury or death
    howsoever caused which results from the use of the Software, or any
    developments adaptions modifications translations and enhancements
    thereof.

    The original authors may be contacted via email on ella@dra.hmg.gb or by
    writing to ELLA Office, DRA, St Andrews Road, Malvern, Worcs WR14 3PS, UK.
    ************************************************************************

01:01:85  fix bug44; 'lastkept' in 'readmodes' initialised to 0, previously had 
          been used uninitialised.  Richard Wendland

01:03:86  for C translator; No longer uses assembler written 'analyser', back to
          slower more portable version.  Richard Wendland

29:04:88  "mode too complex" restriction removed.  DCT
          MODE garbage collector from FLEX added.  IFC
09:11:88  New version of IFC Mode garbage collector
06:06:89  Mode limit set to 1023 (max possible).  sidstack limit removed.
          Portable analyser reinstated.  Note that a MODE cheating BIOP
          (labeled 99) is used to optimise MODE comparison - renumber or
          remove to suit translator.  6-bit SID code (for ICL 1900 series)
          removed.  New provisional standard version.  DCT
16:02:90  "checkinsert" out of step with the analyser - spin with certain
          syntax errors.  DCT
05:02:91  Hacked for Ctrans - added back-end specific bits, changed OREL /
          ANDTH and set radix string to lower case (a/g).  DCT
25:02:91  Integer reading part had mixed case characters (radix).  DCT
06:08:91  VMS version 1B.R:  Limits on startrd &c doubled as for Ctrans.
          Ctrans and native VMS versions merged using *5 / *4.  DCT
          Changes log from Ctrans version:
14:02:90  1.2      Keywords added  p024
19:02:90  1.3      Radix characters revert to lower case.  p024
22:02:91  1.3.1.1  version used for last successful build (sun4). aap
25:02:91  1.4      miscellaneous corrections.  aap
26:02:91  1.5      circumvention for multiple label bug.  aap
09:10:92  2.0      Set up for use with CVS  aap
19:08:93           Doubled limits removed (did not work) - DECS Library  
                   operators allowed at the outer level of a DECS Module
                   (as implied).  DCT
23:08:93           Completed merge with Ctrans version.  DCT
25:08:94  33.001  ELLA  NewConFig Entered in new config system previous version
                                  number 2.3 
29:03:95  34.002  ELLA  Modcprght Change copyright header
??:??:??   ?.???  ????
COMMENT

{{{          The Portable ALGOL68 RS Compiler front end                      }}}


COMMENT messages
          43   212
 43 "["
 44 "] "
 45 "%struct ("
 46 "%proc "
 48 "!"
 49 "%then"
 50 "%in"
 51 "%else"
 52 "%out"
 53 ")"
 54 "%end"
 55 "%fi"
 56 "%esac"
 57 "program"
 58 "stdprelude"
 59 " anonymous"
 60 " generator"
 61 " assignment"
 62 " straight"
 63 " format"
 64 ""
 65 "re"
 66 "im"
 67 "collateral"
 68 "%skip"
 69 "%nil"
 70 "%goto"
 71 "%void"
 72 "%flex "
 73 "%bool"
 74 "%char"
 75 "%format"
 76 "%short %bits"
 77 "%bits"
 78 "%long %bits"
 79 "%long %long %bits"
 80 "%short %int"
 81 "%int"
 82 "%long %int"
 83 "%long %long %int"
 84 "%short %real"
 85 "%real"
 86 "%long %real"
 87 "%long %long %real"
 88 "%short %compl"
 89 "%compl"
 90 "%long %compl"
 91 "%long %long %compl"
 92 "%ref "
 93 "%union ("
 94 "%proc ("
 95 "%xtype"
 96 "%ytype"
 97 "%vector[ ] "
 98 "%straight "
 99 ", . . "
101 "compilation abandoned - too many errors"
102 "character not recognised"
103 "illegal radix"
104 "string goes over newline"
105 "illegal character in radix string"
106 "illegal symbol after r"
107 "missing strop symbol"
108 "decs module restriction - no procedure calls"
109 ".1 can be united to .2 in more than one way"
110 ".1 cannot be coerced to .2"
111 "collateral cannot be coerced to .1"
112 "end of file inside comment or pragmat"
113 "comment mismatch"
114 "end of file"
115 ".3 not recognised"
116 "brackets mismatch"
117 "%finish expected here"
118 ".3 expected here"
119 "decs module cannot access kept object whose mode contains %ref"
120 "decs module cannot access kept object whose mode contains %straight"
121 ".1 is not a legal mode"
122 "object of mode %straight cannot be assigned"
123 "%here .4 not declared or used twice"
124 "module .4 no longer has the same formals"
125 "module .4 has changed type"
126 "module .4 does not have this number of formals"
127 "module .4 does not fit here"
128 ".4 is not a formal of module"
129 ".4 not accessible here"
130 "decs module .4 in wrong context"
131 "identifier .4 not declared"
132 "%finish not expected here"
133 "compilation abandoned - too many syntax errors"
134 "unexpected symbol in mode"
135 "cannot have zero elements"
136 "unexpected symbol in format"
137 "replication not allowed here"
138 "unexpected symbol"
139 "bounds not needed in result mode"
140 "%bool, %int or %union required here, not .1"
141 "bounds required in generators"
142 "proc with parameters required here, not .1"
143 "too many parameters"
144 "too few parameters"
145 "illegal exponent"
146 "more than one version of .3"
147 "op .3 not declared for .1 and .2"
148 "op .3 not declared for .1"
149 "decs module restriction - library operators only"
150 "bounds not required here"
151 "lhs of assignment must be a reference"
152 "selector .4 not defined for struct"
153 ".1 cannot be selected"
154 ".4 is not a legal modename"
155 ".1 cannot be indexed"
156 "wrong number of indices"
157 "only one index needed"
158 "straight must be indexed by a single subscript"
159 "elements of in-parts must be units"
160 "module .4 not found"
161 "op .3 not declared for these modes"
162 ".3 already used at this level"
163 "bounds required in mode declaration"
164 "mode defined as (ref to) itself"
165 "mode .1 not declared"
166 "semicolon not needed here"
167 "priority must lie between 1 and 9"
168 "operator .3 has more than two operands"
169 "label not allowed after while"
170 "operator .3 must have operands"
171 ".1 not in .2"
172 "identifier .4 already declared"
173 "%heap not allowed here"
174 "no bounds required in identity declaration"
175 "bounds required in variable declaration"
176 "declaration not allowed after label"
177 "label .4 declared twice"
178 "label not allowed here"
179 "%forall not defined for .1"
180 "declaration must be followed by semicolon"
181 "bounds not allowed in parameter mode"
182 "equals required here"
183 ".3 already a mode at this level"
184 "label .4 not declared"
185 "needs: %here .4"
186 "undeclared .4 used .5 times"
187 "selector .4 defined twice"
188 "mixed bounds"
189 "already kept"
190 "objects of mode %xtype and %ytype cannot be assigned"
191 ".1 cannot be flexed"
192 "%int or %union required after %case"
193 "%bool required after %if"
194 "decs module restriction - label .4 is in outer level"
195 "istruct too large"
196 "built-in operators may not be kept"
197 "hole .4 already declared"
198 "formal .4 used twice"
199 ".4 is a decs module"
200 "elements of collaterals must be units"
201 "no opening comment symbol"
202 "nested mode declarations not allowed"
203 ".3 not expected here"
204 "priority already defined at this level"
205 "label .4 already used as identifier"
206 "too many modes"
207 "syntax stack overflow"
208 "too many brackets"
209 "mode too complicated"
210 "too many identifiers"
211 "too many routines"
212 "too many library identifiers"
COMMENT


COMMENT implementation dependent declarations COMMENT

*5 { Some of these objects are defined in external Modules }
*4 MODE ID = STRUCT 32 CHAR;

*4 INT maxid = 32;
*4 INT maxchar = 256;

*4 MODE YM = INT;
*4 MODE YS = INT;

*4 INT startrd = 1000, startlib = 2000, startkmp = 3000;
*5 INT startrd = min rdno - 1, startlib = min libid - 1,
*5     startkmp = kept generator proc correction;

*4 INT upbofmodes = 1023;
CO upbofmodes must be less than 952 CO   { - origin ???  DCT 25:05:89 }


*4 INT maxistruct = 100000;

   CHAR dchar = ".", pchar = "+", nchar = "-";
CO These characters represent the decimal point, positive exponent and
   negative exponent of a real denotation in stream language.  They may
   be altered to any non-digit character
CO

INT linesize = 160;

INT bolddiff := -32;    { = ABS(A) - ABS(a) }
CO The initial value should be the difference between the ABS values
   of uppercase "a" and lowercase "a"
CO

COMMENT  end of implementation dependent declarations  COMMENT

MODE AMODELIST,
     AMODE = STRUCT (INT mode, modeproc, REF AMODELIST el),
     AMODELIST = STRUCT (REF AMODE am, REF AMODELIST rest);


MODE MODELIST = STRUCT (INT mode, REF MODELIST rest),
     PRIMITIVE = INT,
     PRC = STRUCT (INT deproc),
     UNN = STRUCT (INT rdenno, REF MODELIST modelist),
     PROCP = STRUCT (INT deproc, REF MODELIST pars),
     SELIST = STRUCT (INT mode, fieldno, ID name, REF SELIST rest),
     STRCT = STRUCT (INT rdenno, deflex, REF SELIST sels),
     ISTRUCT = STRUCT (INT rdenno, imode, length, deflex),
     VCTOR = STRUCT (INT rdenno, vecmode, deflex),
     ARRAY = STRUCT (INT rdenno, mode, nods, deflex),
     STENLIST = STRUCT (INT mode, rdenno, REF STENLIST rest),
     STEN = STRUCT (INT mode, REF STENLIST stenlist),
     SAMEAS = STRUCT (INT mode),
     MDE = UNION (PRIMITIVE, REF UNN, REF PROCP, REF STRCT,
                  REF ISTRUCT, REF PRC,  REF VCTOR,
                  REF ARRAY, REF STEN, REF AMODE, SAMEAS
                 );

MODE IDDEC = STRUCT (ID name, INT decno, level, mode, scope,
                     REF IDDEC rest
                    ),
     RDEN = STRUCT (ID name, BITS props,
                    INT mode, rdenno, maxname, level,
                    REF RDEN rest
                   ),
     LABEL = STRUCT (ID name, INT labno, status,
                     REF LABEL rest
                    );

MODE INTPAIR = STRUCT (INT i, j),
     INTTRIPLE = STRUCT (INT i, j, k),
     CAT = STRUCT (ID n, f, INT level);


MODE XGEN = STRUCT (INT mode, BOOL loc),
     XCODE = STRUCT (INT mode, nopars),
     XNUMBER = STRUCT (INT mode, REF VECTOR[]CHAR nu),
     XALIEN = STRUCT (INT almode),
     XCHARS = STRUCT (INT nochars, base, REF VECTOR[]CHAR chars),
     XSTRING = STRUCT (INT strmode),
     XFORMAT = STRUCT (INT nochars, nocases, w),
     XLOAD = UNION (BOOL, INT, REF LABEL, STRUCT (INT nse),
                    XGEN, XSTRING, XFORMAT,
                    XNUMBER, XALIEN, XCODE
                   ),
     XIDDEC = STRUCT (INT type, REF IDDEC iddec),
     XLABDEC = STRUCT (REF LABEL lab, BOOL notsetting),
     XROUTINE = REF RDEN,
     XDEC = UNION (XIDDEC, XLABDEC),
     XEDIT = STRUCT (BOOL up),
     XOPER = STRUCT (INT fn, m, param),
     XWARN = STRUCT (INT w),
     XCONTROL = STRUCT (INT fn, m, BITS props, INT param),
     XPRAG = STRUCT (BOOL all, REF VECTOR[]CHAR pr),
     XCHARPOS = STRUCT (INT charpos),
     XSIZES = STRUCT (INT norden, nomodes, nolabs,
                      nodecnos, nomodules, nolibinds
                     );

CO modules CO

MODE XMODINFO = STRUCT (ID name, CAT l, g, INT type),
     YMODINFO = STRUCT (XMODINFO xmi, YM ym),
     XSPEC = STRUCT (ID f, INT no, nl, ng,
                     UNION (REF VECTOR[]CHAR, REF VECTOR[]CAT) u
                    ),
     YSPEC = STRUCT (XSPEC xs, YS ys),
     XOPENMODULE = STRUCT (ID name, INT maxlevel, nof, moduleno),
     XCLOSEMODULE = STRUCT (INT moduleno, nof),
     XTMODULE = STRUCT (INT type, moduleno, ID name, YM ym),
     XTDEC = STRUCT (BOOL bu, INT level, REF IDDEC id),
     XCALLMODULE = STRUCT (INTPAIR body,
                           REF VECTOR[]INTTRIPLE kset,
                           REF VECTOR[]INT keeps,
                           INT last
                          ),
     XCLOSURE = STRUCT (INT body,
                        REF VECTOR[]INT actuals, INT moduleno
                       ),
     XINTERF = STRUCT (ID name, YM ym, ID formal, YS ys,
                       INT level, ownlevel
                      ),
     XKEEPS = REF VECTOR[]INT,
     XTDTYPE = STRUCT (INT moduleno, type),
     XBUTYPE = STRUCT (REF VECTOR[]INT decnos, modes),
     XCOMPTYPE = STRUCT (INT moduleno, type, maxmodule);


MODE OUTPUT = UNION (XEDIT, XLOAD, XDEC, XOPER, XCHARPOS,
                     XWARN,  XCONTROL, XSIZES, REF VECTOR[]MDE,
                     XPRAG, XMODINFO, XSPEC, XOPENMODULE,
                     XCLOSEMODULE, XTMODULE, XTDEC, XCALLMODULE,
                     XCLOSURE, XINTERF, XKEEPS, XTDTYPE,
                     XBUTYPE, XCOMPTYPE, XROUTINE, XCHARS
                    );


XEDIT up1, down1;
up OF up1 := TRUE;
up OF down1 := FALSE;
OUTPUT up := up1, down := down1;

INT vacmode = 1,
    skipmode = 2,
    nilmode = 3,
    gotomode = 4,
    voidmode = 5,
    faultmode = 6,
    bool = 7,
    char = 8,
    formatmode = 9,
    bits = 11,
    int = 15,
    real = 19,
    vecchar = 26,
    arraychar = 27,
    collatmode = 28,
    xtype = 29,
    ytype = 30;

CO bits only used in XROUTINE CO
BITS ccbit = BIN 2,
     operatorbit = BIN 4,
     valbit = BIN 8,
     holebit = BIN 16,
     globscopebit = BIN 32;

CO bits used in XCONTROL - cannot use 1 (downbit) or 2 (assmntbit) CO
BITS priobit = BIN 4,
     exitbit = BIN 8,
     semibit = BIN 16,
     heapbit = BIN 32,
     decbit = BIN 64,
     vardecbit = BIN 128,
     compgenbit = BIN 256,
     elifousebit = BIN 512,
     labbit = BIN 1024,
     dontpullbit = BIN 2048,
     dyprocbit = BIN 4096,
     dyvardecbit = BIN 8192,
     dydecbit = BIN 16384,
     genprocbit = BIN 32768,
     locgenbit = BIN 65536,
     locdydecbit = BIN 131072;

CO oper CO
INT xstatgrab = 1,
    xparampack = 2,
    xselect = 3,
    xcopy = 4,
    xtrim = 5,
    xsimpleindex = 6,
    xtrimindex = 7,
    xdyngrab = 8,
    xbdpack = 9,
    xdyop = 10,
    xmonop = 11,
    xstraight = 12,
    xprestraight = 13,
    xstrindex = 14,
    xassign = 15,
    xdefaultbd = 16;

CO control CO
INT xif = 1,
    xcase = 2,
    xcaseu = 3,
    xbegin = 4,
    xthen = 5,
    xin = 6,
    xinu = 7,
    xcomma = 8,
    xcommau = 9,
    xexit = 10,
    xout = 11,
    xoutu = 12,
    xelse = 13,
    xfi = 14,
    xesac = 15,
    xesacu = 16,
    xend = 17,
    xcoll = 18,
    xcollcomma = 19,
    xfor = 20,
    xwhile = 21,
    xendcoll = 22,
    xforall = 23,
    xod = 24,
    xsemi = 25,
    xroutinend = 27,
    xuchoice = 28,
    xdo = 29,
    xfinish = 30;

CO coercions CO
INT xderef = 17,
    xcall = 18,
    xvoid = 19,
    xniltom = 20,
    xgotoproc = 21,
    xgotom = 22,
    xwrc = 23,
    xwir = 24,
    xarrarr = 26,
    xvecarr = 27,
    xisvec = 28,
    xis = 29,
    xunite = 30,
    xuniteu = 31,
    xisarr = 32,
    xskiptom = 33,
    xvec = 34,
    xarr = 35,
    xdeunite = 36,
    xwbvb = 37,
    xvac = 38,
    xytypetom = 39,
    xmtoxtype = 40;

CO types of decs CO
INT xiddec = 1,
    xvardec = 2,
    xfdec = 3,
    xfordec = 4,
    xivardec = 5,
    xccdec = 6,
    xforalldec = 7,
    xdummydec = 8;

CO warnings CO

XWARN xwass, xwandth, xworel, xwindex, xwplusabetc, xwforall, xwloop;
w OF xwass := 1;
w OF xwandth := 2;
w OF xworel := 3;
w OF xwindex := 4;
w OF xwplusabetc := 5;
w OF xwforall := 6;
w OF xwloop := 7;

STRUCT (INT nse) skip, nil, empty;
nse OF skip := skipmode;
nse OF nil := nilmode;
nse OF empty := 1;

VECTOR[0]CHAR emptystring;


MODE INST = STRUCT (INT lmode, rmode, ans, level, decno, scope,
                    REF INST rest
                   ),
     OPER = STRUCT (INT prio, REF INST i),
     INDIC = STRUCT (ID name, INT level, scope,
                     UNION (REF OPER, REF AMODE, INT) u,
                     REF INDIC rest
                    );

MODE CONCHECK = STRUCT (CAT c, INT scope, REF CONCHECK rest),
     CONTEXHT = STRUCT (CAT l, g, REF CONTEXHT rest),
     PROXYL = STRUCT (ID name, INT no, REF PROXYL rest),
     CLOSURE,
     SUBLIST = STRUCT (ID proxy, INT level,
                       UNION (REF CLOSURE, REF PROXYL) a,
                       REF SUBLIST rest
                      ),
     CLOSURE = STRUCT (ID name, REF SUBLIST s),
     ONEOP = STRUCT (REF INDIC n, REF INST i),
     KEEPITEM = UNION (REF IDDEC, REF INDIC, ONEOP),
     KEEPLIST = STRUCT (KEEPITEM u, REF KEEPLIST rest),
     KMODELIST = STRUCT (INT m, km, REF KMODELIST rest);

REF CONTEXHT nilcon = NIL;
REF CONCHECK nilconchk = NIL;
REF PROXYL nilprl = NIL;
REF SUBLIST nilsubl = NIL;
REF KEEPLIST nilkl = NIL;
REF KMODELIST nilkml = NIL;

MODE VALUE,
     VLIST = STRUCT (VALUE v, INT type, REF VLIST rest),
     VALUE = STRUCT (BITS props, INT mode, REF VLIST vlist,
                     REF LABEL labs
                    );

MODE RANGEINFO = STRUCT (REF VECTOR[]REF IDDEC ids,
                         REF VECTOR[]REF INDIC indics,
                         REF LABEL labs, REF RDEN rd,
                         INT lastid,
                         BITS props, dybits,
                         INT level
                        );

MODE OPSTACK = STRUCT (ID name, INT hash, REF INST i, BOOL diadic,
                       INT biop, BOOL lib, REF OPSTACK rest
                      );

MODE SELSTACK = STRUCT (ID name, REF SELSTACK rest);

MODE INDSTACK = STRUCT (INT noofinds, nooftrims, BOOL vector,
                        BITS bits, REF INDSTACK rest
                       );

MODE RIDIDLIST = STRUCT (REF REF IDDEC rid, REF IDDEC id,
                         REF RIDIDLIST rest
                        );

MODE LKIDS = STRUCT (ID id, INT idsize, idhash, REF LKIDS rest);

INT refmark = 1024;
BITS decsmask = BIN 1023;  CO refmark - 1 CO

BITS z = BIN 0,
     z1 = BIN 1;

REF MODELIST nilml = NIL;
REF AMODELIST nilaml = NIL;
REF AMODE nilam = NIL;
REF SELIST nilsel = NIL;
REF INDIC nilind = NIL;
REF IDDEC nilid = NIL;
REF VLIST nilvl = NIL;
REF INST nilinst = NIL;
REF STEN nilsten = NIL;
REF LABEL nillab = NIL;
REF LKIDS nillkids = NIL;
REF INT nilint = NIL;
REF BOOL nilbool = NIL;

BITS downbit = BIN 1,
     assmntbit = BIN 2,
     decprio = decbit OR priobit,
     labsemi = labbit OR semibit,
     alldecbits = decbit OR vardecbit,
     notdontpull = NOT dontpullbit;

XOPER opervoid = (xvoid, voidmode, 0);
XCONTROL controlsemi = (xsemi, 0, compgenbit, 0);

REF VLIST freevl := NIL;

CO ********************************************************************** CO

PROC compile = (PROC (REF VECTOR[]CHAR, REF INT) BOOL input,
                PROC (OUTPUT, INT) VOID output,
                PROC (VECTOR[]CHAR, INT) VOID flt,
                PROC (INT) REF VECTOR[]CHAR message,
                PROC (ID, INT, BOOL) YMODINFO givemoduledetails,
                PROC (ID, ID, YM) YSPEC givespec,
                PROC (REF VECTOR[]CHAR, BOOL) INT lookup,
                REF[]STRUCT (INT type, value) charset
               ) BOOL:
BEGIN

{{{
PROC (STR) VOID  lib_output = ALIEN "LIB$PUT_OUTPUT";
RCH  ch = make_channel( HEAP VECTOR [81] CHAR,
                        (STR s) VOID:  lib_output(s[: UPB s - 1]) { remove \n }
                      );
}}}

CO Objects used inside primread are given first, so that their
     displacements may be easily calculated
CO

    BOOL isint := TRUE;
    INT bold = 6;
    VECTOR[linesize + 1]CHAR textbuff, globfbuff;
    INT tind := 0, textend := 0, find;
    ID compsymb, ident;
    INT compsize, comphash, idsize, idhash := 1;
    VECTOR[linesize]CHAR string, str;
    INT stringsize := 1, noofchars, stringbase, iv;
    INT supflts := 0;

    PROC idmess = (INT m) ID:
    BEGIN VECTOR[]CHAR rc = message(m);
          ID id;
          FOR i TO maxid
          DO id[i] := IF   i > UPB rc
                      THEN " "
                      ELSE rc[i]
                      FI
          OD;
          id
    END;

    ID spaces = idmess(64),
       re = idmess(65),
       im = idmess(66),
       identformat = idmess(63);

    INT typechar1;
    REF CHAR string1 = string[1];

    VECTOR[upbofmodes]MDE modes;
    freevl := NIL;

    RANGEINFO globinfo := (LOC VECTOR[64]REF IDDEC,
                           LOC VECTOR[64]REF INDIC, NIL, NIL,
                           3, z, z, 0
                          );
    FOR i TO 64
    DO (ids OF globinfo)[i] := NIL;
       (indics OF globinfo)[i] := NIL
    OD;

    SELIST scx1, scx2, cx1, cx2, lcx1, lcx2, llcx1, llcx2;
    STRCT st1, st2, st3, st4;
    VCTOR vecchar1 := (2, char, 0);
    ARRAY arraychar1 := (2, char, 1, 0);
    MODELIST boolnil := (bool, NIL);

    st1 := (1, 0, scx1 := (18, 1, re, scx2 := (18, 2, im, NIL)));
    st2 := (1, 0, cx1 := (19, 1, re, cx2 := (19, 2, im, NIL)));
    st3 := (1, 0, lcx1 := (20, 1, re, lcx2 := (20, 2, im, NIL)));
    st4 := (1, 0, llcx1 := (21, 1, re, llcx2 := (21, 2, im, NIL)));

    VECTOR[]MDE initmodes = (1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 11, 11, 11,
                             15, 15, 15, 15, 19, 19, 19, 19,
                             st1, st2, st3, st4, vecchar1, arraychar1,
                             28, xtype, ytype
                            );

    INT formatunion := 0, formatproc := 0;

    REF RANGEINFO globcurrent;
    VALUE enqv;
    INT modedecdepth := 0;
    REF AMODELIST untreated := NIL;
    REF IDDEC ri;
    INT lastmode := UPB initmodes;
    modes[ : lastmode] := initmodes;
    INT newmode1 = lastmode + 1;
    INT nolongs := 0, globccmode;
    ID nullid  = idmess(59);  CO anonymous CO
    INT lastrd := startrd, labno := 1, rdmode, outlevel := 1, maxident := 0;
    XMODINFO xm;

    REF PROXYL prl := NIL, tempprl;
    REF CLOSURE close := NIL;
    REF KEEPLIST kl := NIL;
    REF REF KEEPLIST rkl := kl;
    REF SUBLIST substack:= NIL, sublist:= NIL, tsubst:= NIL, testsubst:= NIL;
    INT substlevel := 0;
    INT moduleno, modulelevel := 0, nextmodule := 0;
    INT nextlibno := startlib, lastkept;
    BOOL burestrict := FALSE;

    VECTOR[64]REF IDDEC libids;
    VECTOR[64]REF INDIC libinds;

    FOR i TO 64
    DO libids[i] := NIL;
       libinds[i] := NIL
    OD;

    REF CONCHECK concheck := NIL;
    type OF xm := 0;

    OP /= = (REF CAT l, r)BOOL:
    n OF l /= n OF r OREL f OF l /= f OF r;

    BOOL lastidchanged;

    BOOL incom := FALSE;

    INT noofstrings, oldtind;
    REF VECTOR[]CHAR textbuff1 = textbuff[ : linesize];

    PROC (INT) VOID abort1;

    VECTOR[64]INT brackets;
    INT brind := 1;
    INT wrongord := 0, wrongcrd := 0, wronglevel;

    INT rccrd = 54,
        rccomment = 60,
        rcmatchcom = 67,
        rcnewline = 80,
        rcident = 82,
        rcintexp = 83,
        rccolon = 84,
        rcpragmat = 90;

    INT illegaltok = 100,
        colontok = 110,
        faultindtok = 114,
        bangtok = 117,
        stringtok = 118,
        ordtok = 124,
        crdtok = 125,
        labeltok = 127,
        identtok = 132,
        intdentok = 146,
        otherindtok = 156,
        otheroptok = 176,
        bitsdentok = 177,
        pointtok = 130,
        powertentok = 175,
        modenametok = 158,
        colonhtok = 173;
    INT biplus = 200,
        biminus = 201,
        biequals = 210,
        monadic = 236,
        diadiconly = 204,
        recoversymbol = 86,
        frecoversymbol = 87,
        calllookup = 99;

    ID id1;

    INT strsize, strbase;
    REF AMODE decmode;
    REF INDIC cindic;
    REF INST cinst;
    INT cbiop;
    BOOL  clibop;

    INT next := rcnewline, bangtype;
    INT look := 2;
    CO look = 0  -  do not look in library modules
       look = 1  -  look in existing library modules only
       look = 2  -  look inside further library modules if necessary
    CO
    INT decreader = 1,
        ucreader = 2,
        screader = 3,
        formatreader = 4,
        startreader = 5;
    INT recoverdepth := 0, nscreader := startreader;

    REF LKIDS lkids := NIL;
    REF REF LKIDS lkend := lkids;
    INT lkinserts := -1, lkmodeins, lktype;
    AMODE lkscam;

    INT noflts := -1;
    INT fltgap = 2;

    BOOL fulldiags := FALSE, inprogram := FALSE;

    STRUCT 13 INT insertsn := (11, 32, 22, 14, 24, 28, 10, 61, 46,
                               13, 56, 27, 79
                              );

    STRUCT 17 INT ignorablen := (10, 12, 13, 16, 17, 23, 30, 54, 56,
                                 63, 73, 74, 75, 76, 78, 79, 0
                                );

    STRUCT 24 INT nonducstart := (10, 11, 16, 17, 23, 25, 28, 45,
                                  54, 56, 61, 63, 68, 69, 73, 74,
                                  75, 76, 79, 80, 81, 82, 83, 92
                                 );

    STRUCT 3 INT insertsf := (42, 28, 56);

    STRUCT 4 INT ignorablef := (28, 35, 39, 49);

    STRUCT 15 INT nonpicstart := (0, 25, 28, 35, 39, 40, 43, 45, 47,
                                  48, 50, 51, 52, 53, 60
                                 );

CO ********************************************************************** CO

COMMENT This section of the compiler contains
          (1)  VECTOR[]CHAR sidcode
          (2)  PROC analyser  -  this may be rewritten in code
          (3)  PROC checkinsert
COMMENT

VECTOR[]CHAR sidcode = 16r"0 1 c3 dc 40 4b 71 5b 8d 50 0 7 80 20 51 5f "
16r"0 c 80 a 0 42 40 a9 80 d 49 bb 0 b 0 5b a0 4a 87 4f 51 95 0 6 80 20 51 "
16r"ab 0 5b a0 4a 80 47 46 af 80 50 4e 31 80 50 4d c1 80 50 4e 89 80 50 40 "
16r"99 80 50 4e 5f a0 50 83 57 40 59 20 b 80 56 40 a9 0 27 20 25 c0 db 40 "
16r"5f 71 53 c0 db 40 67 4f 3 20 5 e1 da c0 d9 40 6f 6e ed e1 d8 c0 d7 60 "
16r"75 c6 2c 0 7 0 a 80 2c 40 85 20 3 80 1d 20 c 80 18 40 8d 0 b a0 19 c0 "
16r"d6 0 12 0 11 40 99 0 15 20 3 c0 d6 40 9f 6d f c0 d6 40 a9 0 27 47 e9 20 "
16r"4a c0 d6 40 b1 40 bb 6c ff e1 d5 c0 1b 0 49 80 1b 60 b1 c4 d4 0 40 0 5c "
16r"60 cb c0 d3 0 2a 0 48 6c 43 c6 18 41 c5 41 d7 45 81 48 d7 20 9 c9 12 0 "
16r"3c 46 41 0 3d 0 34 41 d7 45 81 48 d7 20 9 c8 d2 0 35 80 d2 0 34 41 d7 "
16r"45 81 48 d7 20 9 c9 d1 0 44 46 55 0 42 0 34 41 d7 45 81 48 d7 20 9 cb "
16r"3e 0 33 0 30 80 3e 46 8d 0 32 46 41 41 d7 45 81 48 d7 20 9 c8 d0 0 47 "
16r"80 d0 45 ad 0 48 45 81 48 d7 20 9 c8 3c 0 e 46 a3 0 3 41 d7 45 81 48 d7 "
16r"20 9 c3 cf 0 5 6a a1 c4 ce 0 d 49 9f 20 9 82 5b 6c 23 84 5a 42 b 44 a5 "
16r"20 9 87 59 0 38 0 34 41 d7 45 81 48 d7 20 9 85 4e 0 2b 0 5 47 f7 6c 33 "
16r"86 47 0 e 0 59 49 fd 0 3 20 9 84 39 0 5 47 f7 6c 33 83 21 4a 45 20 9 85 "
16r"20 48 f 45 81 48 d7 20 9 84 1a 0 2c 80 20 20 9 87 16 0 37 0 34 41 d7 45 "
16r"81 48 d7 20 9 87 15 0 36 0 34 41 d7 45 81 48 d7 20 9 80 f 80 33 0 2c 80 "
16r"20 20 9 80 18 61 c9 c3 d6 40 8d a0 19 c0 19 0 45 0 34 a0 19 e1 cd c7 18 "
16r"0 2d 80 18 41 f5 80 19 0 2f 61 d7 c0 3b 0 57 80 3b 4a 5b 0 58 80 3d 61 "
16r"d7 c0 d4 41 fd 0 2e 6a 55 c0 d4 0 5c 42 5 64 a5 e1 cc 80 5a 62 b c0 cf "
16r"0 5 62 11 c3 cb 42 91 62 a1 c7 ca 0 1d 42 b5 0 2e 0 34 0 7 62 c1 c7 c9 "
16r"0 20 80 c9 0 2e 0 34 0 7 62 c1 c6 c8 0 f 42 db 0 34 0 7 62 c1 c6 3a 0 "
16r"2d 80 3a 0 34 0 7 62 c1 87 45 43 59 0 22 0 2e 0 34 0 7 62 c1 82 2c 64 "
16r"91 85 2b 44 1d 0 34 0 7 62 c1 89 2a 80 18 44 b 80 19 0 14 0 2e 0 34 0 "
16r"7 62 c1 87 29 43 59 0 12 0 2e 0 34 0 7 62 c1 80 1f 44 55 0 34 0 7 62 c1 "
16r"82 48 20 1e 80 37 62 99 c2 c7 20 1c 80 37 20 1b c6 ca 42 b5 0 2e 0 34 "
16r"0 7 62 c1 c0 d1 0 34 0 8 a0 d1 c3 e 0 21 a0 e c0 c6 0 1f a0 c6 80 20 0 "
16r"4 62 c7 c3 c5 0 3 a0 c5 80 1c 62 d1 c2 20 62 c1 c0 c4 0 9 a0 c4 88 40 "
16r"80 3b 42 fb 0 2f 80 3d 43 11 0 b 20 2b 80 3b 44 63 80 3d 0 2f 0 5 43 11 "
16r"0 6 20 2b c6 d4 0 23 0 2a 43 b 0 29 20 25 c0 3d 20 24 c0 d4 41 fd 20 b "
16r"c3 c3 43 2b 20 2e c3 c8 0 f 62 db c3 3a 0 2d a0 3a 82 2b 64 1d 80 1f 64 "
16r"55 c3 c2 43 51 62 b5 c3 c9 0 20 a0 c9 83 45 43 59 20 22 82 2c 63 df 85 "
16r"2a 80 18 44 b 80 19 20 14 80 29 43 59 20 12 c2 cb 62 91 c0 ca 20 1d c2 "
16r"c3 63 2b c3 c8 0 f 63 71 c3 3a 0 8 a0 3a 82 2b 63 9d 80 1f 63 d1 85 40 "
16r"80 3b 80 3d 43 59 20 b 80 3b 0 26 43 89 80 3d 0 5 43 59 20 6 e1 3d 83 "
16r"1c 0 27 63 89 80 a 63 95 e1 3d 80 1c 0 27 63 89 c5 2e 0 9 80 2e 43 59 "
16r"20 a 80 18 43 af 80 19 20 7 c0 cf 43 59 63 b5 80 20 63 b9 c2 19 20 e c0 "
16r"1c 0 c 80 1c 63 c5 c3 20 43 b5 20 d c0 cf 43 af 20 d c3 c8 0 10 63 71 "
16r"c0 3a 0 8 0 11 a0 3a c3 c1 43 f1 20 13 80 18 43 f9 80 19 0 1a 43 f1 20 "
16r"15 c2 cf 63 59 80 21 20 16 c0 cf 43 59 0 17 64 1 c2 19 20 18 80 1c 43 "
16r"f9 20 18 c0 c1 43 f1 0 17 64 13 c2 19 20 19 80 1c 44 b 20 19 c6 2e 0 9 "
16r"80 2e 43 11 0 a 20 30 80 18 44 33 80 19 0 7 20 2c c0 cf 43 11 64 39 80 "
16r"20 64 3d c2 19 20 31 c0 1c 0 32 80 1c 64 49 c3 20 44 39 20 33 c0 cf 44 "
16r"33 20 33 c3 c8 0 10 62 db c0 3a 0 2d 0 11 a0 3a c4 d4 0 23 44 73 20 25 "
16r"c0 c0 0 26 43 89 20 24 c0 d4 0 2a 43 b 64 7b c3 bf 0 28 64 89 80 49 0 "
16r"2a 43 b 64 89 e1 3d 80 1c 0 27 64 73 c6 be 43 df 0 2e 0 34 0 7 62 c1 c0 "
16r"20 0 34 0 6 a0 20 c5 18 41 c5 41 d7 45 81 68 d7 c8 12 0 3c 46 41 0 3d "
16r"0 34 41 d7 45 81 68 d7 c7 d2 0 35 80 d2 0 34 41 d7 45 81 68 d7 c8 d1 0 "
16r"44 46 55 0 42 0 34 41 d7 45 81 68 d7 ca 3e 0 33 0 30 80 3e 46 8d 0 32 "
16r"46 41 41 d7 45 81 68 d7 c7 d0 0 47 80 d0 45 ad 0 48 45 81 68 d7 c7 3c "
16r"0 e 46 a3 0 3 41 d7 45 81 68 d7 c3 cf 0 5 68 ef c3 ce 0 d 69 9f 83 5b "
16r"0 5b 69 7d 86 59 0 38 0 34 41 d7 45 81 68 d7 87 4e 0 2b 0 5 47 f7 0 2a "
16r"45 81 68 d7 85 47 0 e 0 59 49 fd 20 3 86 39 0 5 47 f7 0 2a 45 81 68 d7 "
16r"82 21 6a 45 84 20 48 f 45 81 68 d7 83 1a 0 2c a0 20 86 16 0 37 0 34 41 "
16r"d7 45 81 68 d7 86 15 0 36 0 34 41 d7 45 81 68 d7 80 f 80 33 0 2c a0 20 "
16r"e1 bd c0 bc 45 97 48 1f 48 2f 48 41 48 55 48 6b 48 83 48 9d 68 b9 e1 bb "
16r"c6 9 0 46 80 9 45 ad 0 48 65 97 80 e 45 ad 0 49 65 97 c3 18 41 c5 61 d7 "
16r"c6 12 0 3c 46 41 0 3d 0 34 61 d7 c5 d2 0 35 80 d2 0 34 61 d7 c6 d1 0 44 "
16r"46 55 0 42 0 34 61 d7 c8 3e 0 33 0 30 80 3e 46 8d 0 32 46 41 61 d7 c5 "
16r"d0 0 47 80 d0 45 ad 20 48 c5 3c 0 e 46 a3 0 3 61 d7 c3 cf 0 5 66 b7 c5 "
16r"ba 0 d 47 69 0 3 61 d7 83 5b 0 5b 67 41 84 59 0 38 0 34 61 d7 85 4e 0 "
16r"2b 0 5 47 f7 20 2a 84 39 0 5 47 f7 20 2a 82 21 67 fd 82 20 68 f 84 16 "
16r"0 37 0 34 61 d7 80 15 0 36 0 34 61 d7 c0 12 0 39 80 12 66 49 c2 b9 20 "
16r"3b c0 12 0 3a 80 12 66 49 c4 1e 0 3e 46 63 66 6b a1 4d 80 2e 66 81 c0 "
16r"1e 0 3f 80 1e a0 2e e1 b9 c0 4b 66 71 c0 4b 0 40 80 4b 0 41 46 7d a0 2e "
16r"e1 2e a0 d0 e1 b9 c2 4b 66 71 c0 1e 46 63 66 6b e1 12 80 18 46 95 a0 19 "
16r"c0 d4 41 fd 0 31 66 9d e1 19 80 1c 66 95 c0 3c 0 4c 0 39 0 6 46 af 20 "
16r"c 80 3c 40 59 0 b a0 3c c3 cb 42 91 67 2b c6 ca 0 1d 42 b5 0 2e 0 34 67 "
16r"41 c6 c9 0 20 80 c9 0 2e 0 34 67 41 c5 c8 0 f 42 db 0 34 67 41 c5 3a 0 "
16r"2d 80 3a 0 34 67 41 86 45 43 59 0 22 0 2e 0 34 67 41 85 2c 43 df 0 2e "
16r"0 34 67 41 84 2b 44 1d 0 34 67 41 88 2a 80 18 44 b 80 19 0 14 0 2e 0 34 "
16r"67 41 86 29 43 59 0 12 0 2e 0 34 67 41 80 1f 44 55 0 34 67 41 c5 ca 42 "
16r"b5 0 2e 0 34 67 41 c0 d1 0 34 46 55 0 42 0 34 61 d7 c7 3e 0 30 80 3e 46 "
16r"8d 0 32 46 41 61 d7 c0 b8 0 4b 67 55 c4 18 41 c5 0 4a 61 d7 c0 ba 0 d "
16r"47 69 0 3 0 4a 61 d7 c0 ba 0 4d 47 7b 47 c7 80 2f 0 4e 47 df 0 3 a0 2d "
16r"c6 b7 47 8d 47 97 47 9f 47 a7 20 56 80 46 47 af 20 51 e1 b6 80 30 0 41 "
16r"80 20 20 52 e1 b5 80 31 0 53 63 b e1 b4 80 32 0 54 63 b e1 b3 80 33 0 "
16r"55 63 b c0 20 0 41 80 20 80 11 0 50 41 fd 0 57 0 9 67 c1 e1 b3 80 1c 67 "
16r"af e1 2f 80 34 47 cf 20 4f c0 d6 40 b1 40 bb 67 d7 e1 2f 80 b 0 29 67 "
16r"cf c0 d6 40 a9 0 27 47 e9 20 25 e1 b2 80 17 0 49 80 1b 40 a9 0 28 67 e9 "
16r"c0 cf 43 11 20 34 c4 18 41 c5 0 4c 61 d7 c0 ba 0 d 47 69 0 3 61 d7 c3 "
16r"b9 0 29 61 d7 c0 10 0 4f 80 10 45 ad 20 50 e1 b1 c0 8 0 46 80 8 45 ad "
16r"45 97 0 48 68 1f e1 b0 c0 7 0 46 80 7 45 ad 45 97 48 1f 0 48 68 2f e1 "
16r"af c0 6 0 46 80 6 45 ad 45 97 48 1f 48 2f 0 48 68 41 e1 ae c0 5 0 46 80 "
16r"5 45 ad 45 97 48 1f 48 2f 48 41 0 48 68 55 e1 ad c0 4 0 46 80 4 45 ad "
16r"45 97 48 1f 48 2f 48 41 48 55 0 48 68 6b e1 ac c0 3 0 46 80 3 45 ad 45 "
16r"97 48 1f 48 2f 48 41 48 55 48 6b 0 48 68 83 e1 ab c0 2 0 46 80 2 45 ad "
16r"45 97 48 1f 48 2f 48 41 48 55 48 6b 48 83 0 48 68 9d e1 bd c0 1 0 46 80 "
16r"1 45 ad 45 97 48 1f 48 2f 48 41 48 55 48 6b 48 83 48 9d 0 48 68 b9 e1 "
16r"aa c6 58 0 46 80 58 45 ad 45 81 20 48 c0 3f 0 4d 80 3f 41 fd 20 4e c3 "
16r"cb 42 91 69 63 c6 ca 0 1d 42 b5 0 2e 0 34 69 7d c6 c9 0 20 80 c9 0 2e "
16r"0 34 69 7d c5 c8 0 f 42 db 0 34 69 7d c5 3a 0 2d 80 3a 0 34 69 7d 86 45 "
16r"43 59 0 22 0 2e 0 34 69 7d 85 2c 43 df 0 2e 0 34 69 7d 84 2b 44 1d 0 34 "
16r"69 7d 88 2a 80 18 44 b 80 19 0 14 0 2e 0 34 69 7d 86 29 43 59 0 12 0 2e "
16r"0 34 69 7d 80 1f 44 55 0 34 69 7d c5 ca 42 b5 0 2e 0 34 69 7d c0 d1 0 "
16r"34 46 55 0 42 0 34 41 d7 45 81 68 d7 c4 a9 47 41 45 81 68 d7 c0 a 0 f "
16r"49 8d 20 3 80 a 0 35 0 3c 0 39 69 97 c0 d4 41 fd 0 a 20 b c6 ba 47 69 "
16r"0 3 41 d7 45 81 68 d7 80 54 0 20 80 20 80 18 49 bb 80 19 0 21 20 26 c0 "
16r"a8 49 c1 69 f7 c3 bc 0 1d 69 d3 c3 3a 0 1c a0 3a c0 20 0 1b a0 20 86 d0 "
16r"80 18 49 e9 49 ef 0 1e a0 19 80 e 80 18 49 e9 49 ef a0 19 c0 cf 43 59 "
16r"20 35 e1 19 80 1c 0 1f 69 e9 e1 a7 80 1c 69 bb c0 18 0 35 80 18 4a 11 "
16r"80 19 0 38 4a 3f 80 a 0 39 69 97 c7 cf 0 36 49 e9 0 41 80 20 0 37 6a 2b "
16r"80 5b 0 58 0 41 80 20 0 37 6a 2b e1 19 80 1c 6a 31 c2 a6 6a 11 c0 20 0 "
16r"41 80 20 0 37 6a 2b c0 c1 43 f1 20 35 c4 b8 47 fd 45 81 68 d7 c0 a 0 10 "
16r"49 8d 20 3 e1 19 80 1c 61 f5 c4 a5 4a 75 0 56 6a 7d c3 d4 41 fd 6a 83 "
16r"80 49 0 55 4a 99 4a 75 0 56 6a 7d e1 bf 80 36 41 fd 20 54 e1 3d 80 1c "
16r"6a 5b c8 49 0 52 80 49 0 55 4a 99 4a 75 0 56 6a 7d c0 bf 0 51 6a 7d e1 "
16r"a5 c0 d4 41 fd 20 53 c3 cb 42 91 6b f c6 ca 0 1d 42 b5 0 2e 0 34 6b 2b "
16r"c6 c9 0 20 80 c9 0 2e 0 34 6b 2b c5 c8 0 f 42 db 0 34 6b 2b c5 3a 0 2d "
16r"80 3a 0 34 6b 2b 86 45 43 59 0 22 0 2e 0 34 6b 2b 82 2c 6b a9 84 2b 44 "
16r"1d 0 34 6b 2b 88 2a 80 18 44 b 80 19 0 14 0 2e 0 34 6b 2b 86 29 43 59 "
16r"0 12 0 2e 0 34 6b 2b 80 1f 44 55 0 34 6b 2b c5 ca 42 b5 0 2e 0 34 6b 2b "
16r"c0 d1 0 34 46 55 0 42 0 34 41 d7 45 81 48 d7 20 9 c3 a4 49 7d 20 9 c0 "
16r"20 0 7 6b 37 c0 20 0 41 0 48 80 20 6b 41 c5 a3 4b 55 0 5 4b 65 20 57 c0 "
16r"d0 0 5a 80 d0 4b 75 20 57 c0 a3 0 45 6b 5b c2 a2 20 47 80 3f 0 46 63 b "
16r"e1 a1 80 44 0 41 0 48 80 20 4b 55 0 5 6b 65 c0 a0 0 43 6b 7b c4 d4 43 "
16r"b 0 5 6b 99 85 5c 0 44 80 2e 0 5 6b 99 80 c 0 43 46 41 0 b 0 5 6b 99 e1 "
16r"a1 80 44 0 41 0 48 80 20 0 5a 80 d0 6b 75 c5 be 43 df 0 2e 0 34 6b 2b "
16r"c0 20 0 37 0 42 0 41 80 20 6b bf c8 3f 0 34 0 48 80 3f 4b e1 0 5 4b f5 "
16r"20 57 c0 d0 0 33 0 48 0 5a 80 d0 4b e1 0 5 4c b 20 57 c4 18 0 3b 49 fd "
16r"20 4 c0 c1 0 3a 4a 3f 0 3b 49 8d 20 4 e1 a1 80 44 0 42 0 41 80 20 0 34 "
16r"0 48 80 3f 4b e1 0 5 6b f5 e1 a1 80 44 0 42 0 41 80 20 0 33 0 48 0 5a "
16r"80 d0 4b e1 0 5 6c b c4 a4 0 5b 49 7d 20 9 c0 20 0 8 0 59 6b 37 c5 9f "
16r"0 2a 45 81 48 d7 20 9 c0 20 0 7 6b 37 c3 9e 4c 53 20 57 80 41 0 42 4c "
16r"d9 0 24 20 57 82 43 6c 5b 80 42 6c bd cb 18 0 2f 80 18 43 f9 80 19 0 36 "
16r"0 1a 43 f1 0 15 0 35 6c 77 c0 9d 0 42 6c a1 c0 9d 0 2c 80 9d 0 5a 80 d0 "
16r"4c 87 0 5 6c 97 c4 d4 0 30 43 b 20 31 80 5c 0 32 0 31 a0 2e e1 a1 c0 44 "
16r"0 2a 80 44 6c 77 c0 9d 0 2c 80 9d 0 5a 80 d0 0 2e 4b e1 0 5 6c b3 e1 a1 "
16r"c0 44 0 2a 80 44 6c a1 c0 9d 0 2c 80 9d 0 5a 80 d0 80 2e 0 2d 0 5 6c cf "
16r"e1 a1 c0 44 0 2a 80 44 6c bd c0 9d 0 22 80 9d 6c e1 c3 a2 0 5 6c f5 c0 "
16r"d0 0 5a 80 d0 0 23 47 f7 0 5 6c f5 e1 a1 c0 44 0 2a 80 44 6c d9 e1 9c "
16r"80 b 6d 5 c2 9c 20 2b c0 d6 0 29 60 a9 c2 9b 6d 19 c0 9a 0 25 6e c9 c7 "
16r"5d 0 4b 0 17 80 5d 0 59 0 14 6d 33 c0 11 0 25 0 17 80 11 0 14 6e b7 85 "
16r"3 4d 55 0 16 0 5a 20 25 86 2 4d ed 0 16 0 5a 0 25 20 13 80 1 4e 65 0 16 "
16r"0 5a 0 25 20 13 c0 18 0 11 4d 63 0 27 0 3 4d 91 20 20 80 18 0 3d 4d 75 "
16r"80 19 4d 8d 40 a9 0 27 47 e9 20 3e c4 cf 43 59 0 35 6d 83 80 21 0 16 20 "
16r"35 e1 19 c0 20 0 41 0 3f a0 20 e1 d6 a0 a c2 99 20 1f c4 11 0 18 80 11 "
16r"6d a9 80 1c 0 11 4d 63 0 25 4d 91 20 20 c3 d6 4d b9 20 26 80 49 0 11 4d "
16r"c1 0 28 20 26 c0 d6 0 11 47 df 20 3 c0 d6 40 9f 6d c7 cb 5d 0 4b 0 17 "
16r"80 5d 0 59 0 14 80 3 4d 55 0 16 0 5a 20 25 c0 11 0 25 0 17 80 11 0 14 "
16r"80 3 4d 55 20 16 c0 d6 4d b9 0 1d 4d f7 20 20 c2 98 6e 5 80 1c 4d b9 0 "
16r"1c 4d f7 20 20 c2 99 20 1f c0 11 0 18 80 11 6e 11 c3 d6 4d b9 20 1e 80 "
16r"49 0 21 6e 1d c5 d6 0 11 4e 31 0 28 20 1e 80 1d 0 11 4e 5f 0 28 20 1e "
16r"c0 d6 40 9f 6e 37 cc 5d 0 4b 0 17 80 5d 0 59 0 14 80 2 4d ed 0 16 0 5a "
16r"0 25 20 13 c0 11 0 25 0 17 80 11 0 14 80 2 4d ed 20 16 c0 d6 40 9f 6d "
16r"19 c0 d6 4d b9 0 19 6e 6d c2 99 20 1b c0 11 0 18 80 11 6e 79 c3 d6 4d "
16r"b9 20 1a 80 49 0 11 4e 89 0 28 20 1a c0 d6 40 9f 6e 8f cc 5d 0 4b 0 17 "
16r"80 5d 0 59 0 14 80 1 4e 65 0 16 0 5a 0 25 20 13 c0 11 0 25 0 17 80 11 "
16r"0 14 80 1 4e 65 20 16 83 3 4d 55 20 16 83 2 4d ed 20 16 80 1 4e 65 20 "
16r"16 c6 1c 0 22 80 1c 4e d9 0 20 20 23 c0 99 20 13 c0 d6 4d b9 6e df c2 "
16r"99 20 24 c0 1c 0 22 80 1c 4e d9 20 20 e1 da c0 97 4e f5 60 67 a1 37 a1 "
16r"36 a1 2f a1 2e a1 2a a1 29 a0 12 e1 96 c3 95 0 5 6f 37 84 38 40 67 50 "
16r"6d 71 15 85 31 80 38 40 67 50 f 70 2f 84 22 40 67 50 f 70 2f 83 1f 40 "
16r"67 71 4b 80 18 0 d 40 59 0 e 80 19 60 67 c2 94 6f 4d 83 93 40 67 70 17 "
16r"80 1e 40 67 50 1 50 f 50 7b 70 87 c3 26 4f 81 6f 9f c7 24 0 6 0 a 80 24 "
16r"40 85 0 3 60 67 83 25 4f ad 60 67 86 21 80 18 4f db 4f ed 80 19 60 67 "
16r"83 20 4f f5 60 67 80 13 40 67 50 1 70 f 80 26 80 18 4f 8f 4f 93 4f 99 "
16r"80 19 60 67 e1 92 a0 1d e1 91 80 1e a0 1d e1 19 80 23 a0 1d e1 96 c0 27 "
16r"0 5 80 27 40 67 0 5 6f 81 e1 90 c0 18 0 8 0 a 80 18 41 fd 0 b 4f c1 0 "
16r"9 a0 19 e1 19 c0 1c 4f c9 6f d5 c0 1c 0 8 0 a 80 1c 41 fd 20 b e1 19 c0 "
16r"1c 6f c9 c0 8f 40 6f 80 12 6f e3 e1 8e c0 8f 40 6f 80 12 6f e3 e1 19 80 "
16r"1c 4f db 6f ed e1 90 80 18 4f db 80 1c 4f db a0 19 c0 8d 50 7 60 67 a1 "
16r"38 82 31 a0 38 a0 22 e1 8c c0 8d 50 1 70 f c4 8d 50 1 50 f 70 2f c0 1e "
16r"0 5 80 1e 40 67 50 1 50 f 50 7b 70 87 e1 96 c0 8b 0 5 50 39 70 87 83 23 "
16r"40 67 70 47 80 1e 40 67 50 f 70 7b c2 8a 70 53 80 38 40 67 50 6d 70 75 "
16r"c6 93 0 5 80 93 40 67 50 1 70 f 84 31 80 38 40 67 70 f 80 22 40 67 70 "
16r"f e1 89 80 38 40 67 70 6d e1 88 c0 8a 70 53 e1 88 c0 23 0 5 80 23 40 67 "
16r"70 47 e1 96 c0 27 0 5 80 27 40 67 70 93 c3 87 0 5 70 b7 84 38 40 67 50 "
16r"6d 70 df 86 31 80 38 40 67 50 f 0 5 70 39 80 22 40 67 50 f 0 5 70 39 83 "
16r"93 40 67 70 c7 80 1e 40 67 50 1 50 f 70 7b c5 8d 50 1 50 f 0 5 70 39 c0 "
16r"1e 0 5 80 1e 40 67 50 1 50 f 70 7b c3 86 0 5 70 fb 86 31 80 38 40 67 50 "
16r"f 0 5 70 39 80 22 40 67 50 f 0 5 70 39 c2 8b 70 39 80 93 71 3 c6 85 40 "
16r"67 50 1 50 f 0 5 70 39 c0 8b 0 5 70 39 e1 96 c3 86 0 5 71 2f 85 31 80 "
16r"38 40 67 50 f 70 2f 80 22 40 67 50 f 70 2f c3 8b 50 39 70 87 80 93 71 "
16r"39 c5 85 40 67 50 1 50 f 70 2f c0 8b 0 5 50 39 70 87 e1 96 80 1f 40 67 "
16r"71 4b e1 84 80 1c 40 5f 71 53 e1 f a0 56 c0 83 51 67 0 11 71 7f c2 82 "
16r"20 10 80 52 71 6f c6 20 0 d 80 20 80 11 0 e a0 20 80 21 20 f e1 81 80 "
16r"53 0 12 80 20 71 89 e1 81 80 1c 0 13 0 12 80 55 71 89 e1 20 80 18 51 9d "
16r"a0 19 c0 20 0 a 80 20 71 a5 e1 19 80 1c 71 9d c4 80 51 5f 0 9 71 c3 80 "
16r"51 80 20 0 14 80 18 51 d5 80 19 0 1a 20 8 c5 ba 0 d 47 69 0 3 20 b 80 "
16r"18 40 8d 80 19 20 b c0 20 0 14 80 20 0 5a 80 d0 51 e3 71 ff 83 54 80 20 "
16r"20 17 80 20 71 ed c2 8e 20 15 c0 18 0 14 80 18 51 d5 80 19 0 1a 20 16 "
16r"c3 19 0 19 20 18 80 1c 51 d5 20 18 "
16r"0 0 0 80 0 1 f8 0 2 0 30 0 0 20 0 80 0 1 f8 0 2 0 0 0 0 20 0 80 0 1 "
16r"f8 0 2 0 10 0 0 20 0 80 0 1 f8 0 2 0 30 0 0 0 0 40 0 0 0 8 0 0 2 0 "
16r"0 0 20 4 20 6b 43 80 0 0 0 0 0 0 c 2 10 0 0 0 0 0 0 0 0 0 c 2 0 0 0 0 "
16r"0 0 0 0 0 0 0 48 1 0 0 8 0 0 2 0 0 0 c 4a 31 0 40 8 0 0 2 0 0 0 c 0 20 "
16r"0 40 0 0 0 0 0 0 0 0 2 10 0 0 0 0 0 0 0 0 0 0 4a 11 0 0 8 0 0 2 0 0 0 "
16r"0 0 20 0 40 80 0 0 0 0 0 0 0 48 0 0 0 0 0 0 0 0 0 0 20 4 0 8 0 0 0 "
16r"0 0 0 0 0 20 4c 0 6b 3 8 0 0 2 0 0 0 0 40 10 0 0 0 0 0 0 0 0 0 0 42 10 "
16r"0 0 0 0 0 0 0 0 0 c 0 0 0 0 0 0 0 0 0 0 0 10 0 ce 0 0 0 0 0 0 0 0 0 1c "
16r"2 ce 0 0 0 0 0 0 0 0 0 0 48 0 0 0 8 0 0 2 0 0 0 20 0 0 63 3 0 0 0 0 0 "
16r"0 0 40 40 0 0 0 0 0 0 80 0 0 0 0 40 0 0 0 0 0 0 80 0 0 0 0 48 0 0 0 0 "
16r"0 0 80 0 0 0 40 0 0 0 0 0 0 0 0 4 0 4 41 48 0 4 0 0 0 0 82 4 7f c2 0 "
16r"0 0 0 0 a0 0 8 0 0 0 0 0 0 0 0 0 0 30 0 0 0 7f d6 41 48 0 5 0 1 0 0 82 "
16r"84 7f cb 3e a3 ff fb f9 7a 87 86 8 7b 0 14 41 48 0 5 0 0 0 0 82 4 0 14 "
16r"41 48 0 5 0 0 8 0 82 4 0 14 41 48 0 5 0 1 8 0 82 4 0 20 0 80 0 1 f8 2 "
16r"2 0 0 0 0 0 0 8 0 0 2 4 0 0 0 0 0 2 0 1 3f f8 1 30 84 80 0 13 0 0 0 "
16r"40 0 0 0 0 0 20 0 0 7f c2 0 0 80 0 0 20 0 0 0 0 0 0 0 80 0 1 f8 2 2 "
16r"0 0 0 0 14 41 48 0 5 3a 4 8 40 82 4 40 14 41 48 0 5 3a 5 8 40 82 84 "
16r"60 14 41 48 0 5 3a 5 8 40 82 84 70 14 41 48 0 5 3a 5 8 40 82 84 78 14 "
16r"41 48 0 5 3a 5 8 40 82 84 7c 14 41 48 0 5 3a 5 8 40 82 84 7e 14 41 "
16r"48 0 5 3a 5 8 40 82 84 7f 14 41 48 0 5 3a 5 8 40 82 84 0 0 40 48 0 4 "
16r"0 0 0 0 80 4 0 0 0 0 0 1 8 0 0 0 0 0 0 0 0 0 0 1 18 0 0 0 0 0 0 0 0 "
16r"0 0 1 38 0 0 0 0 0 0 0 0 0 0 1 78 0 0 0 0 0 0 0 0 0 0 1 f8 0 0 0 0 0 "
16r"0 0 0 80 0 1 f8 0 2 0 0 0 7f d6 41 c8 0 5 3a 15 8 40 82 84 0 0 0 0 0 1 "
16r"f8 0 2 0 0 0 7f 94 41 48 0 5 3a 5 8 40 82 84 7f c2 0 0 0 0 0 0 0 0 0 0 "
16r"0 14 41 48 0 5 3a 5 8 40 82 84 0 2 0 81 7f f8 1 30 84 80 0 3 0 0 0 "
16r"8 0 0 0 4 0 0 0 0 0 20 0 8 0 0 0 4 0 0 0 0 0 2 0 1 7f f8 1 30 84 80 0 "
16r"3 0 2 0 0 7 80 1 0 0 80 0 0 0 2 0 0 3f e8 1 0 4 80 0 3 ff ff ff ff 7f "
16r"ff ff ff ff ff ff ff ff ff ff f7 ff ff ff ff ff ff ff ff 0 0 0 0 7 80 "
16r"0 0 0 0 0 0 0 2 0 2 7 82 0 0 0 4 0 0 0 0 0 0 0 0 0 10 80 0 0 0 0 0 0 "
16r"0 38 0 0 0 0 0 0 3 0 2 0 0 7 80 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 80 0 0 "
16r"7f c3 3e a3 ff fb f9 7a 87 86 8 53 7f d6 41 48 0 5 3a 5 8 40 82 84 "
16r"0 0 0 0 0 1 f8 0 2 0 8 0 0 2 0 1 3f f8 1 30 84 80 0 3 7f c0 0 0 0 0 "
16r"0 0 0 0 0 0 0 0 0 2 0 2 0 0 0 4 0 0 0 0 18 0 0 0 0 0 0 0 0 0 0 0 0 "
16r"0 0 0 0 0 70 0 0 0 7f c3 3e a3 ff fb f9 7a 87 86 8 73 7f c3 3e a3 ff fb "
16r"f9 7a f7 86 8 73 7f c3 3e b3 ff fb f9 7a f7 86 8 73 0 0 0 4 0 8 0 0 0 "
16r"0 0 0 0 0 3c cb ff 63 43 88 0 0 2 0 0 0 20 4 0 6b 3 0 0 0 0 0 0 0 1c "
16r"cb ff 0 40 88 0 0 2 0 0 0 3c cf ee 6b 43 88 0 0 2 0 0 0 0 0 0 0 0 0 0 "
16r"0 3 0 ";

 CO end CO

INT sidbwd =     +4619, boolwdsize =        +4;

INT  sidstackstep = 1000;
INT  upbofsidstack:= sidstackstep;
REF VECTOR [] INT sidstack:= LOC VECTOR[upbofsidstack]INT;
INT stind := 1;

INT crts := 1, failpos, t1;

INT sidbwdm = sidbwd - boolwdsize * 384, boolwds3 = boolwdsize * 3;


PROC analyser = INT:
BEGIN
    INT u, v;
    failpos := 0;
    DO u := ABS sidcode[crts];
       v := ABS sidcode[crts + 1];
       IF u < 128
       THEN IF u < 64 THEN GOTO action FI;
            IF u < 96
            THEN sidstack[stind] := crts + 2;
                 IF stind = upbofsidstack
                 THEN  HEAP VECTOR [upbofsidstack PLUSAB sidstackstep] INT  new;
                       new[: UPB sidstack]:= sidstack;
                       sidstack:= new
                 FI;
                 stind +:= 1;
                 failpos := 0
            FI;
            crts := ABS ((BIN u AND BIN 31) SHL 8) + v
       ELIF IF failpos = 0 THEN failpos := crts FI;
            IF v < 128
            THEN t1 = v
            ELSE (BIN ABS sidcode[v * boolwds3 +
                                  ABS (BIN t1 SHR 3) + sidbwdm
                                 ]
                  AND (z1 SHL (7 - ABS (BIN t1 AND BIN 7)))
                 ) /= z
            FI
       THEN IF u < 192
            THEN v := 1;
                 GOTO action
            FI;
            failpos := 0;
            IF u < 224
            THEN crts +:= 2
            ELSE crts := sidstack[stind -:= 1]
            FI
       ELSE IF (u := ABS (BIN u AND BIN 31)) = 0
            THEN v := 2;
                 GOTO out
            FI;
            crts +:= u + u
       FI
    OD;

action:
    IF ABS (BIN u AND BIN 63) < 32
    THEN crts +:= 2
    ELSE crts := sidstack[stind -:= 1]
    FI;
out:
    v
END;


PROC checkinsert = (INT t, BOOL testnext)BOOL:
BEGIN
    INT failcrts := failpos, failstind := stind,
        symbol := t, u, v, rstind := 1;
    VECTOR[30]INT rsidstack;
    BOOL readt1 := testnext, result;

    DO u := ABS sidcode[failcrts];
       v := ABS sidcode[failcrts + 1];
       IF u < 128
       THEN IF u < 64
            THEN IF u < 32
                 THEN failcrts +:= 2
                 ELSE failcrts := IF rstind = 1
                                  THEN sidstack[failstind -:= 1]
                                  ELSE rsidstack[rstind -:= 1]
                                  FI
                 FI
            ELSE IF u < 96
                 THEN rsidstack[rstind] := failcrts + 2;
                      rstind +:= 1
                 FI;
                 failcrts := ABS ((BIN u AND BIN 31) SHL 8) + v
            FI
       ELIF IF v < 128
            THEN v = symbol
            ELSE (BIN ABS sidcode[v * boolwds3 + sidbwdm +
                                  ABS (BIN symbol SHR 3)
                                 ]
                  AND (z1 SHL (7 - ABS (BIN symbol AND BIN 7)))
                 ) /= z
            FI
       THEN IF readt1 ANDTH ABS (BIN u AND BIN 223) /= 193
            THEN result := TRUE;
                 GOTO exit
            ELSE IF (BIN u AND BIN 32) = z
                 THEN failcrts +:= 2
                 ELSE failcrts := IF rstind = 1
                                  THEN sidstack[failstind -:= 1]
                                  ELSE rsidstack[rstind -:= 1]
                                  FI
                 FI;
                 IF u < 192
                 THEN readt1 := TRUE;
                      symbol := t1
                 FI
            FI
       ELIF (u := ABS (BIN u AND BIN 31)) > 0
       THEN failcrts +:= u + u
       ELSE result := FALSE;
            GOTO exit
       FI
    OD;

exit:
    result
END;



CO ********************************************************************** CO

COMMENT  bits are:   straight  array  vector  arraychar
                     vecchar  lcompl  lreal  lint
                     int  lbits  char  bool
COMMENT

VECTOR[]STRUCT (INT prio, do, BITS test, INT ans) diops = (

        (6, 2, 2r0001 1111 0010, -10),   CO + CO
        (6, 2, 2r0000 0111 0000, -1),    CO - CO
        (8, 3, 2r0100 0000 0000, int),   CO upb CO
        (8, 3, 2r0100 0000 0000, int),   CO lwb CO
        (3, 2, 2r0000 0000 0001, -1),    CO andth CO
        (2, 2, 2r0000 0000 0001, -1),    CO orel CO
{       { the lbits bit must be set to be able to
          deal with the optimised OR/AND option }
        (3, 2, 2r0000 0000 0101, -1),    CO andth CO
        (2, 2, 2r0000 0000 0101, -1),    CO orel CO
}       (5, 2, 2r0001 1011 0010, bool),  CO < CO
        (5, 2, 2r0001 1011 0010, bool),  CO > CO
        (5, 2, 2r0001 1011 0110, bool),  CO <= CO
        (5, 2, 2r0001 1011 0110, bool),  CO >= CO
        (4, 2, 2r0001 1111 0111, bool),  CO = CO
        (4, 2, 2r0001 1111 0111, bool),  CO /= CO
        (7, 9, 2r0001 1111 0010, -10),   CO * CO
        (7, 2, 2r0000 0111 0000, -9),    CO / CO
        (7, 2, 2r0000 0001 0000, -1),    CO % CO
        (7, 2, 2r0000 0001 0000, -1),    CO mod CO
        (8, 4, 2r0000 0111 0000, -8),    CO ** CO
        (9, 2, 2r0000 0011 0000, -5),    CO i CO
        (8, 4, 2r0000 0000 0100, -8),    CO shl CO
        (8, 4, 2r0000 0000 0100, -8),    CO shr CO
        (7, 5, 2r0000 0000 0100, bool),  CO elem CO
        (1, 6, 2r0001 1111 0000, -7),    CO plusab CO
        (1, 6, 2r0000 0111 0000, -7),    CO minusab CO
        (1, 6, 2r0001 1111 0000, -7),    CO timesab CO
        (1, 6, 2r0000 0001 0000, -7),    CO overab CO
        (1, 6, 2r0000 0001 0000, -7),    CO modab CO
        (1, 6, 2r0000 0110 0000, -7),    CO divab CO
        (88, 7, z, bool),                CO is CO
        (88, 7, z, bool),                CO isnt CO
        (3, 2, 2r0000 0000 0101, -1),    CO and CO
        (2, 2, 2r0000 0000 0101, -1),    CO or CO
        (1, 8, 2r0001 1000 0000, -12),   CO plusto CO
        (5, 3, 2r0100 0000 0000, -11),   CO cycle CO
        (8, 4, 2r0000 0000 0100, -8)     CO up (** or shl) CO
    );

VECTOR[]STRUCT (BITS test, INT ans) monops = (

        (2r0000 0111 0000, -1),    CO + CO
        (2r0000 0111 0000, -1),    CO - CO
        (2r1110 0000 0000, int),   CO upb CO
        (2r1110 0000 0000, int),   CO lwb CO
        (2r0000 0000 0101, -1),    CO not CO
        (2r0000 0111 0111, -4),    CO abs CO
        (2r0000 0001 0000, -6),    CO bin CO
        (2r0000 0000 1000, char),  CO repr CO
        (2r0000 0111 0100, -2),    CO leng CO
        (2r0000 0111 0100, -3),    CO shorten CO
        (2r0000 0001 0000, bool),  CO odd CO
        (2r0000 0011 0000, int),   CO sign CO
        (2r0000 0010 0000, -6),    CO round CO
        (2r0000 0010 0000, -6),    CO entier CO
        (2r0000 0100 0000, -6),    CO re CO
        (2r0000 0100 0000, -6),    CO im CO
        (2r0000 0100 0000, -6),    CO arg CO
        (2r0000 0100 0000, -1)     CO conj CO
    );

    INT booland = 65,
        boolor = 81,
        minplus = 337,
        maxdiv = 418;
    CO 16 * op + version CO

    BOOL moreinput := TRUE;

    PROC faultchars = (VECTOR[]CHAR mess)VOID:
    BEGIN INT i := tind;
          WHILE i > 0 ANDTH textbuff[i] = " "
          DO i -:= 1 OD;

          IF   supflts = 0
          THEN flt(mess, i);
               noflts +:= 12;
               IF   noflts > 180 ANDTH noflts < 193
               THEN CO compilation abandoned - too many errors CO
                    abort1(101)
               FI
          ELIF fulldiags
          THEN VECTOR[UPB mess + 8]CHAR m;
               m[ : 8] := "**(S)** ";
               m[9 : ] := mess;
               flt(m, i)
          FI
    END;

    PROC fault = (INT i)VOID: faultchars(message(i));

    PROC abort = (INT mess) VOID:
    BEGIN supflts := 0;
          IF mess >= 0 THEN fault(mess) FI;
          textend -:= 1;
          TO 10
          WHILE moreinput
          DO moreinput := input(textbuff1, textend) OD;
          GOTO endcompile2
    END;

    abort1 := abort;


PROC primread = INT:
BEGIN
    INT type, value;
    CHAR c;
    BOOL radixgiven := FALSE, lastspace;
    INT ans, radix := 10, origsize, strop := 0;

CO It may be worth declaring
   REF VECTOR[]CHAR idvec = ident, compvec = compsymb;
   in order to avoid the isvec coercion inside loops
CO

    INT stringonly = 1,
        space = 2,
        letter = 3,
        digit = 4,
        stringquote = 5,
                CO bold is global CO
        openstrop = 7,
        matchstrop = 8,
        simple = 20,
        compstart = 21,
        compound = 22,
        compterm = 23;

l:  CASE
         c := textbuff[tind +:= 1];
         type := type OF charset[ABS c]
         CO if value can be set up here economically, some later
            assignments to value may be omitted
         CO
    IN

CO stringonly CO
       (fault(102);
        CO character not recognised CO
        GOTO l
       ),

CO space CO
        IF tind = textend
        THEN ans := rcnewline
        ELSE GOTO l
        FI,

CO letter CO
       (idsize := 0;
        idhash := 0;
        ident := spaces;

   l1:  IF idsize /= maxid
        THEN ident[idsize +:= 1] := c;
             idhash +:= ABS c
        FI;

   l2:  c := textbuff[tind +:= 1];
        type := type OF charset[ABS c];
        IF type = space ANDTH tind /= textend
        THEN GOTO l2
        ELIF type = letter OREL type = digit
        THEN GOTO l1
        FI;
        tind -:= 1;
        ans := rcident;
        idhash := ABS (BIN idhash AND BIN 63) + 1
       ),

CO digit CO
       (IF isint THEN stringsize := 0 FI;
        origsize := stringsize;
  l1:   iv := 0;
        IF isint ANDTH
           (string[stringsize +:= 1] := "020400080a00000g"[radix]) = "0"
        THEN fault(103)
             CO illegal radix CO
        FI;

        DO
           value := value OF charset[ABS c];
           IF value < radix ANDTH value >= 0
           THEN
                string[stringsize +:= 1] := c;
                IF iv <= maxistruct
                THEN iv := iv * radix + value
                FI
           ELIF value /= 37 CO space CO
                OREL tind = textend
           THEN GOTO out
           FI;

           c := textbuff[tind +:= 1]
        OD;

  out:  IF value = 27 CO r CO ANDTH NOT radixgiven
        THEN IF iv > 16 OREL iv < 2
             THEN iv := 16;
                  fault(103)
                  CO illegal radix CO
             FI;
             stringsize := origsize;
             radixgiven := TRUE;
             radix := iv;

             WHILE
                   c := textbuff[tind +:= 1];
                   value OF charset[ABS c] = 37
             DO IF tind = textend
                THEN GOTO out
                FI
             OD;

             IF
                type OF charset[ABS c] /= stringquote
             THEN GOTO l1
             ELSE noofchars := 1;
                  lastspace := TRUE;
                  WHILE
                        c := textbuff[tind +:= 1];
                        value := value OF charset[ABS c];
                        type OF charset[ABS c] /= stringquote
                  DO
                     string[stringsize +:= 1] := c;
                     IF value = 37
                     THEN IF tind = textend
                          THEN CO string over newline CO
                               fault(104);
                               supflts := fltgap;
                               tind -:= 1;
                               GOTO end
                          ELIF lastspace
                          THEN stringsize -:= 1
                          ELSE noofchars +:= 1;
                               lastspace := TRUE
                          FI
                     ELIF value >= radix OREL value < 0
                     THEN CO illegal char in radix string CO
                          fault(105)
                     ELSE lastspace := FALSE
                     FI
                  OD;

            end:  IF lastspace OREL stringsize = 0
                  THEN noofchars -:= 1
                  FI;
                  IF lastspace ANDTH stringsize /= 0
                  THEN stringsize -:= 1
                  FI;
                  radixgiven := FALSE;
                  ans := stringtok;
                  stringbase := radix
             FI
        ELIF value = 14 CO e CO
        THEN ans := rcintexp
        ELSE tind -:= 1;
             ans := IF radixgiven
                    THEN bitsdentok
                    ELSE intdentok
                    FI
        FI;

        IF radixgiven ANDTH stringsize <= origsize + 1
        THEN fault(106);
             CO illegal symbol after r CO
             supflts := fltgap
        FI
       ),

CO stringquote CO
       (stringsize := 0;

        WHILE IF tind = textend
              THEN fault(104);
                   CO string goes over newline CO
                   supflts := fltgap;
                   FALSE
              ELSE
                   c := textbuff[tind +:= 1];
                   type OF charset[ABS c] /= stringquote
                   OREL (c := textbuff[tind +:= 1];
                         type OF charset[ABS c] = stringquote
                        )
              FI
        DO
           string[stringsize +:= 1] := c
        OD;

  out:  tind -:= 1;
        stringbase := 0;
        noofchars := stringsize;
        ans := stringtok
       ),

CO bold CO

       (compsize := comphash := 0;
        compsymb := spaces;
        typechar1 := bold;

        WHILE type = bold OREL type = digit
        DO IF compsize /= maxid
           THEN ans := IF type = bold
                       THEN - 1 - value OF charset[ABS c]
                       ELSE ABS c
                       FI;
                comphash +:= ans;
                compsymb[compsize +:= 1] := REPR ans
           FI;
           c := textbuff[tind +:= 1];
           type := type OF charset[ABS c]
        OD;

        comphash := ABS (BIN comphash AND BIN 63) + 1;

        ans := lookup(compsymb[ : compsize], TRUE);
        tind -:= 1
       ),

CO openstrop CO
       strop := 1,

CO matchstrop CO
       strop := 2

    OUT

CO simple or compound CO
        compsize := comphash := 0;
        compsymb := spaces;
        typechar1 := type;
   l1:  IF compsize /= maxid
        THEN compsymb[compsize +:= 1] := c;
             comphash +:= ABS c
        FI;

        IF type /= compterm ANDTH type /= simple
        THEN c := textbuff[tind +:= 1];
             type := type OF charset[ABS c];
             IF type = compound OREL type = compterm
             THEN GOTO l1
             ELSE tind -:= 1
             FI
        FI;
        comphash := ABS (BIN comphash AND BIN 63) + 1;

        IF compsize /= 1
           OREL (ans := value OF charset[ABS compsymb[1]]) = calllookup
        THEN ans := lookup(compsymb[ : compsize], FALSE)
        FI
    ESAC;

    IF strop /= 0
    THEN
         ans := value OF charset[ABS c];
         c := textbuff[tind +:= 1];
         type := type OF charset[ABS c];
         value := value OF charset[ABS c];

         IF type /= letter
         THEN tind -:= 1
              CO ans (already assigned) may be illegal tok CO
         ELSE
              compsize := comphash := 0;
              compsymb := spaces;
              typechar1 := type;

              WHILE value <= 36 ANDTH value >= 0
                    CO alphabetic CO
              DO IF compsize /= maxid
                 THEN compsymb[compsize +:= 1] := c;
                      comphash +:= ABS c
                 FI;
                 c := textbuff[tind +:= 1];
                 type := type OF charset[ABS c];
                 value := value OF charset[ABS c]
              OD;
              comphash := ABS (BIN comphash AND BIN 63) + 1;

              ans := lookup(compsymb[ : compsize], TRUE);
              IF strop = 1
              THEN tind -:= 1
              ELIF type /= matchstrop
              THEN tind -:= 1;
                   IF NOT incom
                   THEN fault(107);
                        CO missing strop symbol CO
                        supflts := fltgap
                   ELSE ans := illegaltok
                   FI
              FI
         FI
    FI;
    isint := TRUE;
    ans
END;


PROC fprimread = INT:
BEGIN INT type, value;
      CHAR c;
      INT j, k, radix := 0;

l:    c := textbuff[tind +:= 1];
      type := type OF charset[ABS c];
      value := value OF charset[ABS c];

l1:   IF type > 2
      THEN globfbuff[find +:= 1] := c
      FI;

      CASE type
      IN
CO stringonly CO
         (fault(102);
          CO character not recognised CO
          GOTO l
         ),

CO space CO
         IF tind = textend
         THEN IF find /= 0
              THEN output(XCHARS (- find, 0,
                                  globfbuff[ : find]
                                 ), outlevel + 1);
                   noofstrings +:= find;
                   find := 0
              FI;
              rcnewline
         ELSE GOTO l
         FI,

CO letter CO
         IF value = 28
            CO s CO
         THEN WHILE
                    c := textbuff[tind +:= 1];
                    type := type OF charset[ABS c];
                    value := value OF charset[ABS c];

                    type = 2 ANDTH tind /= textend
              DO SKIP OD;
              IF value = 130 OREL value = 13 OREL value = 10
                             OREL value = 14 OREL value = 18
              THEN globfbuff[find +:= 1] := c;
                   value
              ELSE tind -:= 1;
                   28
              FI
         ELSE value
         FI,

CO digit CO
         (radix := value;
      m:  WHILE
                c := textbuff[tind +:= 1];
                type := type OF charset[ABS c];
                value := value OF charset[ABS c];

                type = 4
          DO globfbuff[find +:= 1] := c;
             IF radix < 100
             THEN radix := 10 * radix + value
             FI
          OD;

          IF type = 2 ANDTH tind /= textend
          THEN GOTO m
          FI;
          IF value = 27
             CO r CO
          THEN IF radix > 16
               THEN radix := 16;
                    fault(103)
                    CO illegal radix CO
               FI;
               globfbuff[find +:= 1] := c;

               c := textbuff[tind +:= 1];
               type := type OF charset[ABS c];
               value := value OF charset[ABS c];
               IF type = 5
               THEN GOTO l1
               ELSE tind -:= 1
               FI;
               -2
          ELSE tind -:= 1;
               8
          FI
         ),

CO stringquote CO
         (DO IF tind = textend
             THEN fault(104);
                  CO string goes over newline CO
                  GOTO out
             ELSE
                  c := textbuff[tind +:= 1];
                  type := type OF charset[ABS c];
                  value := value OF charset[ABS c];
                  globfbuff[find +:= 1] := c;
                  IF type = 5
                     CO stringquote CO
                  THEN
                       c := textbuff[tind +:= 1];
                       type := type OF charset[ABS c];
                       value := value OF charset[ABS c];
                       IF type /= 5
                       THEN GOTO out
                       ELSE globfbuff[find +:= 1] := c
                       FI
                  FI;
                  IF radix /= 0
                  THEN IF value >= radix ANDTH value /= 37
                       THEN CO illegal char in radix string CO
                            fault(105)
                       FI
                  FI
             FI
          OD;
     out: tind -:= 1;
          IF type = 2
          THEN globfbuff[find +:= 1] := c
          FI;
          stringtok
         )

      OUT k := (tind -:= 1);
          IF ((j := primread) >= rccomment ANDTH j < rcnewline)
             OREL (j >= rcpragmat ANDTH j < illegaltok)
          THEN find -:= 1;
               j
          ELIF j = 160
               OREL ((j = 128 OREL j < 60) ANDTH compsize = 1)
               OREL j = 130
          THEN j
          ELIF j = biplus ANDTH compsize = 1
          THEN -1
          ELIF j = biminus ANDTH compsize = 1
          THEN 0
          ELIF value = 130
          THEN tind := k + 1;
               9
          ELSE tind := k;
               100
          FI
      ESAC
END;

CO ********************************************************************** CO

PROC insertprocp = (INT deproc, REF MODELIST pars)INT:
BEGIN INT j;
      REF MODELIST ml1, ml2;
      FOR i FROM newmode1 TO lastmode
      DO CASE modes[i]
         IN (REF PROCP pp):
              IF deproc OF pp = deproc ANDTH
                 (ml1 := pars OF pp;
                  ml2 := pars;
                  WHILE (ml1 ISNT nilml)
                        ANDTH (ml2 ISNT nilml)
                        ANDTH mode OF ml1 = mode OF ml2
                  DO ml1 := rest OF ml1;
                     ml2 := rest OF ml2
                  OD;
                  (ml1 IS nilml) ANDTH (ml2 IS nilml)
                 )
              THEN j := i;
                   GOTO end
              FI
         OUT SKIP
         ESAC
      OD;

      IF lastmode < upbofmodes
      THEN modes[j := lastmode +:= 1] := HEAP PROCP := (deproc, pars)
      ELSE abort(206)
           CO too many modes CO
      FI;

end:  j
END;

PROC insertunion = (REF MODELIST rm)INT:
BEGIN INT j;
      REF MODELIST ml1, ml2;
      FOR i FROM newmode1 TO lastmode
      DO CASE modes[i]
         IN (REF UNN u):
              IF ml1 := rm;
                 ml2 := modelist OF u;
                 WHILE (ml1 ISNT nilml)
                       ANDTH (ml2 ISNT nilml)
                       ANDTH mode OF ml1 = mode OF ml2
                 DO ml1 := rest OF ml1;
                    ml2 := rest OF ml2
                 OD;
                 (ml1 IS nilml) ANDTH (ml2 IS nilml)
              THEN j := i;
                   GOTO end
              FI
         OUT SKIP
         ESAC
      OD;

      IF lastmode < upbofmodes
      THEN modes[j := lastmode +:= 1] := HEAP UNN := (0, rm)
      ELSE abort(206)
           CO too many modes CO
      FI;

end:  j
END;

PROC insertstrct = (INT deflex, REF SELIST sels)INT:
BEGIN INT j;
      REF SELIST sl1, sl2;
      FOR i FROM 22 TO lastmode
      DO CASE modes[i]
         IN (REF STRCT str):
              IF sl1 := sels OF str;
                 sl2 := sels;
                 WHILE (sl1 ISNT nilsel)
                       ANDTH (sl2 ISNT nilsel)
                       ANDTH name OF sl1 = name OF sl2
                       ANDTH mode OF sl1 = mode OF sl2
                 DO sl1 := rest OF sl1;
                    sl2 := rest OF sl2
                 OD;
                 (sl1 IS nilsel) ANDTH (sl2 IS nilsel)
              THEN j := i;
                   GOTO end
              FI
         OUT SKIP
         ESAC
      OD;

      IF lastmode < upbofmodes
      THEN modes[j := lastmode +:= 1] := HEAP STRCT := (0, deflex, sels)
      ELSE abort(206)
           CO too many modes CO
      FI;

end:  j
END;

PROC insertprc = (INT mode)INT:
BEGIN INT j;
      PRC p;
      deproc OF p := mode;
      FOR i FROM newmode1 TO lastmode
      DO CASE modes[i]
         IN (REF PRC pp):
              IF deproc OF pp = mode
              THEN j := i;
                   GOTO end
              FI
         OUT SKIP
         ESAC
      OD;

      IF lastmode < upbofmodes
      THEN modes[j := lastmode +:= 1] := HEAP PRC := p
      ELSE abort(206)
           CO too many modes CO
      FI;

end:
      j
END;

PROC insertarray = (INT mode, nods, deflex)INT:
BEGIN INT j;
      FOR i FROM arraychar TO lastmode
      DO CASE modes[i]
         IN (REF ARRAY a):
              IF mode OF a = mode ANDTH nods OF a = nods
                 ANDTH IF deflex OF a >= 0
                       THEN deflex >= 0
                       ELSE deflex < 0
                       FI
              THEN j := i;
                   GOTO end
              FI
         OUT SKIP
         ESAC
      OD;

      IF lastmode < upbofmodes
      THEN modes[j := lastmode +:= 1] := HEAP ARRAY
                                      := (0, mode, nods, deflex)
      ELSE abort(206)
           CO too many modes CO
      FI;

end:
      j
END;

PROC insertvec = (INT m, deflex)INT:
BEGIN INT j;
      FOR i FROM vecchar TO lastmode
      DO CASE modes[i]
         IN (REF VCTOR rv):
              IF vecmode OF rv = m
                 ANDTH IF deflex OF rv >= 0
                       THEN deflex >= 0
                       ELSE deflex < 0
                       FI
              THEN j := i;
                   GOTO end
              FI
         OUT SKIP
         ESAC
      OD;

      IF lastmode < upbofmodes
      THEN modes[j := lastmode +:= 1] := HEAP VCTOR := (0, m, deflex)
      ELSE abort(206)
           CO too many modes CO
      FI;

end:
      j
END;

PROC insertis = (INT m, l)INT:
BEGIN INT j;
      FOR i FROM newmode1 TO lastmode
      DO CASE modes[i]
         IN (REF ISTRUCT ri):
              IF imode OF ri = m ANDTH length OF ri = l
              THEN j := i;
                   GOTO end
              FI
         OUT SKIP
         ESAC
      OD;

      IF lastmode < upbofmodes
      THEN modes[j := lastmode +:= 1] := HEAP ISTRUCT := (0, m, l, 1)
      ELSE abort(206)
           CO too many modes CO
      FI;

end:
      j
END;

PROC insertassmntproc = (INT m)INT:
insertprocp(m + refmark,
            HEAP MODELIST := (m + refmark, HEAP MODELIST := (m, NIL))
           );

PROC opproc = (REF INST i)INT:
BEGIN REF MODELIST ml := HEAP MODELIST := (rmode OF i, NIL);
      IF lmode OF i /= 0
      THEN ml := HEAP MODELIST := (lmode OF i, ml)
      FI;
      insertprocp(ans OF i, ml)
END;

PROC freevalue = (REF VALUE v) VOID:
IF props OF v >= heapbit
THEN REF VLIST vl := vlist OF v, vl1;
     WHILE vl ISNT nilvl
     DO vl1 := vl;
        vl := rest OF vl;
        rest OF vl1 := freevl;
        freevl := vl1
     OD
FI;

PROC globvlist = REF VLIST:
IF freevl IS nilvl
THEN HEAP VLIST
ELSE REF VLIST vl := freevl;
     freevl := rest OF freevl;
     vl
FI;

PROC heapvalue = (REF VALUE v) VOID:
IF (props OF v AND heapbit) = z
THEN REF REF VLIST vl := vlist OF v;
     REF VLIST heapvl;

     WHILE vl ISNT nilvl
     DO heapvalue(v OF vl);
        (REF REF VLIST (vl)) := globvlist := vl;
        vl := rest OF vl
     OD;
     props OF v := props OF v OR heapbit
FI;

PROC downandups = (REF VALUE v) VOID:
BEGIN REF VLIST vl := vlist OF v;

      WHILE vl ISNT nilvl
      DO IF props OF v OF vl >= downbit
         THEN output(down, outlevel);
              output(up, outlevel)
         FI;
         downandups(v OF vl);
         vl := rest OF vl
      OD
END;

PROC tidyv = (REF VALUE v) VOID:
BEGIN IF vlist OF v IS nilvl
      THEN IF props OF v >= semibit
           THEN v := (props OF globcurrent OR downbit OR heapbit,
                      - 1, globvlist := (v, xbegin, NIL), NIL
                     )
           ELSE IF props OF v >= downbit
                THEN output(down, outlevel)
                FI;
                props OF v := props OF v OR downbit
                              OR props OF globcurrent
           FI
      ELSE props OF v := props OF globcurrent
                                   OR downbit OR props OF v
      FI;

      output(up, outlevel);
       downandups(v)
END;

CO ********************************************************************** CO

PROC faultp = (INT messno, INT m1, m2, REF ID id)VOID:
BEGIN
    VECTOR[]CHAR mess = message(messno);
    VECTOR[240]CHAR m;

    INT mind := 0;
    BOOL dot := FALSE;
    CHAR c;

    PROC outid = (ID id)VOID:
    BEGIN CHAR c;
          INT i := mind;
          FOR i TO maxid
          WHILE (c := id[i]) /= " "
          DO m[mind +:= 1] := c OD;
          IF i = mind THEN GOTO endf FI
    END;

    PROC outboldid = (ID id)VOID:
    BEGIN CHAR c;

          INT i := mind;
          FOR i TO maxid
          WHILE (c := id[i]) /= " "
          DO m[mind +:= 1] := IF c >= "a" ANDTH c <= "z"
                              THEN REPR (ABS c + bolddiff)
                              ELSE c
                              FI
          OD;
          IF i = mind THEN GOTO endf FI;

          SKIP
    END;


    PROC outchars = (VECTOR[]CHAR v)VOID:
    BEGIN INT u = UPB v;
          m[mind + 1 : mind + u] := v;
          mind +:= u
    END;

    PROC outmess = (INT n)VOID:
    BEGIN VECTOR[]CHAR v = message(n);
          INT u = UPB v;
          m[mind + 1 : mind + u] := v;
          mind +:= u
    END;

    PROC outint = (INT i)VOID:
    BEGIN INT j := i;
          INT k := j MOD 10;
          j := j % 10;
          IF j > 0 THEN outint(j) FI;
          m[mind +:= 1] := REPR (k + ABS "0")
    END;

    PROC outmode = (INT mode, BOOL high)VOID:
    BEGIN REF INDIC ri;
          REF MODELIST ml;
          REF SELIST sl;

          REF VECTOR[]REF INDIC rri;

          IF mode < 0
          THEN m[mind +:= 1] := "?";
               GOTO out
          FI;

          IF ABS (BIN mode AND decsmask) > UPB initmodes
          THEN FOR j TO 2
               DO rri := CASE j
                         IN indics OF globcurrent,
                            libinds
                         ESAC;
                  FOR i TO 64
                  DO ri := rri[i];
                     WHILE ri ISNT nilind
                     DO CASE u OF ri
                        IN (REF AMODE ra):
                             IF mode OF ra = mode
                             THEN outboldid(name OF ri);
                                  GOTO out
                             FI
                        OUT SKIP
                        ESAC;
                        ri := rest OF ri
                     OD
                  OD
               OD
          FI;

          IF mode > refmark
          THEN outmess(92);  CO ref CO
               outmode(mode - refmark, high)
          ELSE CASE modes[mode]
               IN (PRIMITIVE p):
                    IF mode = faultmode
                    THEN GOTO endf
                    ELSE outmess(IF mode = collatmode
                                 THEN CO collateral CO
                                      67
                                 ELSE mode + 66
                                 FI
                                )
                    FI,
                  (REF PRC prc):
                    (outmess(46);  CO proc CO
                     outmode(deproc OF prc, high)
                    ),
                  (REF UNN u):
                    (outmess(93);  CO union ( CO
                     IF high
                     THEN ml := modelist OF u;
                          outmode(mode OF ml, FALSE);
                          IF (ml := rest OF ml) ISNT nilml
                          THEN outchars(", ");
                               outmode(mode OF ml, FALSE);
                               IF rest OF ml ISNT nilml
                               THEN outmess(99)  CO , . .  CO
                               FI
                          FI
                     FI;
                     m[mind +:= 1] := ")"
                    ),

                  (REF PROCP pp):
                    (outmess(94);  CO proc ( CO
                     IF high
                     THEN ml := pars OF pp;
                          outmode(mode OF ml, FALSE);
                          IF (ml := rest OF ml) ISNT nilml
                          THEN outchars(", ");
                               outmode(mode OF ml, FALSE);
                               IF rest OF ml ISNT nilml
                               THEN outmess(99)  CO , . .  CO
                               FI
                          FI
                     FI;
                     m[mind +:= 1] := ")";
                     outmode(deproc OF pp, FALSE)
                    ),
                  (REF STRCT s):
                    IF mode < 26
                    THEN outmess(mode + 66)
                    ELSE outmess(45);  CO struct ( CO
                         IF high
                         THEN sl := sels OF s;
                              outmode(mode OF sl, FALSE);
                              m[mind +:= 1] := " ";
                              outid(name OF sl);
                              IF (sl := rest OF sl) ISNT nilsel
                              THEN outchars(", ");
                                   outmode(mode OF sl, FALSE);
                                   m[mind +:= 1] := " ";
                                   outid(name OF sl);
                                   IF rest OF sl ISNT nilsel
                                   THEN outmess(99)  CO , . . CO
                                   FI
                              FI
                         FI;
                         m[mind +:= 1] := ")"
                    FI,
                  (REF ISTRUCT ri1):
                    (outint(length OF ri1);
                     m[mind +:= 1] := " ";
                     outmode(imode OF ri1, high)
                    ),
                  (REF VCTOR v):
                    (IF deflex OF v < 0
                     THEN outmess(72)  CO flex CO
                     FI;
                     outmess(97);  CO vector[ ] CO
                     outmode(vecmode OF v, high)
                    ),
                  (REF ARRAY a):
                    (IF deflex OF a < 0
                     THEN outmess(72)  CO flex CO
                     FI;
                     outmess(43);  CO [ CO
                     INT mm := mode OF a;
                     TO nods OF a - 1
                     DO CASE modes[mm]
                        IN (REF ARRAY ra):
                             mm := mode OF ra
                        ESAC
                     OD;
                     TO nods OF a - 1
                     DO m[mind +:= 1] := "," OD;
                     outmess(44);  CO ] CO
                     outmode(mm, high)
                    ),
                  (REF STEN sten):
                    (outmess(98);  CO straight CO
                     outmode(mode OF sten, high)
                    )
               OUT outchars("ILLEGAL MODE ")
               ESAC
          FI;
out:      SKIP
    END;

    FOR i TO UPB mess
    DO c := mess[i];
       IF dot ANDTH c /= "."
       THEN dot := FALSE;
            IF c = "1"
            THEN outmode(m1, TRUE)
            ELIF c = "2"
            THEN outmode(m2, TRUE)
            ELIF c = "3"
            THEN outboldid(id)
            ELIF c = "4"
            THEN outid(id)
            ELSE outint(m1)
            FI
       ELIF NOT dot ANDTH c = "."
       THEN dot := TRUE
       ELSE m[mind +:= 1] := c;
            dot := FALSE
       FI
    OD;
    faultchars(m[ : mind]);
endf: SKIP
END;

CO ********************************************************************** CO

PROC marker = (INT mode)INT:
BEGIN CO  marker(mode) < 0       =>  mode volatile,
             ABS marker(mode) = 1  =>  static,
                                = 2  =>  simple array,
                                = 3  =>  compound, with no assign proc yet made,
                                > 3  =>  assignment proc
        CO

        PROC state = (REF INT rd, INT mode) VOID:
        BEGIN INT i = marker(mode);
                IF i <= - 2
                THEN rd := - 3
                ELIF i >= 2
                THEN rd := (rd > 0 ! 3 ! - 3)
                ELIF i = - 1 ANDTH rd > 0
                THEN rd := - rd
                FI
        END;

        IF mode <= 25
        THEN 1
        ELIF mode = xtype
        THEN -3
        ELIF mode >= refmark
        THEN - 1
        ELSE CASE modes[mode]
               IN (REF ARRAY a):
                             (IF rdenno OF a = 0
                              THEN state(rdenno OF a := 2, mode OF a)
                              FI;
                              rdenno OF a
                             ),
                    (REF STRCT st):
                             (IF rdenno OF st = 0
                              THEN REF SELIST s := sels OF st;
                                     rdenno OF st := 1;

                                     WHILE s ISNT nilsel
                                     DO state(rdenno OF st, mode OF s);
                                          s := rest OF s
                                     OD
                              FI;
                              rdenno OF st
                             ),
                    (REF UNN u):
                             (IF rdenno OF u = 0
                              THEN REF MODELIST ml := modelist OF u;
                                     rdenno OF u := 1;

                                     WHILE ml ISNT nilml
                                     DO state(rdenno OF u, mode OF ml);
                                          ml := rest OF ml
                                     OD
                              FI;
                              rdenno OF u
                             ),
                    (REF VCTOR v):
                             (IF rdenno OF v = 0
                              THEN state(rdenno OF v := 2, vecmode OF v)
                              FI;
                              rdenno OF v
                             ),
                    (REF ISTRUCT is):
                             (IF rdenno OF is = 0
                              THEN state(rdenno OF is := 1, imode OF is)
                              FI;
                              rdenno OF is
                             ),
                    (REF PRC p):
                              - 1,
                    (REF PROCP pp):
                              - 1,
                    (REF STEN sten):
                              - 3
               OUT 1
               ESAC
        FI
END;

PROC assmarker = (INT mode)INT:
BEGIN CO same as marker but any dim flex array is simple CO
        INT i := marker(mode);
        IF i = 3
        THEN CASE modes[mode]
               IN (REF ARRAY a):
                          IF nods OF a /= 1 ANDTH deflex OF a < 0
                          THEN i := IF marker(mode OF a) < 0
                                      THEN -2
                                      ELSE 2
                                      FI
                          FI
               OUT SKIP
               ESAC
        FI;
        i
END;

PROC deflex = (INT i)INT:
IF i > refmark
THEN i
ELSE CASE modes[i]
       IN (REF ARRAY a):
                IF deflex OF a = 0
                THEN i
                ELIF deflex OF a = 1
                THEN INT j;
                       IF deflex OF a := 0;
                            (j := deflex(mode OF a)) = mode OF a
                       THEN deflex OF a := 0;
                              i
                       ELSE deflex OF a := insertarray(j, nods OF a, 1)
                       FI
                ELIF deflex OF a = - 1
                THEN deflex OF a := - i;
                       - (deflex OF a :=
                          - insertarray(deflex(mode OF a), nods OF a, 1)
                         )
                ELSE ABS deflex OF a
                FI,
            (REF VCTOR v):
                IF deflex OF v = 0
                THEN i
                ELIF deflex OF v = 1
                THEN INT j;
                       IF deflex OF v := 0;
                            (j := deflex(vecmode OF v)) = vecmode OF v
                       THEN deflex OF v := 0;
                              i
                       ELSE deflex OF v := insertvec(j, 1)
                       FI
                ELIF deflex OF v = - 1
                THEN deflex OF v := - i;
                       - (deflex OF v :=
                          - insertvec(deflex(vecmode OF v), 1)
                         )
                ELSE ABS deflex OF v
                FI,
            (REF ISTRUCT is):
                IF deflex OF is = 0
                THEN i
                ELIF deflex OF is = 1
                THEN INT j;
                       IF deflex OF is := 0;
                            (j := deflex(imode OF is)) = imode OF is
                       THEN deflex OF is := 0;
                              i
                       ELSE deflex OF is := insertis(j, length OF is)
                       FI
                ELSE deflex OF is
                FI,
            (REF STRCT s):
                IF deflex OF s = 0
                THEN i
                ELIF deflex OF s = 1
                THEN REF SELIST csel, dsel, sel := sels OF s;
                       deflex OF s := 0;

                       WHILE (sel ISNT nilsel)
                               ANDTH deflex(mode OF sel) = mode OF sel
                       DO sel := rest OF sel OD;

                       IF sel IS nilsel
                       THEN deflex OF s := 0;
                              i
                       ELSE sel := sels OF s;
                              csel := NIL;

                              WHILE sel ISNT nilsel
                              DO dsel := HEAP SELIST := sel;
                                   rest OF dsel := csel;
                                   csel := dsel;
                                   mode OF csel := deflex(mode OF csel);
                                   sel := rest OF sel
                              OD;

                              WHILE csel ISNT nilsel
                              DO dsel := rest OF csel;
                                   rest OF csel := sel;
                                   sel := csel;
                                   csel := dsel
                              OD;
                              deflex OF s := insertstrct(0, sel)
                       FI
                ELSE deflex OF s
                FI
       OUT i
       ESAC
FI;

PROC enflex = (INT m)INT:
BEGIN INT i := ABS marker(m);
        REF REF SELIST rsel;
        REF SELIST old, new;
        IF i = 1 OREL i = 2 ANDTH deflex(m) /= m
        THEN m
        ELSE CASE modes[m]
               IN (REF ARRAY a):
                        (i := mode OF a;
                         TO nods OF a - 1
                         DO CASE modes[i]
                              IN (REF ARRAY a1):
                                          i := mode OF a1
                              ESAC
                         OD;
                         i := enflex(i);
                         FOR k TO nods OF a - 1
                         DO i := insertarray(i, k, 1) OD;
                         insertarray(i, nods OF a, - 1)
                        ),
                    (REF VCTOR v):
                        insertvec(enflex(vecmode OF v), - 1),
                    (REF ISTRUCT is):
                        insertis(enflex(imode OF is), length OF is),
                    (REF STRCT s):
                        (rsel := new;
                         old := sels OF s;

                         WHILE old ISNT nilsel
                         DO (REF REF SELIST (rsel)) := HEAP SELIST
                                                          := old;
                              mode OF rsel := enflex(mode OF old);
                              old := rest OF old;
                              rsel := rest OF rsel := NIL
                         OD;
                         insertstrct(1, new)
                        )
               OUT m
               ESAC
        FI
END;

PROC mproc = (INT mode)INT:
insertprocp(deflex(mode), boolnil);

PROC deref = (REF VALUE v) VOID:
BEGIN mode OF v := deflex(mode OF v - refmark);
        output(XOPER (xderef, mode OF v, 0), outlevel)
END;

PROC deproc = (REF VALUE v) VOID:
CASE modes[mode OF v]
IN (REF PRC p):
        (IF burestrict
         THEN fault(108)
                CO no proc calls CO
         FI;
         output(XOPER (xcall, deproc OF p, 0), outlevel);
         IF ABS marker(mode OF v := deproc OF p) >= 2
         THEN dybits OF globcurrent := dybits OF globcurrent
                                              OR dyprocbit
         FI
        )
ESAC;

PROC pmode = (INT m)INT:
BEGIN INT ans := m;
    aa:
        ans := ABS (BIN ans AND decsmask);
        CASE modes[ans]
        IN (REF PRC p):
                   (ans := deproc OF p;
                    GOTO aa
                   )
        OUT SKIP
        ESAC;
        deflex(ans)
END;


BOOL deprefable := TRUE;
PROC(REF VALUE, INT, INT, INT, BOOL)BOOL coerce1;

PROC depref = (REF VALUE v, INT frommode, tomode, BOOL code)BOOL:
IF NOT deprefable
THEN frommode = tomode
ELSE INT f := frommode, t := tomode;
       BOOL ans := TRUE;

       WHILE f /= t ANDTH ans
       DO IF f > refmark
            THEN IF code THEN deref(v) FI;
                   f := deflex(f - refmark)
            ELSE CASE modes[f]
                   IN (REF PRC p):
                             (IF code THEN deproc(v) FI;
                              f := deproc OF p
                             )
                   OUT ans := FALSE
                   ESAC
            FI
       OD;
       ans
FI;

PROC weakmode = (INT mode)INT:
BEGIN INT m := mode;
        INT qref := 0;
        DO IF m > refmark
             THEN qref := refmark;
                    m -:= refmark
             ELSE CASE modes[m]
                    IN (REF PRC p):
                              (qref := 0;
                               m := deproc OF p
                              )
                    OUT GOTO out
                    ESAC
             FI
        OD;
out:    m + qref
END;

PROC unite = (REF VALUE v, INT f, t, str, BOOL code)INT:
CASE modes[t]
IN (REF UNN u):
          (INT ans := 0;
           REF MODELIST ml := modelist OF u;
           FOR i
           WHILE ml ISNT nilml
           DO IF coerce1(v, f, mode OF ml, str, code ANDTH ans = 0)
                THEN IF ans /= 0 ANDTH code
                       THEN CO uniting in more than one way CO
                              faultp(109, f, t, NIL)
                       ELSE ans := i
                       FI
                FI;
                ml := rest OF ml
           OD;
           ans
          )
ESAC;

PROC makeflex = (INT m)INT:
BEGIN INT ans := m;
        IF m < refmark
        THEN CASE modes[m]
               IN (REF VCTOR v):
                        IF deflex OF v >= 0
                        THEN ans := insertvec(vecmode OF v, -1)
                        FI,
                    (REF ARRAY a):
                        IF deflex OF a >= 0
                        THEN ans := insertarray(mode OF a, nods OF a, -1)
                        FI
               OUT SKIP
               ESAC
        FI;
        ans
END;

PROC strbd = (INT m)INT:
CASE modes[m]
IN (REF STRCT s):
         (INT j;
          REF SELIST sels := sels OF s;
          FOR i WHILE sels ISNT nilsel
          DO j := i;
               sels := rest OF sels
          OD;
          j
         ),
     (REF ISTRUCT is):
         length OF is,
     (REF VCTOR v):
         - 1,
     (REF ARRAY a):
         - 1 - nods OF a,
     (REF UNN u):
         1
OUT 0
ESAC;

CO ********************************************************************** CO

PROC strproc = (INT f, t, oldf, BOOL code)INT:
CO f is ref and flexed CO
BEGIN
    INT i, p := 1, m;
    REF STENLIST rs;
    INT lastid1, ind, param, decl;
    BITS props1, dybits1;
    RDEN rd;
    REF SELIST sels;
    REF MODELIST ml;
    IDDEC iddec;
    REF INT lastid = lastid OF globcurrent;

    PROC strcoerce = (INT f, t)VOID:
    BEGIN VALUE v := (z, f, NIL, NIL);
            INT f1 := f;
            IF oldf < refmark
            THEN IF code THEN deref(v) FI;
                   f1 -:= refmark
            FI;
            IF NOT coerce1(v, f1, t, 7, code)
            THEN p := 0
            FI
    END;

    BOOL olddeprefable = deprefable;
    deprefable := FALSE;

    CASE modes[t]
    IN (REF STEN sten):
            (rs := stenlist OF sten;

             WHILE rs ISNT (REF STENLIST (NIL))
             DO IF mode OF rs = oldf
                  THEN p := rdenno OF rs;
                         GOTO out
                  ELSE rs := rest OF rs
                  FI
             OD;

             IF code
             THEN lastid1 := lastid;
                    lastidchanged := TRUE;
                    props1 := props OF globcurrent;
                    dybits1 := dybits OF globcurrent;
                    ind := lastid +:= 1;
                    param := lastid +:= 1;
                    i := insertprocp(mode OF sten,
                                     HEAP MODELIST := (int,
                                          HEAP MODELIST := (f, NIL))
                                    );

                    rd := (idmess(62), CO straight CO
                           globscopebit, i,
                           p := lastrd +:= 1, 0, 0, NIL
                          );
                    output(rd, outlevel);
                    output(XIDDEC (xfdec, iddec := (nullid, ind, 1,
                                                      int, 0, NIL
                                                     )), outlevel);
                    output(XIDDEC (xfdec, iddec := (nullid, param, 1,
                                                      f, 0, NIL
                                                     )), outlevel)
             FI;

             CASE modes[ABS (BIN oldf AND decsmask)]
             IN (REF VCTOR rv):
                     (m := vecmode OF rv + refmark;
                      IF code
                      THEN output(param, outlevel);
                             output(xwindex, outlevel);
                             output(ind, outlevel);
                             output(XOPER (xsimpleindex, m, 1), outlevel)
                      FI;
                      strcoerce(m, mode OF sten)
                     ),
                  (REF ISTRUCT ri):
                     (m := imode OF ri + refmark;
                      IF code
                      THEN output(param, outlevel);
                             output(XOPER (xisvec,
                                             insertvec(imode OF ri, 1)
                                             + refmark,
                                             0
                                            ), outlevel);
                             output(xwindex, outlevel);
                             output(ind, outlevel);
                             output(XOPER (xsimpleindex, m, 1), outlevel)
                      FI;
                      strcoerce(m, mode OF sten)
                     ),
                  (REF STRCT rst):
                     (IF code
                      THEN sels := sels OF rst;
                             FOR j WHILE sels ISNT nilsel
                             DO i := j;
                                  sels := rest OF sels
                             OD;
                             output(XCONTROL (xcase, int, compgenbit,
                                                mode OF sten
                                               ), outlevel);
                             output(ind, outlevel);
                             output(XCONTROL (xin, mode OF sten,
                                                compgenbit, i
                                               ), outlevel)
                      FI;
                      sels := sels OF rst;
                      FOR j
                      WHILE sels ISNT nilsel
                      DO m := mode OF sels + refmark;
                           IF code
                           THEN IF j /= 1
                                  THEN output(XCONTROL (xcomma,
                                                            mode OF sten,
                                                            compgenbit, j
                                                           ), outlevel)
                                  FI;
                                  output(param, outlevel);
                                  output(XOPER (xselect, m, j), outlevel)
                           FI;
                           strcoerce(m, mode OF sten);
                           sels := rest OF sels
                      OD;
                      IF code
                      THEN output(XCONTROL (xesac, 0, compgenbit,
                                                mode OF sten
                                               ), outlevel)
                      FI
                     ),
                  (REF UNN ru):
                     IF oldf > refmark
                     THEN p := 0
                     ELSE IF code
                            THEN decl := lastid OF globcurrent +:= 1;
                                   ml := modelist OF ru;
                                   FOR j
                                   WHILE ml ISNT nilml
                                   DO i := j;
                                        ml := rest OF ml
                                   OD;
                                   output(XCONTROL (xcaseu, oldf, compgenbit,
                                                      mode OF sten
                                                     ), outlevel);
                                   output(param, outlevel);
                                   output(XOPER (xderef, oldf, 0), outlevel);
                                   output(XCONTROL (xinu, mode OF sten,
                                                      compgenbit, i
                                                     ), outlevel)
                            FI;
                            ml := modelist OF ru;
                            FOR j
                            WHILE ml ISNT nilml
                            DO IF code
                                 THEN IF j /= 1
                                        THEN output(XCONTROL (xcommau,
                                                                 mode OF sten,
                                                                  compgenbit, j
                                                                 ), outlevel)
                                        FI;
                                        output(XCONTROL (xuchoice,
                                                           mode OF ml,
                                                           compgenbit, j
                                                          ), outlevel);
                                        output(param, outlevel);
                                        output(XOPER (xdeunite,
                                                     mode OF ml + refmark, 0
                                                       ), outlevel)
                                 FI;
                                 strcoerce(mode OF ml + refmark,
                                           mode OF sten
                                          );
                                 ml := rest OF ml
                            OD;
                            IF code
                            THEN output(XCONTROL (xesacu, 0, compgenbit,
                                                      mode OF sten
                                                     ), outlevel)
                            FI
                    FI,
               (REF ARRAY ra):
                   (m := mode OF ra + refmark;
                    IF code
                    THEN output(param, outlevel);
                           output(xwindex, outlevel);
                           output(param, outlevel);
                           output(XOPER (xderef,
                                           deflex(f - refmark), 0
                                          ), outlevel);
                           output(XOPER (xmonop, int, 50), outlevel);
                           CO 50 is lwb CO
                           output(XNUMBER (int,
                                             string[ : 2] := "a1"
                                            ), outlevel);
                           output(XOPER (xdyop, int, 17), outlevel);
                           output(ind, outlevel);
                           output(XOPER (xdyop, int, 2), outlevel);
                          CO 17 = "-", 2 = "+" CO
                          IF nods OF ra = 1
                          THEN output(XOPER (xsimpleindex,
                                                 m, 1
                                                ), outlevel)
                          ELSE TO nods OF ra - 1
                                 DO output(XOPER (xtrim, 0, 0), outlevel)
                                 OD;
                                 output(XOPER (xtrimindex, m,
                                        nods OF ra
                                       ), outlevel);
                                 IF NOT coerce1(NIL, IF oldf < refmark
                                                           THEN m - refmark
                                                           ELSE m
                                                           FI,
                                                     mode OF sten,
                                                     6, FALSE
                                                    )
                                 THEN output(XOPER (xderef,
                                                        m - refmark, 0
                                                       ),  outlevel);
                                        output(XOPER (xstatgrab,
                                                        makeflex(m - refmark)
                                                        + refmark,
                                                        0 CO heap CO
                                                       ), outlevel)
                                              FI
                                       FI
                                FI;
                                strcoerce(m, mode OF sten)
                           )
                  OUT IF code
                        THEN faultchars("STR-PROC")
                        ELSE p := 0
                        FI
                  ESAC;

                 IF code
                 THEN output(XCONTROL (xroutinend, 0, compgenbit, 0),
                               outlevel
                              );
                        IF lastid > maxident
                        THEN maxident := lastid
                        FI;
                        lastid := lastid1;
                        props OF globcurrent := props1;
                        dybits OF globcurrent := dybits1
                 FI;
                 IF p > 1
                 THEN stenlist OF sten := HEAP STENLIST
                                           := (oldf, p, stenlist OF sten)
                 FI
                )
        OUT faultchars("STRPROC")
        ESAC;
    out:
        deprefable := olddeprefable;
        p
END;

CO ********************************************************************** CO

INT all = 10;

PROC coerce = (REF VALUE v, INT f, t, str, BOOL code)BOOL:
CO  strength:  1  equals
                 2  depref
                 3  isvec or mtoxtype
                 4  isarray or vecarray
                 5  straighten
                 6  unite, no straighten
                 7  unite straighten
                 8  widen
                 9  row etc
                10  hipping etc CO
BEGIN
    INT ans := - 1, t1, f1, qref, i, j, p3 := 0;
    REF MODELIST ml;
    BITS b;
    IF f = t OREL f = faultmode
    THEN ans := 0
    ELIF str = 10 ANDTH
           (IF f = gotomode
            THEN ans := IF t < refmark ANDTH CASE modes[t]
                                                 IN (REF PRC p):
                                                           TRUE
                                                 OUT FALSE
                                                 ESAC
                          THEN xgotoproc
                          ELSE xgotom
                          FI
            ELIF t = voidmode ANDTH f /= collatmode
            THEN f1 := f;
                   IF code ANDTH (props OF v AND assmntbit) = z
                   THEN
                          WHILE i := weakmode(f1);
                                  (BIN (i - f1) AND decsmask) /= z
                          DO coerce(v, f1, i, 2, TRUE);
                               f1 := i
                          OD
                   FI;
                   ans := IF f1 = voidmode
                          THEN 0
                          ELSE xvoid
                          FI
            ELIF f = skipmode
            THEN ans := xskiptom
            ELIF f = nilmode ANDTH t > refmark
            THEN ans := xniltom
            ELIF f = vacmode ANDTH t < refmark ANDTH (i := strbd(t)) < 0
                   CO vec or array CO
            THEN p3 := - i - 1;
                   ans := xvac
            FI;

            ans >= 0
           )
    THEN SKIP
    ELIF str >= 2 ANDTH depref(v, f, t, FALSE)
    THEN IF code THEN depref(v, f, t, TRUE) FI;
           ans := 0
    ELIF str >= 3
    THEN qref := IF t > refmark
                   THEN refmark
                   ELSE 0
                   FI;
           t1 := t - qref;
           IF t1 < refmark
           THEN
               CASE modes[t1]
               IN (REF VCTOR vec):
                         IF deflex OF vec >= 0
                         THEN IF (i := weakmode(f)) > qref
                                THEN CASE modes[f1 := IF qref = 0
                                                         THEN pmode(f)
                                                         ELSE i - refmark
                                                         FI
                                                  ]
                                       IN (REF ISTRUCT ri):
                                                IF imode OF ri =
                                                     vecmode OF vec
                                                     ANDTH coerce(v, f,
                                                                  f1 + qref,
                                                                  2, code
                                                                 )
                                                THEN ans := xisvec
                                                FI
                                       OUT SKIP
                                       ESAC
                                FI;
                                IF ans = - 1 ANDTH str >= 9 ANDTH
                                     coerce(v, f, vecmode OF vec + qref,
                                            9, code
                                           )
                                THEN ans := xvec
                                FI;
                                IF ans = - 1 ANDTH str >= 8
                                               ANDTH vecmode OF vec = bool
                                     ANDTH (f1 := pmode(f)) >= 10
                                     ANDTH f1 <= 13 ANDTH qref = 0
                                THEN coerce(v, f, f1, 2, code);
                                       ans := xwbvb
                                FI
                         FI,
                    (REF ARRAY a):
                         IF deflex OF a >= 0
                         THEN IF str >= 4 ANDTH (i := weakmode(f)) > qref
                                THEN i := f1 := IF qref = 0
                                                  THEN pmode(f)
                                                  ELSE i - refmark
                                                  FI;
                                       j := t1;
                                       TO nods OF a
                                       WHILE i /= 0
                                       DO IF i > refmark
                                            THEN i := 0
                                            ELSE CASE modes[i]
                                                   IN (REF ISTRUCT is):
                                                             i := imode OF is
                                                   OUT i := 0
                                                   ESAC
                                            FI;

                                            CASE modes[j]
                                            IN (REF ARRAY a1):
                                                       j := mode OF a1
                                            ESAC
                                      OD;

                                      IF i = j ANDTH
                                           coerce(v, f, f1 + qref, 2, code)
                                      THEN p3 := nods OF a;
                                             ans := xisarr
                                      ELIF nods OF a = 1
                                      THEN CASE modes[f1]
                                             IN (REF VCTOR rv):
                                                    IF vecmode OF rv
                                                         = mode OF a
                                                         ANDTH coerce(v, f,
                                                                      f1 + qref,
                                                                      2, code
                                                                     )
                                                    THEN ans := xvecarr
                                                    FI
                                           OUT SKIP
                                           ESAC
                                      FI
                               FI;

                               IF ans = - 1 ANDTH str >= 9
                               THEN IF coerce(v, f,
                                                  mode OF a + qref,
                                                  9, code
                                                 )
                                           OREL coerce(v, f,
                                                  makeflex(mode OF a) + qref,
                                                       9, code
                                                      )
                                          THEN ans := IF nods OF a > 1
                                                        THEN xarrarr
                                                        ELSE xarr
                                                        FI
                                         FI
                                 FI;
                                 IF ans = - 1 ANDTH mode OF a = bool
                                      ANDTH nods OF a = 1 ANDTH str >= 8
                                      ANDTH coerce(v, f,
                                               insertvec(mode OF a, 1) + qref,
                                                   8, code
                                                  )
                                 THEN ans := xvecarr
                                 FI
                           FI,
                     (REF STEN s):
                           IF str >= 5 ANDTH str /= 6 ANDTH qref = 0
                           THEN f1 := weakmode(f);
                               aa:
                                  IF depref(v, f, f1, FALSE)
                                  ANDTH (j := strproc(0, t, f1, FALSE)) /= 0
                                  THEN ans := xstraight;
                                       IF code
                                       THEN depref(v, f, f1, TRUE);
                                              i := makeflex(pmode(f)) + refmark;
                                              p3 := strbd(i - refmark);
                                              IF i /= f1
                                           THEN output(XOPER (xprestraight,
                                                                  i, 0
                                                                 ), outlevel)
                                           FI;
                                           IF j = 1
                                           THEN j := strproc(i, t, f1, TRUE)
                                           FI;
                                           output(j, outlevel)
                                    FI
                             ELIF f1 > refmark
                             THEN f1 := deflex(f1 - refmark);
                                    GOTO aa
                             FI
                      FI,
                 (REF UNN u):
                     (IF str >= 6 ANDTH qref = 0
                      THEN CASE modes[f1 := pmode(f)]
                             IN (REF UNN u1):
                                     (ml := modelist OF u1;

                                      WHILE ml ISNT nilml
                                      DO IF unite(v, mode OF ml, t, 1,
                                                      FALSE
                                                     ) = 0
                                           THEN GOTO s
                                           ELSE ml := rest OF ml
                                           FI
                                      OD;
                                      IF coerce(v, f, f1, 2, code)
                                      THEN p3 := - 1;
                                             ans := xuniteu
                                      FI
                                     )
                             OUT SKIP
                             ESAC;
                         s:
                            FOR i FROM 2 TO (str = 6 ! 4 ! 5)
                            WHILE IF (p3 := unite(v, f, t, i, code)) /= 0
                                    THEN IF ans > 0 ANDTH code
                                           THEN faultp(109, f, t, NIL)
                                                  CO > one way of uniting CO
                                           ELSE ans := xunite
                                           FI
                                    FI;
                                     ans < 0
                             DO SKIP OD
                      FI;
                  end:
                      SKIP
                     ),
                 (PRIMITIVE p):
                      IF str >= 8 ANDTH qref = 0 ANDTH p = real
                                    ANDTH coerce(v, f, t1 - 4, 2, code)
                      THEN ans := xwir
                      FI,
                 (REF STRCT s):
                      IF str >= 8 ANDTH qref = 0 ANDTH t1 <= 25
                           ANDTH t1 >= 22
                           ANDTH coerce(v, f, t1 - 4, 8, code)
                      THEN ans := xwrc
                      FI,
                 (REF ISTRUCT ri):
                      IF length OF ri = 1 ANDTH str >= 9
                           ANDTH coerce(v, f, imode OF ri + qref, 8, code)
                      THEN ans := xis
                      FI
            OUT SKIP
            ESAC;

                      IF ans < 0 ANDTH weakmode(f) > qref
                      THEN f1 := pmode(f);
                             IF str >= 3 ANDTH t1 = xtype
                             THEN j := f1
                             ELIF str = 10 ANDTH f1 = ytype
                             THEN j := t1
                             ELSE GOTO e
                             FI;
                         l:  CASE modes[j]
                             IN (REF ARRAY a):
                                       IF nods OF a > 1
                                       THEN j := mode OF a;
                                              GOTO l
                                       FI
                             OUT SKIP
                             ESAC;
                             i := marker(j);
                             IF i = 1 OREL i = 2
                             THEN coerce(v, f, weakmode(f), 2, code);
                                    ans := IF t1 = xtype
                                           THEN xmtoxtype
                                           ELSE xytypetom
                                           FI
                             FI
                      FI
               FI
        FI;

    e:  IF code
        THEN IF ans < 0
               THEN IF str = 10
                      THEN faultp(110, f, t, NIL)
                             CO .1 cannot be coerced to .2 CO
                      FI
               ELSE IF ans > 0
                      THEN output(XOPER (ans, t, p3), outlevel)
                      FI;
                      IF ABS marker(t) >= 2
                      THEN IF (b := IF props OF v >= vardecbit
                                        THEN dyvardecbit
                                        ELIF props OF v >= decbit
                                        THEN dydecbit
                                        ELSE z
                                        FI
                                  ) /= z
                             THEN dybits OF globcurrent :=
                                       dybits OF globcurrent OR b
                         FI;
                         props OF v := props OF v OR dontpullbit
                  FI;
                  mode OF v := t
            FI
    FI;
    ans >= 0
END;

coerce1 := coerce;

PROC hcfoftwo = (INT a, b, BOOL first)INT:
BEGIN INT i := b;
   aa:  IF b /= faultmode ANDTH a /= i ANDTH a /= collatmode
            ANDTH NOT coerce(NIL, a, i, all, FALSE)
        THEN IF i > refmark
               THEN i := deflex(i - refmark);
                      GOTO aa
               ELSE CASE modes[i]
                      IN (REF PRC p):
                               (i := deproc OF p;
                                GOTO aa
                               )
                      OUT i := IF first
                                 THEN hcfoftwo(b, a, FALSE)
                                 ELSE 0
                                 FI
                      ESAC
               FI
        ELIF a = collatmode
        THEN i := pmode(i)
        FI;
        i
END;

PROC hcf = (REF VALUE v)INT:
IF mode OF v >= 0
THEN mode OF v
ELIF REF VLIST vl1 := vlist OF v;
       type OF vl1 /= xcoll
THEN IF type OF vl1 < xbegin
       THEN vl1 := rest OF vl1
       FI;
       INT hmode := hcf(v OF vl1), i;
       WHILE vl1 ISNT nilvl
       DO IF  (i := hcfoftwo(hcf(v OF vl1), hmode, TRUE)) /= 0
            THEN hmode := i
            FI;
            vl1 := rest OF vl1
       OD;
       hmode
ELSE collatmode
FI;

PROC firmto = (REF VALUE v, INT t)INT:
CO 0 = fail, 1 = all, 2 = vecarr unite, 3 = isvec, 4 = depref CO
BEGIN INT ans := 0, i;
        REF VLIST vl;
        IF mode OF v > 0
        THEN FOR i TO 4
               DO IF coerce(NIL, mode OF v, t, CASE i
                                                       IN all, 6, 3, 2
                                                       ESAC, FALSE)
                    THEN ans := i
                    ELSE GOTO out
                    FI
               OD
        ELIF type OF (vl := vlist OF v) = xcoll
        THEN ans := 1
        ELSE IF type OF vl < xbegin
               THEN vl := rest OF vl
               FI;
               WHILE vl ISNT nilvl
               DO IF (i := firmto(v OF vl, t)) = 0
                    THEN ans := 0;
                           GOTO out
                    ELSE IF i > ans THEN ans := i FI;
                           vl := rest OF vl
                    FI
               OD
        FI;
out:    ans
END;

PROC ismode = (REF VALUE v, INT mode, nods)INT:
BEGIN REF VLIST vl := vlist OF v;
        INT n := 0, m;
        IF nods = 0
        THEN mode
        ELIF vl IS nilvl
        THEN m := n := pmode(mode OF v);
               TO nods WHILE n /= 0 ANDTH n < refmark
               DO n := CASE modes[n]
                         IN (REF ISTRUCT ri):
                                       imode OF ri
                         OUT 0
                         ESAC
               OD;

               IF n = mode
               THEN m
               ELSE insertis(ismode(v, mode, nods - 1), 1)
               FI
        ELSE IF type OF vl = xcoll
               THEN WHILE vl ISNT nilvl
                      DO n +:= 1;
                           vl := rest OF vl
                      OD;
                      insertis(ismode(v OF vlist OF v, mode, nods - 1), n)
               ELIF type OF vl = xbegin
               THEN ismode(v OF vl, mode, nods)
               ELSE ismode(v OF rest OF vl, mode, nods)
               FI
        FI
END;

CO ********************************************************************** CO

PROC strong = (REF VALUE v, INT tm, BOOL newendlab)BITS:
CO dontpull CO
BEGIN
    REF VLIST vl;
    REF SELIST sl;
    INT n, m, t;
    BITS ans := z, qdontpull := z;
    INT tomode = ABS tm;
    INT qneg := IF tm < 0
                  THEN -1
                  ELSE 1
                  FI;
    INT pntomode := IF newendlab
                      THEN tomode
                      ELSE -tomode
                      FI;
    WHILE labs OF v ISNT nillab
    DO output(XLABDEC (labs OF v, TRUE), outlevel);
         labs OF v := rest OF labs OF v
    OD;

    IF props OF v >= downbit
    THEN output(down, outlevel)
    FI;

    IF mode OF v >= 0
    THEN coerce(v, mode OF v, tomode, all, TRUE);
           ans := props OF v AND dontpullbit;
           props OF v := z
    ELIF type OF (vl := vlist OF v) = xcoll
    THEN PROC elem = (REF VLIST vl, INT mode)VOID:
           BEGIN output(XCONTROL (type OF vl, mode * qneg,
                                      props OF v OF vl
                                      AND notdontpull OR qdontpull, n
                                     ), outlevel
                         );
                   qdontpull := strong(v OF vl, - mode, TRUE);
                   ans := ans OR qdontpull;
                   qneg := 1
           END;

           IF tomode < refmark
           THEN IF tomode = collatmode
                  THEN GOTO free
                  ELIF tomode = voidmode
                  THEN n := pntomode;
                         FOR i FROM 2
                         WHILE vl ISNT nilvl
                         DO elem(vl, voidmode);
                              vl := rest OF vl;
                              n := i
                         OD;
                         output(XCONTROL (xendcoll, 0, qdontpull, pntomode
                                           ), outlevel);
                         freevalue(v);
                         v := (z, voidmode, NIL, NIL);
                         GOTO over
                  FI;

                  CASE modes[tomode]
                  IN (REF STRCT rs):
                           (sl := sels OF rs;
                            n := pntomode;
                            FOR i FROM 2
                            WHILE (vl ISNT nilvl) ANDTH (sl ISNT nilsel)
                            DO elem(vl, mode OF sl);
                                 vl := rest OF vl;
                                 sl := rest OF sl;
                                 n := i
                            OD;
                            IF (vl ISNT nilvl)
                                 OREL (sl ISNT nilsel)
                            THEN GOTO collflt
                            FI;
                            output(XCONTROL (xendcoll, 0, qdontpull, pntomode
                                              ), outlevel);
                            freevalue(v);
                            v := (z, tomode, NIL, NIL);
                            GOTO over
                           ),
                       (REF ISTRUCT ri):
                           (m := imode OF ri;
                            n := 1
                           ),
                       (REF VCTOR rv):
                           (m := vecmode OF rv;
                            ans := dontpullbit;
                            n := 1
                           ),
                       (REF ARRAY ra):
                           (m := tomode;
                            ans := dontpullbit;
                            TO n := nods OF ra
                            DO CASE modes[m]
                                 IN (REF ARRAY ra1):
                                           m := mode OF ra1
                                 ESAC
                            OD
                           )
                  OUT GOTO collflt
                  ESAC;

                  pntomode := ismode(v, m, n);
                  IF pntomode /= tomode
                  THEN qneg := 1
                  FI;

                  CASE modes[pntomode]
                  IN (REF ISTRUCT ri):
                            m := imode OF ri
                  ESAC;

                  IF NOT newendlab ANDTH pntomode = tomode
                  THEN pntomode := - pntomode
                  FI;
                  vl := vlist OF v;
                  n := pntomode;
                  FOR i FROM 2
                  WHILE vl ISNT nilvl
                  DO elem(vl, m);
                       n := i;
                       vl := rest OF vl
                  OD;
                  output(XCONTROL (xendcoll, 0,
                                     qdontpull, pntomode
                                    ), outlevel);
                  freevalue(v);
                  coerce(v := (z, ABS pntomode, NIL, NIL),
                         ABS pntomode, tomode, all, TRUE
                        );
                  GOTO over
           FI;

 collflt:  CO collateral cannot be coerced to .1 CO
           faultp(111, tomode, 0, NIL);
   free:   freevalue(v);
           v := (z, tomode, NIL, NIL);
  over:   SKIP

    ELSE m := IF type OF vl = xbegin
                THEN tomode
                ELSE - mode OF v
                FI;
           output(XCONTROL (type OF vl, m * qneg,
                              props OF v OF vl AND notdontpull, pntomode
                             ), outlevel);
           ans := qdontpull := strong(v OF vl, -m, type OF vl /= xbegin);
           n := -1;
           WHILE vl ISNT nilvl
           DO n +:= 1;
                t := type OF vl;
                vl := rest OF vl
           OD;
           IF t = xout OREL t = xoutu
           THEN n := - n + 1
           FI;
           vl := rest OF vlist OF v;

           FOR i FROM 2 WHILE vl ISNT nilvl
           DO output(XCONTROL (type OF vl, tomode,
                                   props OF v OF vl
                                   AND notdontpull OR qdontpull, n
                                  ), outlevel);
                qdontpull := strong(v OF vl, -tomode, FALSE);
                ans := ans OR qdontpull;
                n := i;
                vl := rest OF vl
           OD;
           vl := vlist OF v;

           CO 13 = xfi - xif CO
           output(XCONTROL (type OF vl + 13, 0, qdontpull, pntomode
                             ), outlevel);
end:       freevalue(v);
           v := (z, tomode, NIL, NIL)
    FI;
    ans
END;

PROC weak = (REF VALUE v) VOID:
strong(v, weakmode(hcf(v)), TRUE);

CO ********************************************************************** CO

PROC findbiop = (REF INT lmode, rmode, ans, biop)BOOL:
IF lmode = faultmode OREL rmode = faultmode
THEN biop := -1;
       ans := faultmode;
       TRUE
ELSE INT rr := 0, l, r, b, do, a, i, version;
       BITS test;
       b := biop;
       r := pmode(rmode);
       IF b < diadiconly ANDTH lmode = 0
       THEN b +:= monadic - biplus
       FI;

       IF b >= monadic
       THEN IF lmode /= 0 THEN GOTO false FI;
              b -:= monadic;
              do := 1;
              test := test OF monops[b + 1];
              a := ans OF monops[b + 1]
       ELSE IF lmode = 0 THEN GOTO false FI;
              b -:= biplus;
              l := pmode(lmode);
              CASE modes[l]
              IN (REF ISTRUCT li):
                        l := insertvec(imode OF li, 1)
              OUT SKIP
              ESAC;

              do := do OF diops[b + 1];
              test := test OF diops[b + 1];
              a := ans OF diops[b + 1]
       FI;

       CASE modes[r]
       IN (REF ISTRUCT ri):
                 r := insertvec(imode OF ri, 1)
       OUT SKIP
       ESAC;

dolab: CASE do IN
       CO pmodes CO
            SKIP,
       CO 2 hcf CO
            (l := r := hcfoftwo(l, r, TRUE);
             IF l = 0 THEN GOTO false FI
            ),
       CO 3 upb CO
            CASE modes[r]
            IN (REF ARRAY ra):
                       IF l /= int THEN GOTO false FI
            OUT GOTO false
            ESAC,
       CO 4 ^ shl CO
            (i := l;
             l := r;
             r := i;
             IF l /= int THEN GOTO false FI;
             IF b = 33
                  CO UP CO
             THEN b := IF r >= 10 ANDTH r <= 13
                         THEN 18
                         ELSE test := 2r0000 0111 0000;
                                16
                         FI
             FI
            ),
       CO 5 elem CO
            IF l /= int THEN GOTO false FI,
       CO 6 plusab CO
            (IF b = 23 ANDTH r = int
                         ANDTH (l = vecchar OREL l = arraychar)
             THEN rr := int
             ELIF NOT coerce(NIL, r, l, all, FALSE)
             THEN GOTO false
             FI;
             r := l;
             l := makeflex(l) + refmark
            ),
       CO 7 is CO
            (l := hcfoftwo(lmode, rmode, TRUE);
             WHILE l > 0 ANDTH l < refmark
                           ANDTH CASE modes[l]
                                   IN (REF PRC p):
                                             (l := deproc OF p;
                                              TRUE
                                             )
                                   OUT FALSE
                                   ESAC
             DO SKIP OD;

             r := l;
             IF l < refmark
             THEN GOTO false
             FI
            ),
       CO 8 plusto CO
            (i := l;
             l := r;
             r := i;
             do := 6;
             GOTO dolab
            ),
       CO 9 * CO
            (i := hcfoftwo(l, r, TRUE);
             IF i >= 14 ANDTH i <= 25
             THEN rr := l := r := i
             ELIF i = 0 ANDTH (l = int OREL r = int)
             THEN i := l + r - int;
                    IF i /= char ANDTH i /= vecchar ANDTH i /= arraychar
                    THEN GOTO false
                    ELSE rr := r;
                           r := i
                    FI
             ELSE GOTO false
             FI
            )
       ESAC;

       IF test = z
       THEN version := 1
       ELSE version := 0;
              FOR i WHILE test /= z
              DO IF test >= z1
                   THEN version +:= 1;
                          IF CASE i
                               IN
                               CO bool CO
                                    r = bool,
                               CO char CO
                                    r = char,
                               CO bits CO
                                    r >= 10 ANDTH r <= 13,
                               CO int CO
                                    r = int,
                               CO lint CO
                                    r >= 14 ANDTH r <= 17,
                               CO lreal CO
                                    r >= 18 ANDTH r <= 21,
                               CO lcx CO
                                    r >= 22 ANDTH r <= 25,
                               CO vecchar CO
                                    r = vecchar,
                               CO arraychar CO
                                    r = arraychar,
                               CO vec CO
                                    CASE modes[r]
                                    IN (REF VCTOR rv):
                                               TRUE
                                    OUT FALSE
                                    ESAC,
                               CO array CO
                                    CASE modes[r]
                                    IN (REF ARRAY ra):
                                             TRUE
                                    OUT FALSE
                                    ESAC,
                               CO sten CO
                                    CASE modes[r]
                                    IN (REF STEN rs):
                                               TRUE
                                    OUT FALSE
                                    ESAC
                               ESAC
                          THEN GOTO found
                          FI
                   FI;
                   test := test SHR 1
              OD;
              GOTO false
       FI;

found:
       a := CASE - a
            IN
            CO 1 CO
                 r,
            CO 2 add long CO
                 (IF ABS (BIN r AND BIN 3) = 1
                  THEN GOTO false
                  FI;
                  r + 1
                 ),
            CO 3 sub long CO
                 (IF ABS (BIN r AND BIN 3) = 2
                  THEN GOTO false
                  FI;
                  r - 1
                 ),
            CO 4 abs CO
                 IF r <= 8
                 THEN int
                 ELIF r < 14
                 THEN r + 4
                 ELIF r < 22
                 THEN r
                 ELSE r - 4
                 FI,
            CO 5 i CO
                 22 + ABS (BIN (r + 2) AND BIN 3),
            CO 6 cx -> real -> int -> bits CO
                 r - 4,
            CO 7 plusab CO
                 l,
            CO 8 ** shr shl CO
                 (i := r;
                  r := l;
                  l := i
                 ),
            CO 9 / CO
                 IF r < 18 THEN r + 4 ELSE r FI,
            CO 10 +, * CO
                 IF r /= char THEN r ELSE vecchar FI,
            CO 11 cycle CO
                 weakmode(rmode),
            CO 12 plusto CO
                 (i := l;
                  l := r;
                  r := i
                 )
            OUT a
            ESAC;

       lmode := l;
       rmode := IF rr /= 0
                     CO possible for * or *:= CO
                THEN rr
                ELSE r
                FI;
       ans := a;
       biop := - (16 * b + version);
       TRUE
       EXIT
false:
       FALSE
FI;

PROC readcom = (INT commenttype)VOID:
BEGIN INT i, j, startcopy, endcopy;
        startcopy := IF commenttype >= rcpragmat
                     THEN tind + 1
                     ELSE 0
                     FI;

l:      WHILE IF tind = textend
                THEN IF startcopy > 0
                       THEN output(XPRAG (FALSE,
                                              textbuff[startcopy : tind]
                                             ), outlevel);
                              startcopy := 0
                       FI;
                       tind := 0;
                       IF NOT input(textbuff1, textend -:= 1)
                       THEN moreinput := FALSE;
                              abort(112)
                              CO end of file inside comment or pragmat CO
                       FI;
                       textbuff[textend +:= 1] := " "
                FI;





                i := type OF charset[ABS textbuff[tind +:= 1]];

                i < bold
        DO SKIP OD;

        i := IF i = 8
                  CO matchstrop CO
             THEN tind
             ELSE -1
             FI;
        endcopy := (tind -:= 1);
        j := primread;

        IF j < rcmatchcom OREL j >= rcnewline
        THEN IF commenttype /= j
               THEN IF i >= 0 THEN tind := i FI;
                      GOTO l
               FI
        ELIF j /= commenttype + 1 OREL j = rcmatchcom
        THEN IF ABS (BIN j AND z1) = 1
               THEN IF startcopy > 0
                      THEN output(XPRAG (FALSE,
                                             textbuff[startcopy : endcopy]
                                            ), outlevel);
                             startcopy := 0
                      FI;
                      readcom(j)
               ELSE fault(113)
                      CO comment mismatch CO
               FI;
               GOTO l
        FI;

        IF startcopy > 0
        THEN output(XPRAG (TRUE, textbuff[startcopy : endcopy]), outlevel)
        FI
END;

PROC (REF ID, INT)VOID bumodule;

PROC unlook = INT:
CASE lkinserts +:= 1
IN CO ord CO
          (IF lkmodeins = 0 THEN lkinserts := - 1 FI;
           24
          ),
     CO mode or proc CO
          (IF lkids IS nillkids
           THEN lkinserts := - 1
           FI;
           lkmodeins
          )
OUT IF (BIN lkinserts AND z1) = z
      THEN CO comma CO
             28
      ELSE CO id CO
             ident := id OF lkids;
             idhash := idhash OF lkids;
             idsize := idsize OF lkids;
             IF (lkids := rest OF lkids) IS nillkids
             THEN lkinserts := -1;
                    lkend := lkids
             FI;
             32
      FI
ESAC;

CO ********************************************************************** CO

PROC reader = (INT readertype)INT:
BEGIN
    INT i, r, t, ans, case := 0;
    REF INDIC ri;
    BOOL bb;
    ID id1;
    IF noflts > 0 ANDTH next = -1
    THEN noflts -:= 1
    FI;
    IF supflts > 0
    THEN supflts -:= 1
    FI;

    IF lkinserts < 0
    THEN l:
        IF next = -1
        THEN r := IF readertype = formatreader
                    THEN fprimread
                    ELSE primread
                    FI
        ELSE IF next < 1000
               THEN r := next
               ELSE ans := next - 900;
                      next := -1;
                      GOTO exit
               FI;
               next := -1
        FI;

        CASE r - rcnewline + 1
        IN CO newline CO
             IF input(textbuff1, textend -:= 1)
             THEN oldtind := tind := 0;
                    textbuff[textend +:= 1] := " ";
                    GOTO l
             ELSE moreinput := FALSE;
                    abort(CO end of file CO 114)
             FI,
         CO notused CO
             ans := illegaltok,
         CO ident CO
             (ans := identtok;
              IF readertype = screader
              THEN t := tind;
                     IF primread = rccolon
                     THEN ans := labeltok
                     ELSE tind := t
                     FI
              FI
             ),
         CO intexp CO
             (next := powertentok;
              ans := intdentok
             ),
         CO colon CO
              ans := IF readertype = ucreader ANDTH t1 /= 33
                          CO void CO
                     THEN colonhtok
                     ELSE colontok
                     FI

         OUT
              IF r >= biplus OREL r = otherindtok OREL r = otheroptok
              THEN ri := (indics OF globcurrent)[comphash];
                     cindic := NIL;
                     cinst := NIL;
                     cbiop := 0;
                     clibop:= FALSE;
                 aa: WHILE ri ISNT nilind
                     DO IF compsymb = name OF ri
                          THEN cindic := ri;
                                 CASE u OF ri
                                 IN (REF OPER op):
                                           (ans := illegaltok +
                                                   ABS prio OF op;
                                            cinst := i OF op;
                                            IF r >= biplus
                                            THEN cbiop := r
                                            FI;
                                            IF level OF ri /= 0
                                            THEN  { not known }
                                                  clibop:= FALSE
                                            FI
                                           ),
                                      (REF AMODE ra):
                                           (ans := modenametok;
                                            decmode := ra
                                           )
                                 OUT ans := faultindtok
                                 ESAC;
                                 GOTO out
                          ELSE ri := rest OF ri
                          FI
                     OD;
                     clibop:= FALSE;

                     IF r >= biplus
                     THEN cbiop := r;
                            ans := IF r >= monadic
                                   THEN 1
                                   ELSE prio OF diops[r - biplus + 1]
                                   FI + illegaltok
                     ELIF look = 2
                     THEN   CO library CO
                            CASE case +:= 1
                            IN ri := libinds[comphash],
                                 (bumodule(compsymb,
                                           2 + ABS NOT (typechar1 /= 3
                                                         ANDTH typechar1 /= 6)
                                          );
                                  ri := libinds[comphash]
                                 ),
                                 (ri := libinds[comphash]
                                     := HEAP INDIC
                                     := (compsymb, 1, 0, 1, libinds[comphash]);
                                  faultp(115, 0, 0, compsymb);
                                  CO .3 not recognised CO
                                  supflts := fltgap
                                 )
                            ESAC;
                            clibop:= TRUE;
                            GOTO aa
                     ELSE IF look = 1 ANDTH case = 0
                            THEN case := 1;
                                   ri := libinds[comphash];
                                   GOTO aa
                            FI;
                            ans := otherindtok
                     FI;
              out:   SKIP
              ELIF r >= illegaltok
              THEN ans := r
              ELIF r < 36
              THEN ans := r + 121
              ELIF r <= 44
                     CO ouse CO
              THEN ans := bangtok;
                     bangtype := r + 5;
                     next := colonhtok
              ELIF r <= 49
                     CO out CO
              THEN ans := bangtok;
                     bangtype := r
              ELIF r < rccrd
              THEN brackets[brind] := r + 4;
                     IF brind < 64
                     THEN brind +:= 1
                     ELSE abort(208)
                            CO too many brackets CO
                     FI;
                     ans := ordtok
              ELIF r < rccomment
              THEN IF brind <= 2
                     THEN IF brind = 2 ANDTH inprogram
                                           ANDTH r /= brackets[1]
                            THEN fault(116)
                                   CO brackets mismatch CO
                            FI
                     ELIF (t := brackets[brind -:= 1]) /= r
                     THEN IF wronglevel = brind ANDTH wrongord = r
                            THEN fault(116);
                                   CO brackets mismatch CO
                                   brind +:= 1;
                                   wrongcrd := wrongord := 0;
                                   GOTO l
                            ELIF wronglevel = brind ANDTH t = wrongcrd
                                   ANDTH brackets[brind - 1] = r
                            THEN fault(116);
                                   CO brackets mismatch CO
                                   brind -:= 1;
                                   wrongcrd := wrongord := 0
                            ELSE wrongcrd := r;
                                   wrongord := t;
                                   wronglevel := brind - 1;
                                   CO .3 expected here CO
                                   faultp(118, 0, 0,
                                          id1 := idmess(t - rccrd + 53)
                                         )
                            FI
                      FI;

                      ans := crdtok
               ELSE IF r >= rcmatchcom ANDTH r < rcpragmat
                                           ANDTH ABS (BIN r AND z1) = 0
                      THEN fault(201)
                             CO no opening comment symbol CO
                      ELSE t := tind;
                             incom := TRUE;
                             readcom(r);
                             incom := FALSE;
                             IF readertype = formatreader ANDTH tind < t
                             THEN output(XCHARS (- find, 0,
                                                     globfbuff[ : find]
                                                    ), outlevel + 1);
                                   noofstrings +:= find;
                                   find := 0
                            FI;
                            oldtind := tind
                     FI;
                     GOTO l
              FI
          ESAC;

    exit: ans - illegaltok

    ELSE unlook
    FI
END;


{ ***** BIOP 99 on VAX only,  BIOP 1001 on FLEX ***** }

OP (REF MDE) REF INT MODETAG = BIOP 99;

{ "mode too complex" restriction removed }

HEAP INT  last_flex;
REF VECTOR[]INTPAIR test_flex := HEAP VECTOR [200] INTPAIR;
           {afer equality=TRUE: iOF > jOF and are same mode}

PROC  equality =  ( INT  i, j, INT lastdone) BOOL : {mode changed}
BEGIN
         PROC  f = ( INT  i, j) VOID :
         BEGIN   INTPAIR  u;

                 INT  a :=  ABS  ( BIN  i  AND  decsmask),
                      b :=  ABS  ( BIN  j  AND  decsmask);
                 INT  c := i - a,
                      d := j - b;

                 IF  c /= d
                 THEN   GOTO  exit
                 FI ;

                 IF  a = b
                 THEN   GOTO  out
                 ELIF  a < b
                 THEN  c := a;
                       a := b;
                       b := c
                 FI ;

                IF a<= lastdone OREL MODETAG modes[a] /= MODETAG modes[b]
                   THEN GOTO exit FI;

                 FOR  y  TO  last_flex
                 DO  u := test_flex[y];
                      IF  i  OF  u = a  ANDTH  j  OF  u = b
                      THEN   GOTO  out
                      FI
                 OD ;

                IF UPB test_flex = last_flex THEN
                   REF VECTOR[]INTPAIR new =
                         HEAP VECTOR[UPB test_flex+100]INTPAIR;
                   new[:last_flex]:= test_flex; test_flex:=new
                FI;
                test_flex[last_flex +:= 1] := (a, b);
             out:  SKIP
         END ;

         INTPAIR  p;
         MDE  m2;
         REF MODELIST ml1,ml2;
         REF SELIST sl1,sl2;
        last_flex:=1;
        test_flex[1] := (i, j);

         FOR  z
         WHILE  z <= last_flex
         DO  p := test_flex[z];
             m2 := modes[j  OF  p];
              CASE  modes[i  OF  p]
              IN  ( REF  PRC  prc1):
                        CASE  m2
                        IN  ( REF  PRC  prc2):
                                f(deproc  OF  prc1, deproc  OF  prc2)
                        OUT   GOTO  exit
                        ESAC ,

                  ( REF  PROCP  p1):
                        CASE  m2
                        IN  ( REF  PROCP  p2):
                                (f(deproc  OF  p1, deproc  OF  p2);
                                   ml1 := pars  OF  p1;
                                   ml2 := pars  OF  p2;
                                  WHILE  (ml1  ISNT  nilml)
                                          ANDTH  (ml2  ISNT  nilml)
                                  DO  f(mode  OF  ml1, mode  OF  ml2);
                                      ml1 := rest  OF  ml1;
                                      ml2 := rest  OF  ml2
                                  OD ;
                                  IF  (ml1  ISNT  nilml)
                                       OREL  (ml2  ISNT  nilml)
                                  THEN   GOTO  exit
                                  FI
                                )
                        OUT   GOTO  exit
                        ESAC ,

                  ( REF  STRCT  s1):
                        CASE  m2
                        IN  ( REF  STRCT  s2):
                                ( sl1 := sels  OF  s1;
                                  sl2 := sels  OF  s2;
                                  WHILE  (sl1  ISNT  nilsel)  ANDTH
                                         (sl2  ISNT  nilsel)  ANDTH
                                         name  OF  sl1 = name  OF  sl2
                                  DO  f(mode  OF  sl1, mode  OF  sl2);
                                      sl1 := rest  OF  sl1;
                                      sl2 := rest  OF  sl2
                                  OD ;
                                  IF  (sl1  ISNT  nilsel)
                                       OREL  (sl2  ISNT  nilsel)
                                  THEN   GOTO  exit
                                  FI
                                )
                        OUT   GOTO  exit
                        ESAC ,

                  ( REF  UNN  u1):
                        CASE  m2
                        IN  ( REF  UNN  u2):
                                ( ml1 := modelist  OF  u1;
                                  ml2 := modelist  OF  u2;
                                  WHILE  (ml1  ISNT  nilml)
                                          ANDTH  (ml2  ISNT  nilml)
                                  DO  f(mode  OF  ml1, mode  OF  ml2);
                                      ml1 := rest  OF  ml1;
                                      ml2 := rest  OF  ml2
                                  OD ;
                                  IF  (ml1  ISNT  nilml)
                                       OREL  (ml2  ISNT  nilml)
                                  THEN   GOTO  exit
                                  FI
                                )
                        OUT   GOTO  exit
                        ESAC ,

                  ( REF  ARRAY  a1):
                        CASE  m2
                        IN  ( REF  ARRAY  a2):
                                 IF  nods  OF  a1 = nods  OF  a2
                                      ANDTH   IF  deflex  OF  a1 >= 0
                                              THEN  deflex  OF  a2 >= 0
                                              ELSE  deflex  OF  a2 < 0
                                              FI
                                 THEN  f(mode  OF  a1, mode  OF  a2)
                                 ELSE   GOTO  exit
                                 FI
                        OUT   GOTO  exit
                        ESAC ,

                  ( REF  ISTRUCT  is1):
                        CASE  m2
                        IN  ( REF  ISTRUCT  is2):
                                  IF  length  OF  is1 = length  OF  is2
                                  THEN  f(imode  OF  is1, imode  OF  is2)
                                  ELSE   GOTO  exit
                                  FI
                        OUT   GOTO  exit
                        ESAC ,

                  ( REF  STEN  sten1):
                        CASE  m2
                        IN  ( REF  STEN  sten2):
                                 f(mode  OF  sten1, mode  OF  sten2)
                        OUT   GOTO  exit
                        ESAC ,

                  ( REF  VCTOR  v1):
                        CASE  m2
                        IN  ( REF  VCTOR  v2):
                                  IF   IF  deflex  OF  v1 >= 0
                                       THEN  deflex  OF  v2 >= 0
                                       ELSE  deflex  OF  v2 < 0
                                       FI
                                  THEN  f(vecmode  OF  v1, vecmode  OF  v2)
                                  ELSE   GOTO  exit
                                  FI
                        OUT   GOTO  exit
                        ESAC
                OUT   GOTO  exit
                ESAC
         OD ;

         TRUE   EXIT

  exit:  FALSE
END ;




PROC mcond = (INT a, REF MODELIST ml, INT x)BOOL:
BEGIN REF MODELIST mx := ml, el;
        REF SELIST sl;
        WHILE (mx ISNT nilml) ANDTH mode OF mx /= a
        DO mx := rest OF mx OD;

        IF mx ISNT nilml
        THEN FALSE
        ELSE mx := LOC MODELIST := (a, ml);
               IF a > refmark
               THEN x = 2 OREL mcond(a - refmark, mx, 1)
               ELSE CASE modes[a]
                      IN (REF PRC p):
                               x = 2 OREL mcond(deproc OF p, mx, 1),
                           (REF STRCT s):
                               x = 1 OREL (sl := sels OF s;
                                           WHILE (sl ISNT nilsel)
                                             ANDTH mcond(mode OF sl, mx, 2)
                                           DO sl := rest OF sl OD;
                                           sl IS nilsel
                                          ),
                           (REF ARRAY ar):
                               mcond(mode OF ar, mx, x),
                           (REF VCTOR v):
                               mcond(vecmode OF v, mx, x),
                           (REF ISTRUCT is):
                               mcond(imode OF is, mx,
                                     IF length OF is = 1
                                     THEN x
                                     ELSE 2
                                     FI
                                    ),
                         (REF UNN u):
                             (el := modelist OF u;
                              WHILE (el ISNT nilml) ANDTH
                                      mcond(mode OF el, mx, x)
                              DO el := rest OF el OD;
                              el IS nilml
                             )
                      OUT TRUE
                      ESAC
               FI
        FI
END;


PROC dynamic = (REF AMODELIST aml)BOOL:
BEGIN REF AMODELIST x := aml;
        BOOL b := FALSE;
        WHILE (x ISNT nilaml) ANDTH NOT b
        DO b := b OREL IF modeproc OF am OF x = 0
                         THEN FALSE
                         ELIF modeproc OF am OF x /= 1
                         THEN TRUE
                         ELSE dynamic(el OF am OF x)
                         FI;
             x := rest OF x
        OD;
        b
END;


PROC testkept = (INT m)BOOL:
BEGIN REF MODELIST ml;
        REF SELIST sels;
        IF m > refmark
        THEN fault(119);
               CO cannot access kept containing ref CO
               TRUE
        ELSE CASE modes[m]
               IN (REF UNN u):
                        (ml := modelist OF u;
                         WHILE ml ISNT nilml
                         DO IF testkept(mode OF ml)
                              THEN GOTO true
                              ELSE ml := rest OF ml
                              FI
                         OD;
                         FALSE
                        ),
                    (REF STRCT s):
                        (sels := sels OF s;
                         WHILE sels ISNT nilsel
                         DO IF testkept(mode OF sels)
                              THEN GOTO true
                              ELSE sels := rest OF sels
                              FI
                         OD;
                         FALSE
                        ),
                    (REF ISTRUCT is):
                        testkept(imode OF is),
                    (REF VCTOR v):
                        testkept(vecmode OF v),
                    (REF ARRAY a):
                        testkept(mode OF a),
                    (REF STEN st):
                        (fault(120);
                         CO cannot access kept object containing straight CO
                         FALSE
                        )
               OUT FALSE
               ESAC
        FI
        EXIT
       true: TRUE
END;

PROC adjscope = (REF RDEN rd, INT level, scope)VOID:
BEGIN REF RDEN rd1 := rd;
        WHILE (rd1 ISNT (REF RDEN (NIL)))
                ANDTH level < level OF rd1
        DO IF maxname OF rd1 < scope
             THEN maxname OF rd1 := scope
             FI;
             rd1 := rest OF rd1
        OD
END;


INT genam = 1, decam = 2;

PROC loadmodeproc = (REF AMODE a)VOID:
BEGIN INT i = ABS modeproc OF a;
        IF i < startkmp
        THEN output(i, outlevel)
        ELSE output(i - startkmp, outlevel);
               output(XOPER (xderef, mproc(mode OF a), 0), outlevel)
        FI
END;

CO ********************************************************************** CO

PROC treatam = (REF AMODE am, INT type, scope)VOID:
BEGIN
    REF AMODELIST aml;
    REF INT mp = IF am IS nilam
                    THEN NIL
                    ELSE modeproc OF am
                    FI;

    IF (am IS nilam) OREL mode OF am = faultmode
    THEN SKIP
    ELIF mp = 1 ANDTH NOT dynamic(el OF am)
    THEN mp := 0;
           el OF am := NIL
    ELIF mp > 1 OREL mp <= - startkmp
    THEN IF type = genam THEN loadmodeproc(am) FI
    ELIF mp /= 0
    THEN
        REF INT lastid = lastid OF globcurrent;
        lastidchanged := TRUE;
        INT x := mp, m := mode OF am, i, procmode, lastid1 := lastid;
        RDEN rd := (idmess(CO generator CO 60),
                      genprocbit OR ccbit OR (type = genam ! valbit ! z),
                      mproc(m), mp := lastrd +:= 1,
                      scope, 1, NIL
                     );
        IDDEC loc := (nullid, lastid +:= 1, 1, bool, 0, NIL);

        PROC assigngen = (REF AMODE a)VOID:
        BEGIN output(xwass, outlevel);
                loadmodeproc(a);
                output(decno OF loc, outlevel);
                output(XOPER (xparampack,
                                mproc(mode OF a), 1
                               ), outlevel);
                output(XOPER (xcall, deflex(mode OF a), 3), outlevel);
                output(XOPER (xassign,
                                enflex(mode OF a) + refmark, 1
                               ), outlevel);
                output(opervoid, outlevel);
                output(controlsemi, outlevel);
                IF lastid > maxident
                THEN maxident := lastid
                FI
        END;

        PROC assignarr = (REF IDDEC id, REF AMODE a)VOID:
        BEGIN IDDEC element := (nullid, lastid +:= 1,
                                    1, 0, 0, NIL
                                   );
                INT nod;

                CASE modes[mode OF id - refmark]
                IN (REF ARRAY arr):
                          (nod := nods OF arr;
                           mode OF element := IF nod = 1
                                                THEN enflex(mode OF arr)
                                                ELSE mode OF arr
                                                FI + refmark
                          ),
                     (REF VCTOR v):
                          (nod := 1;
                           mode OF element := enflex(vecmode OF v) + refmark
                          )
                ESAC;

                output(xwforall, outlevel);
                output(XCONTROL (xforall, 0, compgenbit, 1), outlevel);
                output(XIDDEC (xforalldec, element), outlevel);
                output(XCONTROL (xdo, voidmode,
                                   compgenbit OR semibit, 0
                                  ), outlevel);
                output(decno OF element, outlevel);
                IF nod = 1
                THEN assigngen(a)
                ELSE assignarr(element, a)
                FI;
                output(XCONTROL (xod, voidmode, compgenbit, 0), outlevel);
                output(controlsemi, outlevel);
                lastid -:= 1
        END;

        output(rd, outlevel);
        output(XIDDEC (xfdec, loc), outlevel);
        output(XCONTROL (xbegin, m, compgenbit OR semibit, m), outlevel);

        IF x < 0
        THEN output(down, outlevel);
               output(decno OF loc, outlevel);
               output(XOPER (xdyngrab, deflex(m), 0), outlevel);
               IF dynamic(el OF am)
               THEN REF AMODE amel = am OF el OF am;
                      IDDEC array := (nullid, lastid +:= 1, 1,
                                        enflex(m) + refmark, 0, NIL
                                       );
                      output(XIDDEC (xivardec, array), outlevel);
                      treatam(amel, decam, scope);
                      output(decno OF array, outlevel);
                      assignarr(array, amel);
                      output(decno OF array, outlevel);
                      output(XOPER (xderef, m, 0), outlevel)
               FI
        ELIF m /= faultmode
        THEN aml := el OF am;
               WHILE aml ISNT nilaml
               DO treatam(am OF aml, decam, scope);
                    aml := rest OF aml
               OD;
               CASE modes[m]
               IN (REF STRCT st):
                         (REF SELIST s := sels OF st;
                          REF AMODELIST aml := el OF am;
                          IDDEC struct := (nullid, lastid +:= 1, 1,
                                             enflex(m) + refmark,
                                             0, NIL
                                            );
                          output(XIDDEC (xvardec, struct), outlevel);

                          WHILE aml ISNT nilaml
                          DO WHILE (s ISNT nilsel)
                                    ANDTH mode OF s /= mode OF am OF aml
                               DO s := rest OF s OD;

                               IF s ISNT nilsel
                               THEN IF modeproc OF am OF aml /= 0
                                      THEN output(decno OF struct,
                                                    outlevel
                                                   );
                                             output(XOPER (xselect,
                                                             enflex(mode OF s)
                                                             + refmark,
                                                             fieldno OF s
                                                            ), outlevel);
                                             assigngen(am OF aml)
                                      FI;
                                      s := rest OF s
                               FI;
                               aml := rest OF aml
                          OD;
                          output(decno OF struct, outlevel)
                         ),
                    (REF ISTRUCT is):
                         (INT i := insertvec(enflex(imode OF is), 1);
                          IDDEC istruct := (nullid, lastid +:= 1, 1,
                                              enflex(m) + refmark,
                                              0, NIL
                                             ),
                                  element := (nullid, lastid +:= 1, 1,
                                              i + refmark, 0, NIL
                                             );
                          output(XIDDEC (xvardec, istruct), outlevel);
                          output(decno OF istruct, outlevel);
                          output(XOPER (xisvec, i + refmark, 0), outlevel);
                          assignarr(element, am OF el OF am);
                          output(decno OF istruct, outlevel)
                         )
               ESAC;
               output(XOPER (xderef, m, 0), outlevel)
        FI;
        output(XCONTROL (xend, 0, compgenbit OR dontpullbit, m), outlevel);
        output(XCONTROL (xroutinend, 0,
                           genprocbit OR compgenbit
                                      OR (type = genam ! valbit ! z),
                           0
                          ), outlevel);
        IF lastid > maxident
        THEN maxident := lastid
        FI;
        lastid := lastid1
    FI
END;


PROC modevars = (REF AMODELIST aml)VOID:
BEGIN REF AMODELIST a := NIL, b := aml, l;
        REF REF AMODELIST rb;
        REF INT lastid = lastid OF globcurrent;
        REF AMODE am;
        REF INT mp;
        IDDEC n;
        INT x;

        WHILE b ISNT nilaml
        DO am := am OF b;
             mp := modeproc OF am;
             IF mp < 0 OREL mp = 1 ANDTH dynamic(el OF am)
             THEN l := rest OF b;
                    rest OF b := a;
                    a := b;
                    b := l
             ELSE IF mp = 1 THEN (REF INT (mp)) := 0 FI;
                    b := rest OF b
             FI
        OD;

        b := a;
        WHILE b ISNT nilaml
        DO am := am OF b;
             mp := modeproc OF am;
             n := (nullid, lastid +:= 1, 1,
                   mproc(mode OF am) + refmark, 0, NIL
                  );
             IF mp < 0
             THEN rb := rest OF b;

                    WHILE rb ISNT nilaml
                    DO IF modeproc OF am OF rb = mp
                         THEN modeproc OF am OF rb := lastid + startkmp;
                                (REF REF AMODELIST (rb)) := rest OF rb
                         ELSE rb := rest OF rb
                         FI
                    OD
             FI;

             output(XIDDEC  (xvardec, n), outlevel);
             (REF INT (mp)) := IF mp < 0
                                  THEN - lastid - startkmp
                                  ELSE lastid + startkmp
                                  FI;
             b := rest OF b
        OD;

        WHILE a ISNT nilaml
        DO am := am OF a;
             a := rest OF a;
             x := ABS modeproc OF am - startkmp;
             output(x, outlevel);
             output(xwass, outlevel);
             modeproc OF am := IF modeproc OF am < 0
                                 THEN - 2
                                 ELSE 1
                                 FI;
             treatam(am, genam, lastid OF globcurrent);
             modeproc OF am := x + startkmp;
             output(XOPER (xassign,
                             mproc(mode OF am) + refmark, 1
                            ), outlevel);
             output(opervoid, outlevel);
             output(controlsemi, outlevel)
        OD
END;

   PROC  substitute = ( INT  i, j,INT from)  VOID :   CO  i may have refs  CO
                {mode changed}
   BEGIN   INT  m = i - j, md = deflex(i) - j;
           SAMEAS  asa;
          mode  OF  asa := i;
           REF  MODELIST  ml :=  NIL ;
           REF  INT  r :=  NIL ;
           REF  SELIST  sl;

           PROC  subam = ( REF  AMODELIST  am)  VOID :
           BEGIN   REF  AMODELIST  aml := am;

                   WHILE  aml  ISNT  nilaml
                   DO   REF  INT  ri = mode  OF  am  OF  aml;
                        INT  i = ri;
                        IF  i /= - 1
                        THEN  ri := - 1;
                              subam(el  OF  am  OF  aml);
                              ri := i;
                               IF  ( BIN  i  AND  decsmask) =  BIN  j
                               THEN  ri  PLUSAB  m
                               FI
                        FI ;
                       aml := rest  OF  aml
                   OD
           END ;

           PROC  subd = ( REF  INT  m)  VOID :
           IF  m = j
           THEN  m := i
           ELIF  m = - j
           THEN  m := - i
           FI ;

           FOR  k  FROM from TO  lastmode
           DO   IF  k = j
                THEN  modes[k] := asa
                ELSE   CASE  modes[k]
                       IN  ( REF  STRCT  s):
                               (sl := sels  OF  s;
                                subd(deflex  OF  s);

                                 WHILE  sl  ISNT  nilsel
                                 DO   IF  ( BIN  mode  OF  sl  AND  decsmask)
                                          =  BIN  j
                                      THEN   mode  OF  sl  PLUSAB  m
                                      FI ;
                                     sl := rest  OF  sl
                                 OD
                               ),
                           ( REF  VCTOR  v):
                               (subd(deflex  OF  v);
                                r := vecmode  OF  v
                               ),
                           ( REF  ISTRUCT  is):
                               (subd(deflex  OF  is);
                                r := imode  OF  is
                               ),
                           ( REF  PRC  p):
                               r := deproc  OF  p,
                           ( REF  UNN  u):
                               ml := modelist  OF  u,
                           ( REF  PROCP  pp):
                               (r := deproc  OF  pp;
                                ml := pars  OF  pp
                               ),
                           ( REF  ARRAY  a):
                               (subd(deflex  OF  a);
                                r := mode  OF  a
                               ),
                           ( REF  STEN  stn):
                               r := mode  OF  stn
                       OUT   SKIP
                       ESAC ;

                       IF  (r  ISNT  nilint)
                            ANDTH  ( BIN  r  AND  decsmask) =  BIN  j
                       THEN  r +:= m;
                             r :=  NIL
                       FI ;

                       WHILE  ml  ISNT  nilml
                       DO   IF  ( BIN  mode  OF  ml  AND  decsmask) =  BIN  j
                            THEN  mode  OF  ml +:=  IF  mode  OF  ml < refmark
                                                    THEN  md
                                                    ELSE  m
                                                    FI
                            FI ;
                           ml := rest  OF  ml
                       OD
               FI
           OD ;
          subam(untreated)
   END ;



   PROC  checkmodes = ( REF  AMODELIST  aml) VOID :
   BEGIN   REF  AMODELIST  a := aml;
           BOOL  b :=  TRUE ;
           WHILE  a  ISNT  nilaml
           DO   IF   NOT  mcond(mode  OF  am  OF  a,  NIL , 0)
                THEN  faultp(121, mode  OF  am  OF  a, 0,  NIL );
                       CO  .1 is not a legal mode  CO
                      substitute(faultmode,
                                 ABS  ( BIN  mode  OF  am  OF  a  AND  decsmask)
                                , newmode1
                               );
                     untreated :=  NIL
               FI ;
              a := rest  OF  a
          OD
   END ;


   PROC  removedupl = ( REF  MODELIST  m) VOID :
   BEGIN   INT  mode;
           REF  MODELIST  m1 := m;
           REF  REF  MODELIST  m2;
           WHILE  m1  ISNT  nilml
           DO  mode := mode  OF  m1;
               m2 := rest  OF  m1;
                WHILE  m2  ISNT  nilml
                DO   IF  mode  OF  m2 = mode
                     THEN  ( REF  REF  MODELIST  (m2)) := rest  OF  m2
                     ELSE  m2 := rest  OF  m2
                     FI
                OD ;
               m1 := rest  OF  m1
           OD
   END ;

   PROC  flattenunion = ( REF  UNN  u, VECTOR[]INT done) REF  MODELIST :
            {mode changed}
   BEGIN   REF  MODELIST  n, p;
           REF  REF  MODELIST  rm := modelist  OF  u;
           WHILE  rm  ISNT  nilml
           DO   IF  mode  OF  rm < refmark
                THEN   CASE  modes[mode  OF  rm]
                       IN  ( REF  UNN  uu):
                                (FORALL di IN done DO
                                   IF di = modeOFrm THEN
                                    faultp(121, mode  OF rm, 0,  NIL );
                                    GOTO end
                                   FI
                                 OD;
                                 VECTOR[UPB done+1]INT new;
                                 new[:UPB done]:=done; new[UPB new]:= modeOFrm;
                                 n := flattenunion(uu,new);
                                 p := rest  OF  rm;
                                  WHILE  n  ISNT  nilml
                                  DO  ( REF  REF  MODELIST  (rm)) :=
                                       HEAP  MODELIST  := (mode  OF  n,  NIL );
                                      rm := rest  OF  rm;
                                      n := rest  OF  n
                                  OD ;
                                 ( REF  REF  MODELIST  (rm)) := p
                                )
                       OUT  rm := rest  OF  rm
                       ESAC
                ELSE  rm := rest  OF  rm
                FI
           OD ;
       end: modelist  OF  u
   END ;



   PROC accidental_eqs = (REF[]MDE mds)VOID:  {new proc}
   ( INT u = UPB mds, l = LWB mds;
     [l:u]INT ind {index in mds};
     [l:u]INT classno {class of mode};
     FOR i FROM l TO u DO ind[i]:=i; classno[i]:=1 OD;
                       {all mds in initially same class}
     VECTOR[u-l+1]INTPAIR classes {iOF..jOf in same calll};

     PROC f = (INT ma,mb)BOOL:
     (INT a = ABS (BIN ma AND decsmask), b = ABS(BIN mb AND decsmask);
      ma = mb OREL
       (a >= l) ANDTH (b>=l) ANDTH (ma-a) = (mb-b) ANDTH
       (classno[a] = classno[b])
     );
     PROC flist = (REF MODELIST mx,my)BOOL:
     ( REF MODELIST slx := mx, sly:=my;
       WHILE (slx ISNT nilml) ANDTH (sly ISNT nilml) ANDTH
             f(modeOFslx,modeOFsly)
       DO slx:=restOFslx; sly:=restOFsly
       OD;
       (slx IS nilml) ANDTH (sly IS nilml)
     );

     INT nc:=1,x,y;
     REF INTPAIR alter;
     classes[1]:=(l,u);
     BOOL change:=TRUE;
     WHILE change DO
       change:=FALSE;
       x:=1;
       WHILE x <= nc DO
         REF INTPAIR cx = classes[x];
         IF iOFcx<jOFcx THEN
           REF MDE mx = mds[ind[iOFcx]];
           CASE mx IN
            (SAMEAS): iOFcx+:=1
           OUT
            alter:=NIL;
            y:=iOFcx+1;
            WHILE y <= jOFcx DO
              REF MDE my = mds[ind[y]];
              CASE my IN
               (SAMEAS): (change:= TRUE;
                          INT z = ind[jOFcx];
                          ind[jOFcx]:= ind[y];
                          ind[y]:=z;
                          jOFcx-:=1
                         )
              OUT IF MODETAG mx = MODETAG my ANDTH
                     CASE mx IN
                      (REF PRC px):
                         CASE my IN
                          (REF PRC py) f(deprocOFpx,deprocOFpy)
                         OUT FALSE
                         ESAC,
                      (REF PROCP px)
                         CASE my IN
                          (REF PROCP py) f(deprocOFpx,deprocOFpy) ANDTH
                                         flist(parsOFpx,parsOFpy)
                         OUT FALSE
                         ESAC,
                      (REF STRCT sx)
                         CASE my IN
                          (REF STRCT sy)
                            (REF REF SELIST
                                 slx = HEAP REF SELIST:= selsOFsx,
                                 sly = HEAP REF SELIST:=selsOFsy;
                             WHILE (slx ISNT nilsel) ANDTH
                                   (sly ISNT nilsel) ANDTH
                                   name  OF  slx = name  OF  sly ANDTH
                                   f(modeOFslx,modeOFsly)
                             DO slx:=restOFslx; sly:=restOFsly
                             OD;
                             (slx IS nilsel) ANDTH (sly IS nilsel)
                            )
                         OUT FALSE
                         ESAC,
                      (REF UNN ux)
                         CASE my IN
                          (REF UNN uy)  flist(modelistOFux,modelistOFuy)
                         OUT FALSE
                         ESAC,
                      (REF ARRAY ax)
                         CASE my IN
                          (REF ARRAY ay) nodsOFax = nodsOFay ANDTH
                                         f(modeOFax,modeOFay)
                         OUT FALSE
                         ESAC,
                      (REF ISTRUCT ix)
                         CASE my IN
                          (REF ISTRUCT iy) lengthOFix = lengthOFiy ANDTH
                                           f(imodeOFix,imodeOFiy)
                         OUT FALSE
                         ESAC,
                      (REF STEN sx)
                         CASE my IN
                          (REF STEN sy)  f(modeOFsx,modeOFsy)
                         OUT FALSE
                         ESAC,
                      (REF VCTOR vx)
                         CASE my IN
                          (REF VCTOR vy)  f(vecmodeOFvx,vecmodeOFvy)
                         OUT FALSE
                         ESAC
                     OUT FALSE
                     ESAC
                  THEN y+:=1
                  ELSE change:= TRUE;
                       INT z = ind[jOFcx];
                       ind[jOFcx]:= ind[y];
                       ind[y]:=z;
                       IF alter IS (REF INTPAIR (NIL)) THEN
                         alter:= classes[nc+:=1];
                         (REF INTPAIR (alter)):= (jOFcx,jOFcx)
                       ELSE iOFalter:= jOFcx
                       FI;
                       jOFcx-:=1
                  FI
              ESAC
            OD;
            IF alter ISNT (REF INTPAIR (NIL))
            THEN  FOR i FROM i OF alter TO j OF alter
                  DO  classno [ind[i]]:= nc  OD
            FI;
            x+:=1
           ESAC
         ELSE x+:=1
         FI
       OD
     OD  {now each class different mode};

     FORALL ci IN classes[:nc] DO
       IF iOFci<jOFci THEN
         INT nm = ind[iOFci];
         FOR i FROM iOFci+1 TO jOFci DO
           substitute(nm,ind[i],l)
         OD
       FI
     OD
   );


CO ********************************************************************** CO

PROC assign = (INT mode) VOID:
CO operands have been loaded; mode is without the ref CO
BEGIN
    INT i, m;
    REF SELIST sels;
    REF INT lastid = lastid OF globcurrent;

    i := ABS assmarker(mode);

    IF mode = xtype OREL mode = ytype
    THEN fault(190)
           CO objects of mode xtype or ytype cannot be assigned CO
    ELIF i <= 2
    THEN IF i = 2 ANDTH (m := deflex(mode)) /= mode
           THEN output (XOPER(xcopy, m, 0), outlevel);
                  i := 1
           FI;
           output(XOPER (xassign, mode + refmark, i), outlevel)
    ELSE
        IF i = 3
        THEN INT lastid1 = lastid;
               lastidchanged := TRUE;
               RDEN rd := (idmess(61), CO assignment CO
                             ccbit OR globscopebit,
                             insertassmntproc(mode),
                             i := lastrd +:= 1, 0, 0, NIL
                            );
               IDDEC forall1, forall2,
                       lhs := (nullid, lastid +:= 1, 1,
                               mode + refmark, 0, NIL
                              ),
                       rhs := (nullid, lastid +:= 1, 1,
                               deflex(mode), 0, NIL
                              );

               PROC fass = VOID:
               BEGIN output(decno OF lhs, outlevel);
                       output(xwass, outlevel);
                       output(decno OF rhs, outlevel);
                       output(XOPER (xcopy, mode OF rhs, 0), outlevel);
                       output(XOPER (xassign, mode + refmark,1), outlevel)
               END;

               output(rd, outlevel);
               output(XIDDEC (xfdec, lhs), outlevel);
               output(XIDDEC (xfdec, rhs), outlevel);
               output(XCONTROL (xbegin, mode + refmark,
                                  compgenbit OR semibit, mode + refmark
                                 ), outlevel);
               BEGIN
                   CASE modes[mode]
                   IN (REF STRCT rs):
                            (rdenno OF rs := IF rdenno OF rs < 0
                                               THEN - lastrd
                                               ELSE lastrd
                                               FI;
                             sels := sels OF rs;
                             FOR i
                             WHILE sels ISNT nilsel
                             DO output(decno OF lhs, outlevel);
                                  output(XOPER (xselect,
                                                  mode OF sels + refmark, i
                                                 ), outlevel);
                                  IF ABS marker(mode OF sels) <= 2
                                  THEN output(xwass, outlevel)
                                  FI;
                                  output(decno OF rhs, outlevel);
                                  output(XOPER (xselect,
                                                  deflex(mode OF sels), i
                                                 ), outlevel);
                                  assign(mode OF sels);
                                  output(opervoid, outlevel);
                                  output(controlsemi, outlevel);
                                  sels := rest OF sels
                             OD
                            ),
                        (REF VCTOR rv):
                            (m := vecmode OF rv;
                             rdenno OF rv := (rdenno OF rv < 0
                                               ! -lastrd
                                               ! lastrd
                                               );
                             IF deflex OF rv < 0
                             THEN fass;
                                    m := enflex(m);
                                    GOTO loopf
                             ELSE GOTO loop
                             FI
                            ),
                        (REF ISTRUCT ri):
                            (m := insertvec(imode OF ri, 1);
                             rdenno OF ri := IF rdenno OF ri < 0
                                               THEN -lastrd
                                               ELSE lastrd
                                               FI;
                             output(decno OF lhs, outlevel);
                             output(XOPER (xisvec, m + refmark, 0), outlevel);
                             IF ABS marker(m) <= 2
                             THEN output(xwass, outlevel)
                             FI;
                             output(decno OF rhs, outlevel);
                             output(XOPER (xisvec, m, 0), outlevel);
                             assign(m);
                             output(opervoid, outlevel);
                             output(controlsemi, outlevel)
                            ),
                        (REF ARRAY ra):
                            (m := mode OF ra;
                             rdenno OF ra := IF rdenno OF ra < 0
                                               THEN -lastrd
                                               ELSE lastrd
                                               FI;
                             IF deflex OF ra < 0
                             THEN fass;
                                    TO nods OF ra - 1
                                    DO CASE modes[m]
                                         IN (REF ARRAY a1):
                                                      m := mode OF a1
                                         ESAC
                                    OD;
                                    m := enflex(m);
                                    FOR i TO nods OF ra - 1
                                        DO m := insertarray(m, i, 1) OD;
                                    GOTO loopf
                            ELSE GOTO loop
                            FI
                           ),
                        (REF STEN rs):
                           fault(122),
                           CO straight cannot be assigned CO
                        (REF UNN ru):
                            (REF MODELIST ml := modelist OF ru;
                             INT caseno := 1, maxcase := 0;
                             IDDEC ccdec := (nullid, lastid +:= 1,
                                               1, 0, 0, NIL
                                              );
                             rdenno OF ru := IF rdenno OF ru < 0
                                               THEN - lastrd
                                               ELSE lastrd
                                               FI;
                             output(decno OF lhs, outlevel);
                             output(xwass, outlevel);
                             output(decno OF rhs, outlevel);
                             output(XOPER (xassign, mode+refmark, 1), outlevel);
                             output(opervoid, outlevel);
                             output(controlsemi, outlevel);

                             WHILE ml ISNT nilml
                             DO IF ABS marker(mode OF ml) /= 1
                                  THEN maxcase +:= 1
                                  FI;
                                  ml := rest OF ml
                             OD;
                             output(XCONTROL (xcaseu, mode,
                                                compgenbit, voidmode
                                               ), outlevel);
                             output(decno OF rhs, outlevel);
                             ml := modelist OF ru;
                             FOR i
                             WHILE ml ISNT nilml
                             DO IF ABS marker(mode OF ml) /= 1
                                  THEN mode OF ccdec := mode OF ml;
                                         output(XCONTROL (IF caseno = 1
                                                            THEN xinu
                                                            ELSE xcommau
                                                            FI,
                                                            voidmode,
                                                            compgenbit,
                                                            IF caseno = 1
                                                            THEN - maxcase
                                                            ELSE caseno
                                                            FI
                                                           ), outlevel);
                                         output(XCONTROL (xuchoice,
                                                            mode OF ml,
                                                            decbit OR
                                                                compgenbit, i
                                                           ), outlevel);
                                         output(XIDDEC (xccdec,
                                                          ccdec
                                                         ), outlevel);
                                         output(decno OF lhs, outlevel);
                                         output(XOPER (xdeunite,
                                                     (m := enflex(mode OF ml))
                                                         + refmark,
                                                         0
                                                        ), outlevel);
                                         IF ABS marker(m) <= 2
                                         THEN output(xwass, outlevel)
                                         FI;
                                         output(decno OF ccdec, outlevel);
                                         assign(m);
                                         output(opervoid, outlevel);
                                         caseno +:= 1
                                 FI;
                                 ml := rest OF ml
                             OD;
                             output(XCONTROL (xoutu, voidmode,
                                                compgenbit, maxcase + 1
                                               ), outlevel);
                             output(skip, outlevel);
                             output(opervoid, outlevel);
                             output(XCONTROL (xesacu, voidmode,
                                                compgenbit, voidmode
                                               ), outlevel);
                             output(controlsemi, outlevel)
                            )
                   ESAC
                   EXIT

             loop: output(decno OF lhs, outlevel);
            loopf: forall1 := (nullid, lastid +:= 1, 1,
                               m + refmark, 0, NIL
                              );
                   forall2 := (nullid, lastid +:= 1, 1, m, 0, NIL);

                   output(xwforall, outlevel);
                   output(decno OF rhs, outlevel);
                   output(xwforall, outlevel);
                   output(XCONTROL (xforall, 0, compgenbit, 2), outlevel);
                   output(XIDDEC (xforalldec, forall2), outlevel);
                   output(XIDDEC (xforalldec, forall1), outlevel);
                   output(XCONTROL (xdo, voidmode,
                                      compgenbit OR semibit, 0
                                     ), outlevel);
                   output(decno OF forall1, outlevel);
                   IF ABS marker(m) <= 2
                   THEN output(xwass, outlevel)
                   FI;
                   output(decno OF forall2, outlevel);
                   assign(m);
                   output(opervoid, outlevel);
                   output(controlsemi, outlevel);
                   output(XCONTROL (xod, 0, compgenbit, 0), outlevel);
                   output(controlsemi, outlevel)
               END;
               output(decno OF lhs, outlevel);
               output(XCONTROL (xend, 0, compgenbit, mode + refmark),
                      outlevel
                     );
               output(XCONTROL (xroutinend, 0, compgenbit, 0), outlevel);
               IF lastid > maxident
               THEN maxident := lastid
               FI;
               lastid := lastid1
        FI;
        output (XOPER (xparampack, insertassmntproc(mode), 2), outlevel);
        output(i, outlevel);
        output(XOPER (xcall, mode + refmark, 0), outlevel)
    FI
END;

PROC findproxy = (REF ID ident)REF PROXYL:
BEGIN REF REF PROXYL rprl := prl;
        REF PROXYL ans;

        WHILE (rprl ISNT nilprl) ANDTH ident /= name OF rprl
        DO rprl := rest OF rprl OD;

        IF rprl IS nilprl
        THEN CO here .3 not declared or used twice CO
               faultp(123, 0, 0, ident);
               ans := HEAP PROXYL := (ident, 0, NIL)
        ELSE ans := rprl;
               (REF REF PROXYL (rprl)) := rest OF rprl
        FI;
        ans
END;

INT maxchar2 = maxchar * maxchar;


   PROC  simplespec = ( BOOL  bu,  REF  VECTOR [] REF  IDDEC  ids,
                        REF  VECTOR [] REF  INDIC  inds,  REF  INT  ndno,
                        INT  scope,  REF  VECTOR [] CHAR  ka
                      ) VOID :
   BEGIN   HEAP INT  ki := 1;

           HEAP INT  basemode := lastmode + 1;

           HEAP INT nomem:=0;
           MODE MODEMEM = VECTOR[nomem+10]REF INT;
           HEAP REF MODEMEM modemem := HEAP MODEMEM;
           PROC remember = (REF INT modepos)VOID:
            IF ABS (BIN modepos AND decsmask) >= basemode THEN
             IF nomem = UPB modemem THEN
                REF MODEMEM temp = HEAP MODEMEM;
                temp[:nomem]:= modemem; modemem:=temp
              FI;
              modemem[nomem+:=1]:=modepos
            FI;

           PROC repmode = (INT old,new)VOID:
            FORALL mmi IN modemem[:nomem] DO
              INT r = ABS(BIN mmi AND decsmask);
              IF r = old THEN
                (REF INT (mmi) ) := new+mmi-r
              FI
            OD;

           SAMEAS  asa;
           HEAP INT noids := 0;
           MODE IDMEM = VECTOR[noids+10]REF IDDEC;
           REF IDMEM allids := HEAP IDMEM;

           PROC  rc =  INT :
           BEGIN   INT  c =  ABS  ka[ki];
                  ki  PLUSAB  1;
                  c
           END ;

           PROC  rw =  INT :
           BEGIN   INT  c =  ABS  ka[ki] * maxchar +  ABS  ka[ki + 1];
                  ki  PLUSAB  2;
                  c
           END ;

           PROC  rs = ( REF  ID  id) INT :
           BEGIN   INT  u =  ABS  ka[ki],
                        l = IF u > maxid THEN  maxid  ELSE  u  FI;
                   INT  i := 0;
                   FOR  j  TO  l
                   WHILE  ka[ki + j] /= " "
                   DO  i +:=  ABS  ka[ki + j]  OD ;

                   REF  VECTOR [] CHAR  n = id;
                  id := spaces;
                  n[ : l] :=  ka[ki + 1 : ki + l];
                  ki  PLUSAB  (u + 1);
                  1 +  ABS  ( BIN  i  AND   16r3f)
           END ;


           PROC  unnumber = ( INT  mode) INT :
           BEGIN   INT  m :=  ABS  ( BIN  mode  AND  decsmask), n;

                   IF  m < 100
                   THEN  mode
                   ELSE  n := m;
                         m := m + basemode - 100;
                     aa:
                          CASE  modes[m]
                          IN  ( SAMEAS  sa):
                                    (m := mode  OF  sa;
                                      GOTO  aa
                                    )
                          OUT   SKIP
                          ESAC ;
                         m + mode - n
                   FI
           END ;

           PROC  readmodes = INT :
           BEGIN   INT  firstmode := lastmode - basemode + 101, i, j, k;
                   PRC  prc;
                   REF  SELIST  sl;
                   REF  REF  SELIST  rsl;

                   PROC  rm =  INT :
                   BEGIN   INT  m := rw, n :=  ABS  ( BIN  m  AND  decsmask);
                           IF  n >= firstmode
                           THEN  m - 100 + basemode
                           ELSE  unnumber(m)
                           FI
                   END ;

                   PROC  rml =  REF  MODELIST :
                   BEGIN   INT  i := rc;
                           REF  MODELIST  ml;
                           REF  REF  MODELIST  rrml := ml;
                           TO  i
                           DO  ( REF  REF  MODELIST  (rrml)) :=  HEAP  MODELIST
                                                            := (rm,  NIL );
                               remember(modeOFrrml);
                               rrml := rest  OF  rrml
                           OD ;
                          ml
                   END ;

                   WHILE  (i := rc) > 5
                   DO  k := rw - 100 + basemode;
                       modes[k] :=  CASE  i - 5
                                   IN  (
                                         REF PRC prc = HEAP  PRC;
                                         remember(deproc  OF  prc := rm);
                                         prc
                                       ),
                                       ( REF PROCP hp =HEAP  PROCP;
                                        remember(deproc  OF  hp := deflex(rm));
                                         CO  the deflex is present in case this
                                             is a generating procedure whose
                                             mode has been kept incorrectly
                                         CO
                                        pars  OF  hp := rml;
                                        hp
                                       ),
                                        HEAP  UNN  := (0, rml),

                                       (rsl := sl;
                                         FOR  i  TO  rc
                                         DO  ( REF  REF  SELIST  (rsl))
                                                  :=  HEAP  SELIST ;
                                             fieldno  OF  rsl := i;
                                             remember(mode  OF  rsl := rm);
                                             rs(name  OF  rsl);
                                             rest  OF  rsl :=  NIL ;
                                             rsl := rest  OF  rsl
                                         OD ;
                                         HEAP  STRCT  := (0, 1, sl)
                                       ),

                                       ( REF ISTRUCT hi = HEAP  ISTRUCT;
                                        rdenno  OF  hi := 0;
                                        remember(imode  OF  hi := rm);
                                        length  OF  hi := rc * maxchar2;
                                        length  OF  hi +:= rw;
                                        deflex  OF  hi := 1;
                                        hi
                                       ),
                                       ( REF VCTOR hv =HEAP  VCTOR ;
                                        rdenno  OF  hv := 0;
                                        remember(vecmode  OF  hv := rm);
                                        deflex  OF  hv := rc - 1;
                                        hv
                                       ),
                                       ( REF ARRAY ha =HEAP  ARRAY ;
                                        rdenno  OF  ha := 0;
                                        remember(mode  OF  ha := rm);
                                        nods  OF  ha := rc;
                                        deflex  OF  ha := rc - 1;
                                        ha
                                       ),
                                       ( HEAP  STEN s  := (rm,  NIL );
                                         remember(modeOFs);
                                         s
                                       )
                                   ESAC ;
                        IF  k > lastmode
                        THEN  lastmode := k
                        FI
                   OD ;

                  i
           END ;


           REF  IDDEC  id;
           REF  INDIC  ind;
           REF  AMODE  am;
           REF  OPER  oper;
           REF  INST  inst;
           ID  tempid;
           INT  hash, i;

           WHILE  ki <  UPB  ka
           DO  i := readmodes;
               hash := rs(tempid);
                IF  i <= 2
                THEN   INT  x =  IF  i = 1
                                 THEN  ndno +:= 1
                                 ELSE  - rw
                                 FI ;
                      ids[hash] := id :=  HEAP  IDDEC
                                := (tempid, x,
                                    0, unnumber(rw), scope, ids[hash]
                                   )
                ELSE
                      ind := inds[hash];

                       WHILE  (ind  ISNT  nilind)
                              ANDTH  name  OF  ind /=  tempid
                       DO  ind := rest  OF  ind  OD ;
                       IF  ind  IS  nilind
                       THEN  ind := inds[hash] :=  HEAP  INDIC  :=
                                    (tempid, 0, scope, am, inds[hash])
                       FI ;
                       IF  i = 3
                       THEN  u  OF  ind := am :=  HEAP  AMODE  :=
                                                 (unnumber(rw), 0,  NIL );
                              remember(modeOFam);
                              IF  rc = 0
                              THEN  id :=  NIL
                              ELSE
                               id:= HEAP IDDEC
                                   := (tempid,modeprocOFam:=ndno+:=1,0,
                                        mproc(modeOFam), scope, NIL)

                              FI
                       ELSE   CASE  u  OF  ind
                              IN  ( REF  OPER  op):
                                       oper := op,
                                  ( REF  AMODE  a):
                                       u  OF  ind := oper
                                                  :=  HEAP  OPER  := (0,  NIL )
                              ESAC ;
                             prio  OF  oper := rc;
                              INT  x, y, z;
                             x := unnumber(rw);
                             y := unnumber(rw);
                             z := unnumber(rw);

                             i  OF  oper := inst
                                         :=  HEAP  INST
                                         := (x, y, z, 0,
                                              IF  i = 4
                                              THEN  ndno +:= 1
                                              ELSE  id := nilid;
                                                    - rw
                                              FI ,
                                             scope, i  OF  oper
                                            );

                            remember(lmodeOFinst);
                            remember(rmodeOFinst);
                            remember(ansOFinst);
                            IF i = 4 THEN
                              id:= HEAP IDDEC := (tempid,ndno,0,
                                                    opproc(inst),scope, NIL)
                            FI
                       FI
                FI ;

                IF  (id  ISNT  nilid)  ANDTH  i /= 2
                THEN  {output( XTDEC  (bu, modulelevel, id), 2) later}
                    remember(modeOFid);
                    IF noids = UPB allids THEN
                      REF IDMEM temp = HEAP IDMEM;
                      temp[:noids]:= allids; allids:=temp
                    FI;
                    allids[noids+:=1]:=id
                FI
           OD ;


           FOR i FROM basemode TO lastmode DO
            CASE modes[i] IN
             (SAMEAS): SKIP
            OUT
             FOR j FROM newmode1 TO basemode-1
              WHILE IF   MODETAG modes[i]= MODETAG modes[j] ANDTH
                         equality(i, j,basemode-1)
                    THEN FORALL pi IN test_flex[:last_flex] DO
                          repmode(iOFpi,jOFpi);
                          modeOFasa:=jOFpi; modes[iOFpi]:=asa
                         OD;
                         FALSE
                    ELSE TRUE
                    FI
             DO SKIP OD
            ESAC
           OD;

           ki:=0;
           i:= basemode;
           WHILE i<=lastmode DO
            CASE modes[i] IN
              (SAMEAS s) (IF ki = 0 THEN ki:=i FI; i+:=1)
            OUT
             IF ki/=0 THEN
              repmode(i,ki); modes[ki]:=modes[i];
              modeOFasa:=ki; modes[i]:=asa;
              i:=ki+1; ki:=0
             ELSE i+:=1
             FI
            ESAC
           OD;

           FORALL id IN allids[:noids] DO
             output( XTDEC  (bu, modulelevel, id), 2)
           OD;

           WHILE   CASE  modes[lastmode]
                   IN  ( SAMEAS  s):TRUE
                   OUT   FALSE
                   ESAC
           DO  lastmode  MINUSAB  1  OD
   END ;



PROC treatspec = (REF ID name, p, YM ym)VOID:
BEGIN YSPEC ys := givespec(name, p, ym);
        REF XSPEC xs = xs OF ys;
        YMODINFO y;
        REF XMODINFO x = xmi OF y;

        PROC setc = VOID:
        BEGIN output(XINTERF (name, ym, p, ys OF ys,
                                  modulelevel +:= 1,
                                  nl OF xs + ng OF xs
                                 ), 2);
                concheck := HEAP CONCHECK := ((name, p, modulelevel),
                                                 lastid OF globcurrent + 1,
                                                 concheck
                                                )
        END;

        IF no OF xs <= 0
        THEN faultp(124, 0, 0, name)
               CO .3 no longer has same formals CO
        ELSE CASE u OF xs
               IN (REF VECTOR[]CAT c1):
                        (VECTOR[UPB c1]CAT c := c1;
                         FOR i TO UPB c
                         DO y := givemoduledetails(n OF c[i], 0, FALSE);
                              IF type OF x <= 0
                              THEN CO not found or changed type CO
                                     faultp(IF type OF x = -2
                                            THEN 160
                                            ELSE 125
                                            FI, 0, 0, n OF c[i])
                              ELSE treatspec(n OF c[i],
                                               f OF c[i], ym OF y
                                              )
                              FI
                         OD;
                         setc;
                         lastid OF globcurrent +:= 1;
                         output(XTDEC (FALSE, modulelevel,
                                         LOC IDDEC :=
                                         (nullid,
                                          lastid OF globcurrent,
                                          level OF globcurrent, int,
                                          lastid OF globcurrent, NIL
                                         )
                                        ), 2
                               )
                        ),
                    (REF VECTOR[]CHAR s):
                        (setc;
                         simplespec(FALSE, ids OF globcurrent,
                                    indics OF globcurrent,
                                    lastid OF globcurrent,
                                    lastid OF globcurrent + 1, s
                                   )
                         )
               ESAC
        FI
END;

PROC closure = (REF CLOSURE c, REF CONTEXHT con)INT:
BEGIN
    YMODINFO y := givemoduledetails(name OF c, 0, TRUE);
    REF XMODINFO x = xmi OF y;
    INT i := 0, rm := nextmodule +:= 1;
    output(XTMODULE (type OF x, rm, name OF c, ym OF y), outlevel);
    CONTEXHT ncon;
    g OF ncon := IF level OF g OF x = 0
                   THEN l OF x
                   ELSE g OF x
                   FI;
    rest OF ncon := con;
    REF SUBLIST sb := s OF c;

    WHILE sb ISNT nilsubl
    DO i +:= 1;
         sb := rest OF sb
    OD;

    IF type OF x < 0
    THEN CO decs or not found CO
           faultp(IF type OF x = -1
                  THEN 199
                  ELSE 160
                  FI, 0, 0, name OF c);
           0
    ELIF i /= type OF x
    THEN faultp(126, 0, 0, name OF c);
           CO .3 doesnt have this no of formals CO
           0
    ELIF level OF l OF x /= 0 ANDTH (con ISNT nilcon)
           ANDTH l OF x /= l OF con ANDTH l OF x /= g OF con
    THEN faultp(127, 0, 0, name OF c);
           CO module .3 does not fit here CO
           0
    ELIF i = 0
    THEN rm
    ELSE
        REF CONTEXHT g;
        VECTOR[i]INT actuals;
        INT j, k, l, u;
        YSPEC ys;
        REF XSPEC xs = xs OF ys;
        REF VECTOR[]INTTRIPLE kp;
        REF VECTOR[]CAT kc;
        sb := s OF c;

        TO i
        DO ys := givespec(name OF c, proxy OF sb, ym OF y);
             l OF ncon := (name OF c, proxy OF sb, nl OF xs);

             IF no OF xs <= 0
             THEN faultp(128, 0, 0, proxy OF sb)
                    CO .3 is not formal of module CO
             ELSE actuals[no OF xs] :=
                    CASE a OF sb
                    IN (REF CLOSURE c1):
                              closure(c1, ncon),
                         (REF PROXYL p):
                              (g := ncon;
                               k := j := 0;

                               WHILE g ISNT nilcon
                               DO j +:= level OF l OF g;
                                    k +:= 1;
                                    u := level OF g OF g;
                                    g := rest OF g
                               OD;

                               kp := LOC VECTOR[k]INTTRIPLE;
                               kc := LOC VECTOR[k]CAT;

                               output(XOPENMODULE (name OF p,
                                                     level OF l OF ncon
                                                     + level OF g OF ncon,
                                                     0, nextmodule +:= 1
                                                    ), outlevel);
                               g := ncon;
                               l := 0;
                               FOR i FROM k BY - 1 TO 1
                               DO kp[i] := (l, IF k = 1
                                                 THEN 1
                                                 ELSE level OF g OF g + 1
                                                 FI,
                                              level OF l OF g
                                              + level OF g OF g
                                             );
                                    kc[i] := l OF g;
                                    l +:= 1;
                                    g := rest OF g
                               OD;
                               output(XCALLMODULE ((no OF p, l),
                                                     kp, NIL, l
                                                    ), outlevel);
                               output(XCLOSEMODULE (nextmodule, 0), outlevel);
                               output(XSPEC (name OF p, no OF p,
                                               j, u, kc
                                              ), 0);
                               nextmodule
                              )
                    OUT 0
                    ESAC
             FI;
             sb := rest OF sb
       OD;
       output(XCLOSURE (rm, actuals, nextmodule +:= 1), outlevel);
       nextmodule
    FI
END;

REF KMODELIST mdone := NIL, kmfree := NIL;

PROC makekeepinfo = (REF KEEPLIST kl, BOOL kb, REF VECTOR[]CHAR ka,
                       REF VECTOR[]INT decnos, modenos
                      )INT:
BEGIN INT ki := 0, d;
        compsize := 0;

        PROC mdno = (INT d, m)VOID:
        BEGIN compsize +:= 1;
                IF kb
                THEN decnos[compsize] := d;
                       modenos[compsize] := m
                FI
        END;

        PROC kc = (INT c)VOID:
        BEGIN IF kb THEN ka[ki + 1] := REPR c FI;
                ki +:= 1
        END;

        PROC kw = (INT i)VOID:
        BEGIN IF kb
                THEN ka[ki + 1] := REPR (i % maxchar);
                       ka[ki + 2] := REPR (i MOD maxchar)
                FI;
                ki +:= 2
        END;


        PROC ks = (VECTOR[]CHAR s)VOID:
        BEGIN INT u := UPB s;
                WHILE u > 1 ANDTH s[u] = " "
                DO u -:= 1 OD;
                IF kb
                THEN ka[ki + 1] := REPR u;
                       ka[ki + 2 : ki + u + 1] := s[ : u]
                FI;
                ki +:= (u + 1)
        END;

        REF KEEPLIST klist := kl;
        INT i, j, k, l, m;
        INT kmno := 99, keepno := 0;
        REF KMODELIST mtodo := NIL;

        PROC numbermode = (INT mode)INT:
        BEGIN INT m := ABS (BIN mode AND decsmask), i;
                REF KMODELIST kml := mdone;
                IF m < newmode1
                THEN mode
                ELSE
                       WHILE kml ISNT nilkml
                       DO IF m OF kml = m
                            THEN i := km OF kml;
                                   GOTO out
                            ELSE kml := rest OF kml
                            FI
                       OD;
                       kml := mtodo;

                       WHILE kml ISNT nilkml
                       DO IF m OF kml = m
                            THEN i := km OF kml;
                                   GOTO out
                            ELSE kml := rest OF kml
                            FI
                       OD;
                       i := kmno +:= 1;
                       mtodo := IF kmfree IS nilkml
                                THEN HEAP KMODELIST
                                ELSE kml := kmfree;
                                       kmfree := rest OF kmfree;
                                       kml
                                FI := (m, i, mtodo);
                   out:
                       i + mode - m
                FI
        END;

        PROC keepmode = (INT mode)INT:
        BEGIN INT i := numbermode(mode), j, l;
                REF MODELIST ml, ml1;
                REF SELIST sl;
                REF KMODELIST kml;

                WHILE mtodo ISNT nilkml
                DO kml := mtodo;
                     mtodo := rest OF mtodo;
                     rest OF kml := mdone;
                     mdone := kml;
                     CASE modes[m OF mdone]
                     IN (REF PRC p):
                                   (kc(6);
                                    kw(km OF mdone);
                                    kw(numbermode(deproc OF p))
                                   ),
                          (REF PROCP pp):
                                   (kc(7);
                                    kw(km OF mdone);
                                    kw(numbermode(deproc OF pp));
                                    ml := pars OF pp;
                                    GOTO ml
                                   ),
                          (REF UNN u):
                                   (kc(8);
                                    kw(km OF mdone);
                                    ml := modelist OF u;
                                    GOTO ml
                                   ),
                          (REF STRCT s):
                                   (kc(9);
                                    kw(km OF mdone);
                                    l := 0;
                                    sl := sels OF s;

                                    WHILE sl ISNT nilsel
                                    DO l +:= 1;
                                         sl := rest OF sl
                                    OD;
                                    kc(l);
                                    sl := sels OF s;

                                    WHILE sl ISNT nilsel
                                    DO kw(numbermode(mode OF sl));
                                         ks(name OF sl);
                                         sl := rest OF sl
                                    OD
                                   ),
                          (REF ISTRUCT is):
                                   (kc(10);
                                    kw(km OF mdone);
                                    kw(numbermode(imode OF is));
                                    j := length OF is % maxchar2;
                                    l := length OF is MOD maxchar2;
                                    kc(j);
                                    kw(l)
                                   ),
                          (REF VCTOR v):
                                   (kc(11);
                                    kw(km OF mdone);
                                    kw(numbermode(vecmode OF v));
                                    kc((deflex OF v < 0 ! 0 ! 2))
                                   ),
                          (REF ARRAY a):
                                   (kc(12);
                                    kw(km OF mdone);
                                    kw(numbermode(mode OF a));
                                    kc(nods OF a);
                                    kc((deflex OF a < 0 ! 0 ! 2))
                                   ),
                          (REF STEN st):
                                   (kc(13);
                                    kw(km OF mdone);
                                    kw(numbermode(mode OF st))
                                   )
                     OUT SKIP
                     ESAC;

                     SKIP EXIT
                 ml:
                     ml1 := ml;
                     l := 0;

                     WHILE ml ISNT nilml
                     DO l +:= 1;
                          ml := rest OF ml
                     OD;
                     kc(l);
                     TO l
                     DO kw(numbermode(mode OF ml1));
                          ml1 := rest OF ml1
                     OD
                OD;
                i
        END;

        ki := 0;

        WHILE klist ISNT nilkl
        DO CASE u OF klist
             IN (REF IDDEC idd):
                      (i := keepmode(mode OF idd);
                       j := decno OF idd;
                       kc((j >= 0 ! 1 ! 2));
                       ks(name OF idd);
                       IF j < 0 THEN kw(-j) FI;
                       kw(i);
                       IF j >= 0
                       THEN mdno(decno OF idd, mode OF idd)
                       FI
                      ),
                  (REF INDIC ind):
                       CASE u OF ind
                       IN (REF AMODE am):
                                (i := keepmode(mode OF am);
                                 IF modeproc OF am /= 0
                                 THEN j := insertprocp(mode OF am, boolnil);
                                        CO this mode is not strictly required.
                                             if it is given, the result of the
                                             proc should be deflexed.  however,
                                             this would prevent existing modules
                                             from being amended
                                        CO
                                        keepmode(j)
                                 FI;
                                 kc(3);
                                 ks(name OF ind);
                                 kw(i);
                                 IF modeproc OF am = 0
                                 THEN kc(0)
                                 ELSE kc(1);
                                        mdno(modeproc OF am, j)
                                 FI
                                )
                       ESAC,
                  (ONEOP op):
                      (i := keepmode(lmode OF i OF op);
                       j := keepmode(rmode OF i OF op);
                       k := keepmode(ans OF i OF op);
                       keepmode(opproc(i OF op));
                       IF (d := decno OF i OF op) >= 0
                       THEN mdno(d, opproc(i OF op))
                       FI;
                       CASE u OF n OF op
                       IN (REF OPER oper):
                                (kc((d >= 0 ! 4 ! 5));
                                 ks(name OF n OF op);
                                 kc(ABS prio OF oper);
                                 kw(i);
                                 kw(j);
                                 kw(k);
                                 IF d < 0 THEN kw(-d) FI
                                )
                       ESAC
                      )
             ESAC;

             klist := rest OF klist
        OD;

        WHILE mdone ISNT nilkml
        DO mtodo := mdone;
             mdone := rest OF mdone;
             rest OF mtodo := kmfree;
             kmfree := mtodo
        OD;
        ki
END;


PROC addtokl = (KEEPITEM ki)VOID:
BEGIN REF KEEPLIST k := kl;
        WHILE (k ISNT nilkl) ANDTH
                CASE u OF k
                IN (REF IDDEC idd):
                          CASE ki
                          IN (REF IDDEC kidd):
                                    idd ISNT kidd
                          OUT TRUE
                          ESAC,
                     (REF INDIC ind):
                          CASE ki
                          IN (REF INDIC kind):
                                    ind ISNT kind
                          OUT TRUE
                          ESAC,
                     (ONEOP one):
                          CASE ki
                          IN (ONEOP kone):
                                    (n OF one ISNT n OF kone)
                                    OREL (i OF one ISNT i OF kone)
                          OUT TRUE
                          ESAC
                OUT TRUE
                ESAC
        DO k := rest OF k OD;

        IF k ISNT nilkl
        THEN fault(189)
               CO already kept CO
        ELSE (REF REF KEEPLIST (rkl)) := HEAP KEEPLIST := (ki, NIL);
               rkl := rest OF rkl
        FI
END;



    bumodule := ( REF  ID  n,  INT  mn)  VOID :
    BEGIN   YMODINFO  y := givemoduledetails(n, mn,  FALSE );
            REF  XMODINFO  x = xmi  OF  y;
            YSPEC  ys;
            REF  XSPEC  xs = xs  OF  ys;
            REF  CONCHECK  c := concheck;
            INT  scope;

            WHILE  (c  ISNT  nilconchk)  ANDTH  l  OF  x /= c  OF  c
            DO  c := rest  OF  c  OD ;

            IF  type  OF  x /= - 1
            THEN   IF  mn = 0
                   THEN  faultp(129, 0, 0, n)
                          CO  .3 not accessible here  CO
                   FI
            ELIF  (c  IS  nilconchk)  ANDTH  level  OF  l  OF  x /= 0
            THEN  faultp(130, 0, 0, name  OF  x)
                   CO  decs .3 in wrong context  CO
            ELSE   IF  c  IS  nilconchk
                   THEN  scope := 3;
                         modulelevel := 0
                   ELSE  scope := scope  OF  c;
                         modulelevel := level  OF  c  OF  c
                   FI ;
                  output( XTMODULE  (- 1, nextmodule +:= 1,
                                     name  OF  x, ym  OF  y
                                    ), 2);
                  ys := givespec(name  OF  x, name  OF  x, ym  OF  y);

                   CASE  u  OF  xs
                   IN  ( REF  VECTOR [] CHAR  s):
                       IF  mn = 0
                       THEN  simplespec( TRUE , ids  OF  globcurrent,
                                         indics  OF  globcurrent,
                                         lastid  OF  globcurrent, scope, s
                                       )
                        ELSE  simplespec( TRUE , libids, libinds,
                                               nextlibno, scope, s
                                        )
                        FI
                   ESAC
            FI
    END ;



PROC findid = REF IDDEC:
BEGIN REF IDDEC id := (ids OF globcurrent)[idhash];
        INT i := 0;
    aa:
        WHILE (id ISNT nilid) ANDTH name OF id /= ident
        DO id := rest OF id OD;

        IF id IS nilid
        THEN CASE i +:= 1
               IN (id := libids[idhash];
                     GOTO aa
                    ),
                    (bumodule(ident, 1);
                     id := libids[idhash];
                     GOTO aa
                    ),
                    (id := HEAP IDDEC := (ident, 1, 1,
                                             faultmode, 0, libids[idhash]
                                            );
                     IF supflts = 0 THEN libids[idhash] := id FI;
                     CO identifier .3 not declared CO
                     faultp(131, 0, 0, ident);
                     GOTO e
                    )
               ESAC
        FI;
        IF mode OF id = faultmode
        THEN decno OF id +:= 1
        FI;

     e: id
END;

CO ********************************************************************** CO

PROC range = (REF RANGEINFO external, REF IDDEC rdname,
                REF INDIC indname, REF BOOL saveexit
               )VLIST:
BEGIN RANGEINFO current := external;
        globcurrent := current;
        BOOL oldidhash := TRUE, oldindichash := TRUE;
        props OF current := IF props OF external = BIN -1
                              THEN decbit
                              ELSE z
                              FI;
        level OF current +:= 1;
        labs OF current := NIL;
        dybits OF current := z;

        REF RIDIDLIST rididlist;
        BITS dobits;
        INT doint;
        INT ccmode, m;
        REF MODELIST ml;

        REF AMODE am;
        INT i, j, k, firstmode, type, descno;
        REF IDDEC id;
        REF INDIC indic;
        REF INST inst1;
        PROC(INT)VALUE uc1;
        REF REF IDDEC rid;
        REF REF INDIC rindic;
        AMODE scam;
        mode OF scam := faultmode;
        VALUE v := (z, faultmode, NIL, NIL);
        INT rangestind := stind, rangebrind := brind,
              formatstind, formatbrind;
        INT formatcaseno;
        VLIST vlist;
        REF VLIST vl;
        BOOL heap := FALSE;
        REF MODELIST parlist := NIL, pl, pl1;
        REF LABEL lab, labl;
        XCHARPOS xcharpos;
        BOOL firstaidec, givenmess;

    PROC scopel = (REF REF LABEL l, e)BOOL:
    BEGIN REF LABEL lab := labs OF current, lab1;
            l := NIL;
            BOOL ans := FALSE;

            WHILE lab ISNT nillab
            DO IF status OF lab /= 0
                 THEN lab1 := labs OF external;
                        ans := TRUE;

                        WHILE (lab1 ISNT nillab)
                                ANDTH name OF lab1 /= name OF lab
                        DO lab1 := rest OF lab1 OD;

                        status OF lab := IF lab1 ISNT nillab
                                           THEN labno OF lab1
                                           ELSE 1
                                           FI
                 FI;
                 lab1 := lab;
                 lab := rest OF lab;
                 IF status OF lab1 = 1
                 THEN rest OF lab1 := e;
                        e := lab1
                 ELSE rest OF lab1 := l;
                        l := lab1
                 FI
            OD;
            ans
    END;


    REF VECTOR[]INT inserts, ignorable, nonstarter;
    BOOL checkt1 = FALSE, notcheckt1 = TRUE;
    PROC VOID informat1;

PROC recovery = (INT readertype)BOOL:
BEGIN VECTOR[10]CHAR insertmess, ignoremess;
        insertmess := "  INSERTED";
        ignoremess := "  IGNORED1";
        INT new;
        modedecdepth := 0;
        BOOL notfound, formatread, result := FALSE;
        supflts := fltgap;
        formatread := IF readertype /= formatreader
                      THEN inserts := insertsn;
                             ignorable := ignorablen;
                             nonstarter := nonducstart;
                             FALSE
                      ELSE inserts := insertsf;
                             ignorable := ignorablef;
                             nonstarter := nonpicstart;
                             TRUE
                      FI;
insert: new := 1;
        FOR i TO UPB inserts
        WHILE NOT checkinsert(inserts[i], checkt1)
        DO new +:= 1 OD;

        IF new = UPB inserts + 1  CO  cannot insert symbol  CO
        THEN notfound := TRUE;
               FOR i TO UPB ignorable
               WHILE notfound
               DO IF t1 = ignorable[i]
                    THEN notfound := FALSE
                    FI
               OD;

               IF notfound
               THEN GOTO level2
               ELSE ignoremess[1] := REPR (ABS (BIN t1 AND BIN 63));
                      IF t1 = 74
                      THEN abort(IF recoverdepth = 0 ANDTH supflts = 0
                                   THEN CO finish not expected here CO
                                         132
                                   ELSE - 1
                                   FI
                                  )
                      FI;
                      faultchars(ignoremess);
                      supflts := fltgap;
                      t1 := reader(readertype);
                      IF checkinsert(t1, notcheckt1)
                      THEN crts := failpos;
                             GOTO endrecover
                      ELSE GOTO insert
                      FI
               FI
        ELSE next := t1 + 1000;
               insertmess[1] := REPR (ABS (BIN (t1 := inserts[new])
                                               AND BIN 63
                                              )
                                       );
               IF t1 = 32 THEN ident := spaces FI;
               faultchars(insertmess);
               supflts +:= 1;
               crts := failpos;
               GOTO endrecover
        FI;

level2:  notfound := TRUE;
        FOR i TO UPB nonstarter
        WHILE notfound
        DO IF t1 = nonstarter[i]
             THEN notfound := FALSE
             FI
        OD;

        IF notfound  CO starter CO
        THEN sidstack[stind] := failpos;
               stind +:= 1;
               crts := 3;
               next := t1 + 1000;
               t1 := IF formatread
                     THEN frecoversymbol
                     ELSE recoversymbol
                     FI;
               IF (recoverdepth +:= 1) > 15
               THEN abort(133)
                      CO compilation abandoned - too many syntax errors CO
               FI;
               supflts := fltgap + 1;
               IF formatread
               THEN faultchars("COLLECTIONLIST CALLED");
                      informat1;
                      vlist := ((z, faultmode, NIL, NIL), 0, NIL);
                      supflts := fltgap;
                      faultchars("END OF COLLECTIONLIST CALL")
               ELSE faultchars("DUCLIST CALLED");
                      look := 2;
                      vlist := range(current, NIL, NIL, NIL);
                      supflts := fltgap;
                      faultchars("END OF DUCLIST CALL");
                      crts := sidstack[stind -:= 1];
                      IF readertype = formatreader
                           ANDTH t1 /= 25 ANDTH t1 /= 28
                      THEN next := t1 + illegaltok;
                             t1 := 0
                      FI

               FI;
               recoverdepth -:= 1;
               GOTO endrecover
        ELIF formatread ANDTH
               (t1 = 0 OREL t1 = 38 OREL t1 = 60 OREL
                (t1 > 39 ANDTH t1 < 54))
        THEN IF t1 > 0 ANDTH t1 < 60
               THEN tind -:= 1
               FI;

               IF formatbrind >= brind
                    CO no unmatched brackets inside format CO
               THEN crts := sidstack[stind := formatstind];
                      supflts := fltgap;
                      faultchars("EXIT OF FORMAT");
                      result := TRUE;
                      t1 := 0;
                      GOTO endrecover
               ELSE formatread := FALSE;
                      inserts := insertsn;
                      ignorable := ignorablen;
                      nonstarter := nonducstart;
                      t1 := reader(screader);
                      GOTO level2
               FI
        ELIF ((t1 /= 25 ANDTH t1 /= 45)
                OREL brind >= rangebrind OREL rangebrind = 2)
                  ANDTH t1 /= 60
        THEN ignoremess[1] := REPR (ABS (BIN t1 AND BIN 63));
               IF t1 = 74
               THEN abort(IF recoverdepth = 0 ANDTH supflts = 0
                            THEN 132
                                   CO finish not expected here CO
                            ELSE -1
                            FI
                           )
               FI;
               ignoremess[10] := "2";
               supflts := fltgap;
               faultchars(ignoremess);
               ignoremess[10] := "1";
               t1 := reader(readertype);
               GOTO level2
        ELSE stind := rangestind;
               faultchars("EXIT OF SC");
               crts := sidstack[stind];
               vlist := ((z, faultmode, NIL, NIL), 0, NIL);
               IF t1 = 60 THEN t1 := reader(screader) FI;
               GOTO exitsc
        FI;

endrecover: result

END;

CO ********************************************************************** CO

PROC declarer = (BOOL modedec, REF AMODE am)INT:
BEGIN INT i, j, n, mode, dectype, decdescno;
        BOOL lic;
        MODE MLL = STRUCT (REF MODELIST ml, REF MLL rest);
        REF MLL mll := NIL;
        REF AMODE amode := NIL;
        REF AMODELIST amodelist := NIL, amodestack := NIL, aml;
        REF SELIST selstack := NIL, selist := NIL, sl, sl1;
        REF MODELIST intstack := NIL, modelist := NIL,
                        modestack := NIL, ml;
        type := 0;
        IF NOT modedec THEN descno := 1 FI;

CO<declarer*>: CO

DO

CASE analyser IN

CO<reader>: CO
    (oldtind := tind;
     t1 := reader(decreader)
    ),

CO<failure>: CO
    (fault(134);
     CO unexpected symbol in mode CO
     recovery(decreader)
    ),

CO<dcheckuf>: CO
    ( INT i = CASE 2 IN 1 ESAC; SKIP ) ,
CO<dchecksc>: CO
    ( INT i = CASE 2 IN 1 ESAC; SKIP ) ,

CO<vm0>: after bus CO
    intstack := LOC MODELIST := (n OVER 2, intstack),

CO<vm1>: rows CO
    (j := mode OF modestack;
     modestack := rest OF modestack;
     n := mode OF intstack;
     intstack := rest OF intstack;
     FOR i TO n - 1
     DO mode := insertarray(mode, i, 1) OD;
     mode := insertarray(mode, n, j)
    ),

CO<vm2>: struct CO
    (sl := selist;
     FOR i WHILE sl ISNT nilsel
     DO fieldno OF sl := i;
          sl1 := sl;
          WHILE (sl1 := rest OF sl1) ISNT nilsel
          DO IF name OF sl1 = name OF sl
               THEN faultp(187, 0, 0, name OF sl)
                     CO selector .3 defined twice CO
               FI
          OD;
          sl := rest OF sl
     OD;
     mode := insertstrct(1, selist)
    ),

CO<vm3>: CO
    mode := mode OF decmode,

CO<vm4>: istruct CO
    (modestack := LOC MODELIST := (iv, modestack);
     IF iv = 0
     THEN fault(135)
            CO cannot have zero elements CO
     ELIF iv > maxistruct
     THEN fault(195)
            CO istruct too large CO
     FI
    ),

CO<vm5>: istruct CO
    (mode := insertis(mode, mode OF modestack);
     modestack := rest OF modestack
    ),

CO<vm6>: vector CO
    (j := mode OF modestack;
     modestack := rest OF modestack;
     mode := insertvec(mode, j)
    ),

CO<vsel1>: stacks selist CO
    selstack := HEAP SELIST := (mode, 0, ident, selstack),

CO<vsel2>: unstacks selist CO
    (sl := selstack;
     selstack := rest OF selstack;
     rest OF sl := selist;
     selist := sl
    ),

CO<vsel3>: last field CO
    selist := HEAP SELIST := (mode, 0, ident, NIL),

CO<vf1>: not flex CO
    modestack := LOC MODELIST := (1, modestack),

CO<vf2>: flex CO
    modestack := LOC MODELIST := (-1, modestack),

CO<fx>: flex before modename CO
    (i := makeflex(mode);
     IF i = mode
     THEN faultp(191, i, 0, NIL)
            CO .1 cannot be flexed CO
     ELSE mode OF amode := i
     FI;
     mode := i
    ),


CO<cm1>:  after ref CO
    mode +:= refmark,

CO<cm2>: after proc mode CO
    mode := insertprc(deflex(mode)),

CO<cm3>: union CO
    mode := insertunion (modelist),

CO<cm5>: proc with params CO
    (modelist := ml OF mll;
     mll := rest OF mll;
     mode := insertprocp(deflex(mode), modelist)
    ),

CO<cm6>: void empty CO
    mode := voidmode,

CO<cm7>: stack modes in modelist CO
    (modestack := HEAP MODELIST := (deflex(mode), modestack);
     modelist := NIL
    ),

CO<cm8>: unstack mode in param pack CO
    (ml := modestack;
     modestack := rest OF modestack;
     rest OF ml := modelist;
     modelist := ml
    ),

CO<cm9>: unstack mode in union list CO
    (IF mode OF modestack > refmark
     THEN i := 1
     ELSE CASE modes[mode OF modestack]
            IN (REF UNN u):
                     (ml := modelist OF u;
                      modestack := rest OF modestack;
                      FOR j WHILE ml ISNT nilml
                      DO modestack := HEAP MODELIST
                                     := (mode OF ml, modestack);
                           ml := rest OF ml;
                           i := j
                      OD
                     )
            OUT i := 1
            ESAC
     FI;

     TO i
     DO ml := modestack;
          modestack := rest OF modestack;
          rest OF ml := modelist;
          modelist := ml
     OD;
     removedupl(modelist)
    ),

CO<cm10>: stack modelist before proc result CO
    mll := LOC MLL := (modelist, mll),

CO<l1>: CO
    nolongs := 2,

CO<l2>: CO
    nolongs := 1,

CO<l3>: CO
    nolongs := 0,

CO<l4>: CO
    nolongs := -1,

CO<pm5>: CO
    mode := 4 * t1 - 137 + nolongs,

CO<pm6>: CO
    mode := IF t1 = 94
            THEN xtype
            ELIF t1 = 95
            THEN ytype
            ELSE t1 - 27
            FI,

CO<pm7>: CO
    mode := faultmode,

CO<pm8>: CO
    (INT k := deflex(mode);
     FOR i FROM newmode1 TO lastmode
     DO CASE modes[i]
          IN (REF STEN st):
                    IF k = mode OF st
                    THEN mode := i;
                           GOTO end
                    FI
          OUT SKIP
          ESAC
     OD;

     IF lastmode < upbofmodes
     THEN modes[mode := lastmode +:= 1] := HEAP STEN := (k, NIL)
     ELSE abort(206)
            CO too many modes CO
     FI;

end: SKIP
    ),

CO<cbd0>: before bounds CO
    (outlevel +:= 1;
     n := 2;
     lic := lastidchanged;
     lastidchanged := FALSE
    ),

CO<cbd1>: after [] CO
    IF type = 2
    THEN fault(188)
           CO mixed bounds CO
    ELSE type := 1
    FI,

CO<cbd2>: after [bds] CO
    (IF lastidchanged
     THEN output(XIDDEC (xdummydec,
                             LOC IDDEC := (nullid, maxident,
                                              level OF globcurrent, 0,
                                              lastid OF globcurrent, NIL
                                             )),
                   outlevel - 1
                  );
            lastid OF globcurrent := maxident
     FI;

     lastidchanged := lic;
     IF type = 1
     THEN fault(188)
            CO mixed bounds CO
     ELSE type := 2
     FI;
     output(XOPER (xbdpack, 0, n), outlevel);
     output(up, outlevel);
     outlevel -:= 1
    ),

CO<cbd3>: first bd CO
    n := 2,

CO<cbd4>: other bds CO
    n +:= 2,

CO<cbd5>: default bds CO
    output(XOPER (xdefaultbd, 0, 0), outlevel),

CO<cbd6>: vector CO
    n := 1,

CO<dcalluc>: evaluate bds CO
    (dectype := type;
     modedecdepth +:= 1;
     decdescno := descno;
     uc1(int);
     descno := decdescno;
     modedecdepth -:= 1;
     type := dectype;
     dybits OF current := z
    ),

CO<md1>: after [bdety]amode CO
    IF type = 2
    THEN amodelist := IF amode ISNT nilam
                        THEN IF modedec
                               THEN HEAP AMODELIST
                               ELSE LOC AMODELIST
                               FI := (amode, NIL)
                        ELSE NIL
                        FI;
           amode := IF modedec
                    THEN HEAP AMODE
                    ELSE LOC AMODE
                    FI
                 := (mode, - mode OF intstack, amodelist);
           intstack := rest OF intstack
    ELSE amode := NIL
    FI,

CO<md2>: struct avmode CO
    amode := IF (amodelist ISNT nilaml) ANDTH type /= 1
             THEN IF modedec
                    THEN HEAP AMODE
                    ELSE LOC AMODE
                    FI := (mode, 1, amodelist)
             ELSE NIL
             FI,

CO<md3>: modename in avmode CO
    (amode := decmode;
     mode := mode OF amode;
     IF modeproc OF amode = 0 OREL type = 1
     THEN amode := NIL
     ELSE adjscope(rd OF current, level OF cindic, scope OF cindic);
            IF NOT modedec ANDTH modeproc OF amode <= 2
            THEN faultp(165, mode, 0, NIL);
                   CO mode .1 not declared CO
                   mode := faultmode
            FI
     FI
    ),

CO<md4>: after cmodes in avmode CO
    amode := NIL,

CO<md0>: after [bdety] in avmode CO
    IF type = 2
    THEN intstack := LOC MODELIST := (descno +:= 1, intstack)
    FI,

CO<md5>: istruct amode CO
    amode := IF (amode ISNT nilam) ANDTH type /= 1
             THEN IF modedec THEN HEAP AMODE ELSE LOC AMODE FI
                    := (mode, 1, IF modedec
                                 THEN HEAP AMODELIST
                                 ELSE LOC AMODELIST
                                 FI := (amode, NIL) )
             ELSE NIL
             FI,

CO<msel1>: stack amodes in struct CO
    (amodelist := IF (amode ISNT nilam) ANDTH type /= 1
                  THEN IF modedec
                         THEN HEAP AMODELIST
                         ELSE LOC AMODELIST
                         FI := (amode, NIL)
                  ELSE NIL
                  FI;
     selist := HEAP SELIST := (mode, 0, ident, NIL)
    ),

CO<msel2>: stack amode in struct CO
    (i := IF (amode ISNT nilam) ANDTH type /= 1
          THEN amodestack := IF modedec
                               THEN HEAP AMODELIST
                               ELSE LOC AMODELIST
                               FI
                            := (amode, amodestack);
                 1
          ELSE 0
          FI;
     selstack := HEAP SELIST := (mode, i, ident, selstack)
    ),

CO<msel3>: unstacks amode CO
    (sl := selstack;
     selstack := rest OF selstack;
     rest OF sl := selist;
     selist := sl;
     IF fieldno OF selist /= 0
     THEN aml := amodestack;
            amodestack := rest OF amodestack;
            rest OF aml := amodelist;
            amodelist := aml
     FI
    ),

CO<enddec1>: ends avmode CO
    (IF NOT modedec
     THEN treatam(amode, IF t1 /= 32 ANDTH t1 /= 29 ANDTH t1 /= 10
                                         ANDTH t1 /= 24 ANDTH t1 /= 62
                                CO ident, val, :, (, code CO
                           THEN genam
                           ELSE decam
                           FI, lastid OF current)
     FI;
     am := IF amode ISNT nilam
           THEN amode
           ELSE (mode, 0, NIL)
           FI;
     GOTO end
    ),

CO<enddec2>: ends vmode CO
    (am := (mode := IF mode > 1 ANDTH mode <= lastmode
                    THEN deflex(mode)
                    ELSE mode
                    FI, 0, NIL);
     GOTO end
    ),

CO<dontlook1>:CO
    look := 1,

CO<decgotosc>: exit after PROC CO
    GOTO scstart

CO<syntax stack overflow>CO
    OUT abort(207)

ESAC

OD;

end: mode

END;      CO end of declarer CO

CO ********************************************************************** CO

PROC lookahead = VOID:
BEGIN INT oldstind := stind;
        lkmodeins := 0;

        DO
             CASE analyser IN

CO<look* >  CO

CO<reader>: CO
    (oldtind := tind;
     t1 := reader(0)
    ),

CO<failure>: CO
    (lkinserts := 1;
     GOTO end
    ),

CO<endlk>: CO
    (lkinserts := IF t1 < 12 OREL t1 = 63
                  THEN 1
                  ELSE 0
                  FI;
     GOTO end
    ),

CO<keepid>: CO
    ((REF REF LKIDS (lkend)) := HEAP LKIDS
                                 := (ident, idsize, idhash, NIL);
     lkend := rest OF lkend
    ),

CO<avm>:  CO
    (outlevel +:= 1;
     declarer(FALSE, lkscam);
     outlevel -:= 1;
     lktype := type
    ),

CO<keepproc>: CO
    (lkmodeins := 44;
     lkinserts := 1;
     GOTO end
    ),

CO<keepmode>: CO
    lkmodeins := 91,

CO<endlklong>: CO
    (nolongs +:= 10;
     lkinserts := 1;
     GOTO end
    ),

CO<keepcomma>: CO
    (next := 1028;
     lkinserts := 0;
     GOTO end
    )

CO<syntax stack overflow>CO
    OUT abort(207)

ESAC
OD;

end:    crts := sidstack[stind := oldstind];
        IF t1 /= 10
        THEN tind := oldtind;
               IF next /= 1028 THEN next := -1 FI
        ELSE next := 1010
        FI;
        IF t1 = 25
        THEN brind +:= 1
        ELIF t1 = 24
        THEN brind -:= 1
        FI;
        t1 := IF lkinserts = 0
              THEN 71
              ELSE IF lkmodeins = 0 THEN lkinserts := -1 FI;
                     24
              FI
END;


PROC informat = VOID:
BEGIN VECTOR[linesize + 1]CHAR locfbuff;
        INT locfind, norf, locstrings, worksp := 0, rep := -1,
              bracketlevel := 0, tt, cccount := 0;
        REF VLIST case := LOC VLIST :=
                             ((downbit, int, NIL, NIL), xcase, NIL);
        VALUE vcase := (z, -int, case, NIL);
        REF REF VLIST lastcase := rest OF case;
        find := 1;
        globfbuff[1] := " ";
        noofstrings := 0;
        formatbrind := brind;
        formatstind := stind;
        output(down, outlevel + 1);
        output(up, outlevel + 1);

        PROC outint = (INT i)VOID:
        BEGIN INT j := i;
                INT k := j MOD 10;
                j := j % 10;
                IF j > 0 THEN outint(j) FI;
                globfbuff[find +:= 1] := REPR (k + ABS "0")
        END;

        PROC outcount = VOID:
        BEGIN globfbuff[find +:= 1] := "(";
                outint(cccount +:= 1);
                globfbuff[find +:= 1] := ")"
        END;

DO
CASE
 analyser IN

CO<informat* >: CO

CO<reader>: CO
    (t1 := reader(formatreader);
     rep -:= 1
    ),

CO<failure>: CO
    (fault(136);
     CO unexpected symbol in format CO
     IF recovery(formatreader) THEN GOTO exit FI
    ),

CO<fcheckuf>: CO
    SKIP,

CO<fchecksc>: CO
    ( INT i = CASE 2 IN 1 ESAC; SKIP ) ,

CO<checki>:  CO
    IF rep = 0
    THEN fault(CO replication not allowed here CO 137)
    FI,

CO<f1>:   CO
    (norf := formatmode;
     outcount
    ),

CO<n1>:   CO
    (rep := 0;
     norf := int;
     outcount
    ),

CO<g1>:   CO
    (norf := int;
     IF t1 /= 24
          CO ( CO
     THEN globfbuff[find +:= 1] := ","
     FI;
     globfbuff[find +:= 1] := "N";
     outcount
    ),

CO<g2>:   CO
    globfbuff[find +:= 1] := ")",

CO<ccl1>:   CO
    (locfbuff := globfbuff;
     locfind := find;
     locstrings := noofstrings;
     tt := tind;
     outlevel +:= 4;
     IF formatcaseno = 0
     THEN output(XIDDEC (xfdec,
                             LOC IDDEC := (nullid,
                                              lastid OF current +:= 1,
                                              0, int, 0, NIL
                                             )
                            ),
                   outlevel - 1
                  );
            output(lastid OF current, outlevel);
            output(up, outlevel);
            lastidchanged := TRUE
     FI;
     (REF REF VLIST (lastcase)) := LOC VLIST
                                    := (uc1(norf),
                                        IF formatcaseno = 0
                                        THEN xin
                                        ELSE xcomma
                                        FI,
                                        NIL
                                       );
     output(up, outlevel);
     props OF v OF lastcase := props OF v OF lastcase OR downbit;
     lastcase := rest OF lastcase;
     formatcaseno +:= 1;
     outlevel -:= 4;
     noofstrings := locstrings;
     globfbuff := locfbuff;
     find := IF tind < tt
             THEN output(XCHARS (- locfind, 0,
                                     globfbuff[ : locfind]
                                    ), outlevel + 1);
                    noofstrings +:= locfind;
                    0
             ELSE locfind
             FI
    ),

CO<endf>:   CO
    (IF formatcaseno /= 0
     THEN outlevel +:= 3;
            strong(vcase, formatunion, TRUE);
            outlevel -:= 3
     FI;
     output(down, outlevel);
     output(XFORMAT (noofstrings + find, formatcaseno, worksp), outlevel);
     output(down, outlevel);
     output(XCHARS (find, 0, globfbuff[ : find]), outlevel + 1);
     output(up, outlevel + 1);
     GOTO exit
    ),

CO<int1>:    CO
    rep := 0,

CO<w1>:   CO
    IF (bracketlevel +:= 1) > worksp
    THEN worksp +:= 1
    FI,

CO<w2>:   CO
    bracketlevel -:= 1

CO<syntax stack overflow>CO
    OUT abort(207)

ESAC
OD;

exit:  SKIP
END;

informat1 := informat;

CO ********************************************************************** CO

PROC uc = (INT mode)VALUE:
BEGIN REF AMODE am := NIL;
        REF VLIST vss;
        REF IDDEC id;
        REF OPSTACK opstack;
        BOOL exitinrange, bangdi;
        VLIST vlist;
        REF VALUE v = v OF vlist;
        REF VLIST vl, vl1;
        INT m, n, next := -1;

        MODE PROCLIST = STRUCT (PROCP p, INT n, procmode,
                                     REF PROCLIST rest
                                    ),
               CODESTACK = STRUCT (INT mode, nopars,
                                      REF CODESTACK rest
                                     );

        REF CODESTACK codestack := NIL;
        REF PROCLIST proclist;
        REF SELSTACK selstack;
        INT i, j, qref;
        REF INDSTACK indstack;
        XALIEN xal;

        DO

CO<newsiduc*> CO

CASE analyser IN

CO<reader>: CO
    IF next >= 0
    THEN t1 := next;
           next := -1
    ELSE t1 := reader(ucreader)
    FI,

CO<failure>: CO
    (fault(138);
     CO unexpected symbol CO
     recovery(ucreader)
    ),

CO<uccheckuf>: CO
    SKIP,

CO<ucchecksc>: CO
    ( INT i = CASE 2 IN 1 ESAC; SKIP ) ,

CO<ucalldec>: CO
    (am := LOC AMODE;
     declarer(FALSE, am)
    ),

CO<ucallform>: CO
    informat,

CO<gotosc>:CO
    (scam := am;
     firstaidec := TRUE;
     GOTO scstart
    ),

CO<gotosc2>: CO
    (firstaidec := TRUE;
     GOTO scstart
    ),

CO<enduc1>: void if uc; CO
    (IF t1 = 11 OREL t1 = 45 OREL t1 = 13
          CO od, keep CO
     THEN strong(v OF vss, voidmode, TRUE)
     ELSE heapvalue(v OF vss)
     FI;

     IF t1 = 11
     THEN props OF current := props OF current OR dybits OF current
     ELIF dybits OF current /= z
     THEN props OF current := props OF current OR dontpullbit;
           dybits OF external := dybits OF external OR dybits OF current
     FI;
     v := v OF vss;
     GOTO exituc
    ),

CO<rdenbody>:CO
    IF ((vl1 := vlist OF v OF vss) ISNT nilvl)
         ANDTH type OF vl1 /= xcoll
    THEN props OF rd OF current := props OF rd OF current OR ccbit
    FI,

CO<enduc2>: coerce to mode CO
    (strong(v OF vss, mode, TRUE);
     v := v OF vss;
     GOTO exituc
    ),

CO<enduc3>:CO
    GOTO exituc,

CO<ucallscf>: dostatement CO
    (range(current, NIL, NIL, NIL);
     vss := LOC VLIST := ((z, voidmode, NIL, NIL), 0, vss)
    ),

CO<ucallscr1>: rden in uc CO
    vss := LOC VLIST := (v OF range(current, NIL, NIL, NIL), 0, vss),

CO<ucallscr2>: prc in uc CO
    (IF type = 2
     THEN fault(139)
            CO bounds in result mode CO
     FI;
     rdmode := deflex(mode OF am);
     vss := LOC VLIST := (v OF range(current, NIL, NIL, NIL), 0, vss)
    ),

CO<ucallscr3>: void rden CO
    (rdmode := voidmode;
     vss := LOC VLIST := (v OF range(current, NIL, NIL, NIL), 0, vss)
    ),


CO<ucallsc>:CO
    (IF t1 = 32
     THEN i := tind;
            IF primread = 84
            THEN t1 := 27
            ELSE tind := i
            FI
     FI;
     exitinrange := FALSE;
     vlist := range(current, NIL, NIL, exitinrange);
     IF rest OF vlist ISNT nilvl
     THEN v := (z, -1, LOC VLIST := vlist, NIL)
     FI
    ),

CO<cc0>: after ord in closedclause CO
    outlevel +:= 1,

CO<cc1>: after (sc) CO
    IF (rest OF vlist IS nilvl) ANDTH
         ((vlist OF v OF vlist ISNT nilvl)
          OREL props OF v >= semibit
          OREL (labs OF v ISNT nillab)
         )
    THEN v := (z, -1, LOC VLIST := vlist, NIL)
    FI,

CO<cc2>: after ! in (sc ! ...  CO
    (i := pmode(hcf(v));
     next := t1;
     bangdi := FALSE;
     j := brackets[brind - 1 - ABS (next = 24)];
     vss := LOC VLIST := ((z, -i, NIL, NIL), 0, vss);
     vss := LOC VLIST := (v, 0, vss);
     t1 := CASE modes[i]
           IN (REF UNN u)
                     (globccmode := i;
                      bangdi := TRUE;
                      xcaseu
                     )
           OUT IF i = int OREL i = faultmode
                 THEN bangdi := TRUE;
                        xcase
                 ELIF i = bool
                 THEN IF j = 57
                             CO case CO
                        THEN fault(192);
                               CO int or union required after case CO
                               xcase
                        ELSE xif
                        FI
                 ELSE faultp(140, i, 0, NIL);
                        CO bool, int or union required here - not .1 CO
                        xcase
                 FI
           ESAC;
     IF bangdi ANDTH j = 56 ANDTH i /= faultmode CO if CO
     THEN fault(193)
            CO bool required after if CO
     FI;
     bangdi := i /= faultmode;
     type OF vss := t1
    ),

CO<cc4>: at end of closedclause CO
    (outlevel -:= 1;
     vss := LOC VLIST := (v, 0, vss)
    ),

CO<cc3>: after afterbang CO
    (vl1 := vss;
     vss := rest OF vss;
     rest OF vl1 := vl;
     vlist OF v OF vss := vl1;
     vl := vss;
     v := v OF vss;
     vss := rest OF vss
    ),

CO<checkbang1>:CO
    IF brind > 1
    THEN i := CASE brackets[brind - 1] - 53
                IN 45, 44, 46, 47
                ESAC;
           IF i = 44
           THEN faultp(203, 0, 0, id1 := idmess(bangtype + 3))
                  CO .3 not expected here CO
           ELIF bangtype /= i
           THEN faultp(118, 0, 0, id1 := idmess(i + 3))
                  CO .3 expected here CO
           FI
    ELSE brackets[brind] := 54;
           brind +:= 1
    FI,

CO<checkbang2>:CO
    (i := CASE brackets[brind - 1] - 53
          IN 45, 44, 48, 49
          ESAC;
     IF i = 44
     THEN faultp(203, 0, 0, id1 := idmess(bangtype + 3))
            CO .3 not expected here CO
     ELIF bangtype /= i
     THEN faultp(118, 0, 0, id1 := idmess(i + 3))
            CO .3 expected here CO
     FI
    ),


CO<then1>: after then sc CO
    vss := LOC VLIST := (v, xthen, vss),

CO<el1>: at end of else clause CO
    (vl := vss;
     vss := rest OF vss;
     rest OF vl := LOC VLIST := (v, xelse, NIL)
    ),

CO<el2>: no else CO
    (vl := vss;
     vss := rest OF vss;
     rest OF vl := NIL
    ),

CO<cs1>: after sc in case CO
    (vss := LOC VLIST := (v, xcomma, vss);
     IF ((props OF v OF vlist AND labsemi) /= z OREL exitinrange)
          ANDTH bangdi
     THEN fault(159)
            CO elements of in-parts must be units CO
     FI
    ),

CO<cs5>: after first sc in case CO
    (vss := LOC VLIST := (v, xin, vss);
     IF ((props OF v OF vlist AND labsemi) /= z OREL exitinrange)
          ANDTH bangdi
     THEN fault(159)
            CO elements of in-parts must be units CO
     FI
    ),

CO<cs2>: out case CO
    vl := LOC VLIST := (v, xout, NIL),

CO<cs3>: no out case CO
    vl := NIL,

CO<cs4>: construct vlist CO
    (vl1 := vss;
     vss := rest OF vss;
     rest OF vl1 := vl;
     vl := vl1
    ),

CO<cs6>: after !: in case CO
    IF NOT bangdi
    THEN next := t1;
           t1 := 29
           CO allows any continuation if unknown mode in enquiry CO
    FI,

CO<coll1>: element of collateral CO
    (vss := LOC VLIST := (v, xcollcomma, vss);
     IF (props OF v OF vlist AND labsemi) /= z OREL exitinrange
     THEN fault(200)
            CO elements of collaterals must be units CO
     FI
    ),

CO<coll2>: at end of collateral CO
    (type OF vl := xcoll;
     v := (z, -2, vl, NIL)
    ),

CO<coll3>: last in coll CO
    (vl := LOC VLIST := (v, xcollcomma, NIL);
     IF (props OF v OF vlist AND labsemi) /= z OREL exitinrange
     THEN fault(200)
            CO elements of collaterals must be units CO
     FI
    ),

CO<un1>: union case CO
    (vss := LOC VLIST := (v, xcommau, vss);
     IF (props OF v OF vlist AND labsemi) /= z OREL exitinrange
     THEN fault(159)
            CO elements of in-parts must be units CO
     FI
    ),

CO<un2>: out union case CO
    vl := LOC VLIST := (v, xoutu, NIL),

CO<un3>: union in CO
    (vss := LOC VLIST := (v, xinu, vss);
     IF (props OF v OF vlist AND labsemi) /= z OREL exitinrange
     THEN fault(159)
            CO elements of in-parts must be units CO
     FI
    ),

CO<elifouse>: CO
    props OF v := props OF v OR elifousebit,

CO<prid>: before id in primary CO
    (id := findid;
     output(decno OF id, outlevel);
     IF burestrict ANDTH
          (decno OF id <= lastkept ANDTH decno OF id >= 0
                            OREL decno OF id >= startlib
                           )
     THEN testkept(mode OF id)
     FI;
     adjscope(rd OF current, level OF id, scope OF id);
     vss := LOC VLIST := ((z, IF mode OF id = 0
                                      CO possible after recovery CO
                                 THEN faultmode
                                 ELSE mode OF id
                                 FI, NIL, NIL
                             ), 0, vss
                            )
    ),

CO<gen1>: generators CO
    (IF type = 1
     THEN fault(141)
            CO bounds required in generators CO
     FI;
     type := 1;
     IF NOT heap
     THEN props OF current := props OF current OR locgenbit
     FI;

     IF modeproc OF am = 0
     THEN output(XGEN (mode OF am + refmark, NOT heap), outlevel)
     ELSE output(NOT heap, outlevel);
            output(XOPER (xparampack, mproc(mode OF am), 1), outlevel);
            output(XOPER (xcall, mode OF am, 1 + ABS heap), outlevel);
            output(XOPER (xstatgrab, mode OF am + refmark,
                            ABS NOT heap
                           ), outlevel)
     FI;
     heap := FALSE;
     vss := LOC VLIST := ((assmntbit,
                              mode OF am + refmark, NIL, NIL
                             ), 0, vss)
    ),

CO<hp1>:  CO
    heap := TRUE,

CO<lab1>: goto lab CO
    (lab := labs OF current;
     WHILE (lab ISNT nillab) ANDTH name OF lab /= ident
     DO lab := rest OF lab OD;
     IF lab IS nillab
     THEN lab := labs OF current := HEAP LABEL
                := (ident, labno +:= 1, 1, labs OF current)
     FI;
     output(lab, outlevel);
     vss := LOC VLIST := ((z, gotomode, NIL, NIL), 0, vss)
    ),


CO<call1>: before ( in call CO
    (i := pmode(hcf(v OF vss));
     strong(v OF vss, i, TRUE);
     CASE modes[i]
     IN (REF PROCP pp):
                proclist := LOC PROCLIST := (pp, 0, i, proclist)
     OUT IF i /= faultmode
           THEN faultp(142, i, 0, NIL)
                  CO proc with parameters required here, not .1 CO
           FI;
           proclist := LOC PROCLIST := ((faultmode, NIL), 0, i, proclist)
     ESAC
    ),

CO<call2>: after parameter CO
    (IF deproc OF p OF proclist /= faultmode
     THEN IF pars OF p OF proclist ISNT nilml
            THEN strong(v OF vss,
                          mode OF pars OF p OF proclist, TRUE
                         );
                   pars OF p OF proclist := rest OF pars OF
                                                p OF proclist;
                   n OF proclist +:= 1
            ELSE deproc OF p OF proclist := faultmode;
                   fault(143)
                   CO too many parameters CO
            FI
     FI;
     vss := rest OF vss
    ),

CO<call3>: after ) in call CO
    (IF burestrict
     THEN fault(108)
            CO no proc calls CO
     FI;
     output(XOPER (xparampack, procmode OF proclist,
                     n OF proclist
                    ), outlevel);
     output(XOPER (xcall, i := deproc OF p OF proclist, 0), outlevel);
     IF ABS marker(i) >= 2
     THEN dybits OF current := dybits OF current OR dyprocbit
     FI;
     IF (pars OF p OF proclist ISNT nilml) ANDTH i /= faultmode
     THEN fault(144)
            CO too few parameters CO
     FI;
     v OF vss := (z, i, NIL, NIL);
     proclist := rest OF proclist
    ),

CO<code1>:  after CODE  CO
    codestack := LOC CODESTACK := (IF am ISNT nilam
                                       THEN mode OF am
                                       ELSE voidmode
                                       FI, 0, codestack
                                      ),

CO<code2>:  after code parameter  CO
    (nopars OF codestack +:= 1;
     vss := rest OF vss
    ),

CO<code3>:  before codestring  CO
    (output(XCODE (mode OF codestack, nopars OF codestack), outlevel);
     vss := LOC VLIST := ((z, mode OF codestack, NIL, NIL), 0, vss);
     codestack := rest OF codestack
    ),

CO<code4>:  after CODE without mode  CO
    am := NIL,

CO<den>:CO
    vss := LOC VLIST := ((z, m, NIL, NIL), 0, vss),

CO<bool>:CO
    (m := bool;
     output(t1 = 19, outlevel)
    ),

CO<nil>:CO
    (m := nilmode;
     output(nil, outlevel)
    ),

CO<skip>:CO
    (m := skipmode;
     output(skip, outlevel)
    ),

CO<empty>: CO
    (m := voidmode;
     output(empty, outlevel)
    ),

CO<str1>:CO
    (str[ : stringsize] := string[ : stringsize];
     n := noofchars;
     strsize := stringsize;
     strbase := stringbase
    ),

CO<str2>:CO
    (IF strsize /= 0
     THEN output(XCHARS (-strsize, strbase, str[ : strsize]), outlevel)
     FI;
     str[ : stringsize] := string[ : stringsize];
     n +:= noofchars;
     strsize := stringsize;
     strbase := stringbase
    ),

CO<str3>:CO
    output(XCHARS (strsize, strbase, IF strsize /= 0
                                       THEN str[ : strsize]
                                       ELSE emptystring
                                       FI
                    ), outlevel),

CO<str4>:  before string as primary CO
    outlevel +:= 1,

CO<str5>:  after string as primary CO
    (m := IF n = 1
          THEN char
          ELSE insertis(char, n)
          FI;
     output(up, outlevel);
     outlevel -:= 1;
     XSTRING xst;
     strmode OF xst := m;
     output(xst, outlevel);
     output(down, outlevel)
    ),

CO<pointonly>:CO
    stringsize := 1,

CO<point>:CO
    (string1 := "r";
     isint := FALSE;
     string[stringsize +:= 1] := dchar
    ),

CO<exp>:CO
    (string1 := "r";
     isint := FALSE;
     string[stringsize +:= 1] := pchar
    ),

CO<sign>:CO
    (IF t1 > 0 ANDTH t1 < 10
     THEN IF cbiop = biminus
            THEN string[stringsize] := nchar
            ELIF cbiop /= biplus
            THEN fault(145)
                   CO illegal exponent CO
            FI
     FI;
     isint := FALSE
    ),

CO<nu>:CO
    (m := IF string1 = "r"
          THEN real
          ELIF string1 = "a"
          THEN int
          ELSE bits
          FI + nolongs;
     output(XNUMBER (m, IF stringsize /= 0
                          THEN string[ : stringsize]
                          ELSE emptystring
                          FI
                       ), outlevel)
    ),

CO<alien>:CO
    (vss := LOC VLIST := ((z, mode, NIL, NIL), 0, NIL);
     almode OF xal := mode;
     output(xal, outlevel)
    ),

CO<nolongs>:CO
    IF nolongs < 6
    THEN nolongs := 0
    ELSE nolongs -:= 10
    FI,

CO<vac>:CO
    (m := vacmode;
     output(empty, outlevel)
    ),

CO<fm1>: before diadic op CO
    (outlevel +:= 1;
     opstack := LOC OPSTACK := (compsymb, comphash, cinst,
                                   TRUE, cbiop, clibop, opstack
                                  )
    ),

CO<fm2>: before monadic op CO
    opstack := LOC OPSTACK := (compsymb, comphash, cinst,
                                  FALSE, cbiop, clibop, opstack
                                 ),

CO<fm3>: after all ops CO
    (INT l, r, l1, r1, op, found, ans;
     REF INST inst, inst1;
     BOOL di = diadic OF opstack;
     BOOL  libop:= lib OF opstack;
     INT usedlib;
     CO   0  at start, op not from library
          1  at start, op from library
          2  for second pass, not called bumodule
          3  for second pass, having called bumodule
     CO

     r1 := mode OF v OF vss;
     l1 := IF di
           THEN mode OF v OF rest OF vss
           ELSE 0
           FI;

     IF r1 /= faultmode ANDTH l1 /= faultmode
     THEN IF r1 = skipmode OREL l1 = skipmode
            THEN GOTO notfound
            FI;

            inst1 := i OF opstack;
            usedlib := ABS ((inst1 ISNT nilinst)
                              ANDTH level OF inst1 = -1
                             );
findop:
            found := 0;
            WHILE (inst1 ISNT nilinst)
                    ANDTH (found <= 1 OREL i = level OF inst1)
            DO i := IF di = (lmode OF inst1 /= 0)
                      THEN firmto(v OF vss, rmode OF inst1)
                      ELSE 0
                      FI;
                 IF i > 1 ANDTH di
                 THEN j := firmto(v OF rest OF vss, lmode OF inst1);
                        IF j < i THEN i := j FI
                 FI;
                 IF i > 1 ANDTH i = found  ANDTH level OF inst1 > 0
                 THEN faultp(146, 0, 0, name OF opstack);
                        CO more than one version of .3 CO
                        GOTO flt
                 ELIF i > found
                 THEN found := i;
                        inst := inst1
                 FI;
                 i := level OF inst1;
                 inst1 := rest OF inst1
            OD;

            IF found > 1
            THEN l := lmode OF inst;
                   r := rmode OF inst;
                   ans := ans OF inst;
                   op := decno OF inst;
                   adjscope(rd OF current, level OF inst, scope OF inst);
                   GOTO fnd
            ELIF usedlib < 2
            THEN r := hcf(v OF vss);
                   l := IF di
                        THEN hcf(v OF rest OF vss)
                        ELSE 0
                        FI;
                   IF (op := biop OF opstack) /= 0
                        ANDTH findbiop(l, r, ans, op)
                   THEN  GOTO fnd
                   FI;

                   { ???? The reader would already have found it ???? DCT }
                   IF usedlib = 0
                   THEN usedlib := 2;
                          REF INDIC ri := libinds[hash OF opstack];
                          libop:= TRUE;
                    aa:   WHILE ri ISNT nilind
                          DO IF name OF opstack = name OF ri
                               THEN CASE u OF ri
                                      IN (REF OPER op):
                                                (inst1 := i OF op;
                                                 GOTO findop
                                                )
                                      OUT GOTO notfound
                                      ESAC
                               ELSE ri := rest OF ri
                               FI
                          OD;

                          IF usedlib = 2
                          THEN usedlib := 3;
                                 op := type OF charset[ABS (name OF
                                                         opstack)[1]];
                                 bumodule(name OF opstack,
                                       2 + ABS NOT (op /= 3 ANDTH op /= 6)
                                         );
                                 libop:= TRUE;
                                 ri := libinds[hash OF opstack];
                                 GOTO aa
                          FI
                   FI
            FI;

            CO op not declared CO
notfound:   IF di
            THEN faultp(147, l1, r1, name OF opstack)
            ELSE faultp(148, r1, 0, name OF opstack)
            FI
     FI;
flt:
     IF di THEN outlevel -:= 1 FI;
     ans := faultmode;
     GOTO anslab;
fnd:
     strong(v OF vss, r, TRUE);

     IF di
     THEN output(up, outlevel);
            outlevel -:= 1;
            strong(v OF rest OF vss, l, TRUE);
            IF -op = booland
            THEN output(xwandth, outlevel)
            ELIF -op = boolor
            THEN output(xworel, outlevel)
            ELIF -op >= minplus ANDTH -op <= maxdiv
            THEN output(xwplusabetc, outlevel)
            FI;
            output(down, outlevel)
     FI;

     IF ABS marker(ans) >= 2
     THEN dybits OF current := dybits OF current OR dyprocbit
     FI;

     IF op <= 0
     THEN output(XOPER (IF di
                            THEN xdyop
                            ELSE xmonop
                            FI, ans, -op), outlevel)
     ELSE   IF burestrict  ANDTH  NOT libop
            THEN   fault(149)
                   CO decs module restriction: library operators only CO
            FI;
            output(XOPER (xparampack, opproc(inst),
                            IF di THEN 2 ELSE 1 FI
                           ), outlevel);
            output(op, outlevel);
            output(XOPER (xcall, ans, 4), outlevel)
     FI;
anslab:
     IF di THEN vss := rest OF vss FI;
     v OF vss := (z, ans, NIL, NIL);
     opstack := rest OF opstack
    ),

CO<fm4>: faultindic as operator CO
    (vss := rest OF vss;
     mode OF v OF vss := faultmode
    ),

CO<cast1>: CO
    (strong(v OF vss, mode OF am, TRUE);
     props OF v OF vss := props OF v OF vss OR assmntbit
    ),

CO<checkvm>: CO
    (IF type = 2
     THEN fault(150)
            CO bounds not required here CO
     FI;
     mode OF am := deflex(mode OF am)
    ),

CO<cast4>:CO
    strong(v OF vss, voidmode, TRUE),

CO<ass1>: CO
    (IF (m := hcf(v OF vss)) /= faultmode
     THEN WHILE m < refmark
            DO CASE modes[m]
                 IN (REF PRC p):
                             m := deproc OF p
                 OUT fault(151);
                       CO lhs of assignment must be a ref CO
                       mode OF v OF vss := faultmode;
                       GOTO l
                 ESAC
            OD
     FI;
     strong(v OF vss, m, TRUE);
     IF ABS assmarker(m - refmark) <= 2
     THEN output(xwass, outlevel)
     FI;
 l:  SKIP
    ),

CO<ass2>: CO
    (m := mode OF v OF rest OF vss;
     IF m /= faultmode
     THEN strong(v OF vss, deflex(m -:= refmark), TRUE);
            assign(m)
     FI;
     vss := rest OF vss;
     props OF v OF vss := props OF v OF vss OR assmntbit
    ),

CO<sel1>: CO
    selstack := LOC SELSTACK := (ident, selstack),

CO<sel2>: CO
    (weak(v OF vss);
     IF (m := mode OF v OF vss) /= faultmode
     THEN n := 0;
            qref := ABS (BIN m AND BIN refmark);
            m := ABS (BIN m AND decsmask);

            CASE modes[m]
            IN (REF ARRAY a):
                       (m := mode OF a;
                        n := nods OF a;
                        TO n - 1
                        DO CASE modes[m]
                             IN (REF ARRAY a1):
                                       m := mode OF a1
                             ESAC
                        OD
                       )
            OUT SKIP
            ESAC;

            CASE modes[m]
            IN (REF STRCT s):
                       (REF SELIST sels := sels OF s;
                        BOOL found := FALSE;
                        FOR j
                        WHILE (sels ISNT nilsel) ANDTH NOT found
                        DO IF name OF sels = name OF selstack
                             THEN i := j;
                                    m := mode OF sels;
                                    found := TRUE;
                                    FOR nods TO n
                                    DO m := insertarray(m, nods, 1) OD;
                                    output(XOPER (xselect, m +:= qref, i),
                                           outlevel)
                             ELSE sels := rest OF sels
                             FI
                        OD;
                        IF NOT found
                        THEN faultp(152, 0, 0, name OF selstack);
                               CO selector not defined for struct CO
                               m := faultmode
                        FI
                       )
            OUT faultp(153, mode OF v OF vss, 0, NIL);
                  CO .1 cannot be selected CO
                  m := faultmode
            ESAC;

            v OF vss := (z, m, NIL, NIL)
     FI;
     selstack := rest OF selstack
    ),

CO<index>: CO
    (strong(v OF vss, int, TRUE);
     vss := rest OF vss;
     noofinds OF indstack +:= 1
    ),

CO<lb>: CO
    (strong(v OF vss, int, TRUE);
     vss := rest OF vss;
     bits OF indstack := bits OF indstack OR BIN 9
    ),

CO<ub>: CO
    (strong(v OF vss, int, TRUE);
     vss := rest OF vss;
     bits OF indstack := bits OF indstack OR BIN 10
    ),

CO<at>: CO
    (strong(v OF vss, int, TRUE);
     vss := rest OF vss;
     bits OF indstack := bits OF indstack OR BIN 12;
     vector OF indstack := FALSE
    ),

CO<colon>: CO
    bits OF indstack := bits OF indstack OR BIN 8,

CO<trim>: CO
    (nooftrims OF indstack +:= 1;
     BITS bi := bits OF indstack;
     j := ABS (bi >= z1);
     IF bi >= BIN 2 THEN j +:= 1 FI;
     IF bi >= BIN 4 THEN j +:= 1 FI;
     output(XOPER (xtrim, ABS bi, j), outlevel);
     bits OF indstack := z
    ),

CO<ind1>: CO
    (indstack := LOC INDSTACK := (0, 0, TRUE, z, indstack);
     weak(v OF vss);
     IF (m := mode OF v OF vss) /= faultmode
     THEN CASE modes[ABS (BIN m AND decsmask)]
            IN (REF ARRAY a):
                      vector OF indstack := FALSE,
                 (REF VCTOR v1):
                      SKIP,
                 (REF ISTRUCT is):
                      coerce(v OF vss, m,
                             insertvec(imode OF is, 1)
                                       + ABS (BIN m AND BIN refmark),
                             all, TRUE
                            ),
                 (REF STEN rs):
                      IF m > refmark
                      THEN deref(v OF vss)
                      FI
           OUT faultp(155, m, 0, NIL);
                 CO .1 cannot be indexed CO
                 mode OF v OF vss := faultmode
           ESAC
     FI;
     output(IF t1 = 59 THEN xwindex ELSE xwforall FI, outlevel)
    ),

CO<ind2>: CO
    (m := mode OF v OF vss;
     n := xsimpleindex;
     IF m /= faultmode
     THEN qref := ABS (BIN m AND BIN refmark);
            m := ABS (BIN m AND decsmask);
            i := noofinds OF indstack;
            j := nooftrims OF indstack;
            CASE modes[m]
            IN (REF ARRAY a):
                      IF nods OF a /= i + j
                      THEN fault(156);
                             CO wrong number of indices CO
                             m := faultmode
                      ELIF i = 0 ANDTH deflex OF a < 0
                      THEN m := insertarray(mode OF a, nods OF a, 1)
                                  + qref
                      ELSE TO i
                             DO CASE modes[m]
                                  IN (REF ARRAY a1):
                                             m := mode OF a1
                                  ESAC
                             OD;
                             m +:= qref
                      FI,
                (REF VCTOR v1):
                      IF i + j /= 1
                      THEN fault(157);
                             CO only one index needed CO
                             m := faultmode
                      ELIF NOT vector OF indstack
                      THEN m := insertarray(vecmode OF v1, 1, 1) + qref
                      ELIF i = 0 ANDTH deflex OF v1 < 0
                      THEN m := insertvec(vecmode OF v1, 1) + qref
                      ELSE m := IF i = 0
                                  THEN m
                                  ELSE vecmode OF v1
                                  FI + qref
                      FI,
                (REF STEN rs):
                      IF j /= 0 OREL i /= 1
                      THEN fault(158);
                             CO only one subscript allowed for straight CO
                             m := faultmode
                      ELSE m := mode OF rs;
                             n := xstrindex
                      FI
            ESAC;

            output(XOPER (IF j = 0
                            THEN n
                            ELSE xtrimindex
                            FI, m, i + j), outlevel);
            v OF vss := (z, m, NIL, NIL)
     FI;
     indstack := rest OF indstack
    ),

CO<enq2>: CO
    v := enqv,

CO<enqexituc>: CO
    (heapvalue(v);
     GOTO exituc
    ),

CO<lkam>: CO
    (am := LOC AMODE := lkscam;
     type := lktype
    ),

CO<uclk>: CO
    IF t1 = 24
    THEN t1 := 90;
           charpos OF xcharpos := tind;
           output(xcharpos, outlevel);
           lookahead
    FI

CO<syntax stack overflow>CO
    OUT abort(207)

ESAC
OD;

exituc:
        charpos OF xcharpos := tind;
        output(xcharpos, outlevel);
        v
END;

uc1 := uc;

CO ********************************************************************** CO

scstart:

DO
CASE
 analyser IN


CO<range* > :  CO

CO<reader>:  CO
    t1 := reader(nscreader),

CO<failure>:  CO
    (fault(138);
     CO unexpected symbol CO
     recovery(screader)
    ),

CO<sccheckuf>: CO
    ( INT i = CASE 2 IN 1 ESAC; SKIP ) ,

CO<scchecksc>: CO
    SKIP,

CO<ch>: commah CO
    IF t1 = 28 THEN t1 := 68 FI,

CO<prg1>:   CO
    (outlevel := 2;
     name OF xm := ident;
     nscreader := screader
    ),

CO<prg2>:   CO
    (outlevel := 2;
     name OF xm := ident;
     type OF xm := -1;
     brind := 2;
     burestrict := TRUE
    ),

CO<prg3>: after compose closure CO
    (YMODINFO y := givemoduledetails(name OF close, 0, TRUE);
     l OF xm := l OF xmi OF y;
     g OF xm := g OF xmi OF y;
     output(xm, 0);
     moduleno := closure(close, NIL);
     output(XCONTROL (xfinish, 0, z, 0), outlevel);
     outlevel := 1;
     output(XCOMPTYPE (moduleno, type OF xm, nextmodule), outlevel);
     output(down, outlevel)
    ),

CO<prg4>:  before main body of prog CO
    (outlevel := 3;
     output(XOPENMODULE (name OF xm,
                           level OF l OF xm + level OF g OF xm,
                           type OF xm, moduleno := nextmodule +:= 1
                          ),  outlevel
           );
     inprogram := TRUE;
     IF t1 = 24
          CO ord CO
     THEN lastid OF current +:= 1;
            output(XIDDEC (xdummydec,
                             LOC IDDEC := (nullid, lastid OF current, 1, 0,
                                              lastid OF current, NIL
                                             )
                             ), 4);
            props OF current := BIN - 1
     FI;

     charpos OF xcharpos := tind;
     output(xcharpos, outlevel);

     uc(voidmode);
     scopel(labs OF current, labs OF external);
     output(XCLOSEMODULE (moduleno, type OF xm), outlevel);
     output(XCONTROL (xfinish, 0, z, 0), outlevel);
     outlevel := 1;
     output(XSIZES (lastrd - startrd, lastmode, labno, maxident,
                      nextmodule, nextlibno - startlib
                     ), outlevel);
     output(modes[ : lastmode], outlevel);
     output(XTDTYPE (moduleno, type OF xm), outlevel);
     output(down, outlevel);
     output(down, 2)
    ),

CO<prg5>: new proxies CO
    (tempprl := prl;
     WHILE (tempprl ISNT nilprl) ANDTH name OF tempprl /= ident
     DO tempprl := rest OF tempprl OD;
     IF tempprl IS nilprl
     THEN prl := HEAP PROXYL := (ident, type OF xm +:= 1, prl)
     ELSE faultp(197, 0, 0, ident)
            CO hole .3 already declared CO
     FI
    ),

CO<prg6>: end of bu module CO
    (VECTOR[makekeepinfo(kl, FALSE, NIL, NIL, NIL)]CHAR kspec;
     VECTOR[compsize]INT decnos, modenos;
     makekeepinfo(kl, TRUE, kspec, decnos, modenos);
     output(decnos, outlevel);
     output(XCONTROL (xfinish, 0, z, 0), outlevel);
     outlevel := 1;
     IF lastid OF current > maxident
     THEN maxident := lastid OF current
     FI;
     output(XSIZES (lastrd - startrd, lastmode, labno, maxident,
                      nextmodule, nextlibno - startlib
                     ), outlevel);
     output(modes[ : lastmode], outlevel);
     output(XBUTYPE (decnos, modenos), outlevel);
     output(down, outlevel);
     output(down, 2);
     output(XSPEC (name OF xm, 0, level OF l OF xm,
                     level OF g OF xm, kspec
                    ), 0);
     labs OF globinfo := labs OF current
    ),

CO<prg7>: after conuse in decs module CO
    (lastkept := lastid OF current;
     outlevel := 3;
     nscreader := screader
    ),

CO<con1>:   CO
    f OF l OF xm := ident,

CO<con2>:    CO
    (n OF l OF xm := ident;
     level OF l OF xm := 1
    ),

CO<con3>:  void context CO
    g OF xm := l OF xm := (spaces, spaces, 0),

CO<con4>: default context; identifiers are stdprelude and program  CO
    l OF xm := (idmess(58), idmess(57), 1),

CO<con5>:  expand context CO
    (IF level OF l OF xm /= 0
     THEN YMODINFO yml := givemoduledetails(n OF l OF xm, 0, FALSE),
                       ymg;
            REF XMODINFO xml = xmi OF yml;
            IF type OF xml >= 0
            THEN g OF xm := IF level OF g OF xml /= 0
                                THEN g OF xml
                                ELSE l OF xml
                                FI;
                   IF level OF g OF xm /= 0
                   THEN ymg := givemoduledetails(n OF g OF xm,
                                                   0, FALSE
                                                  );
                          treatspec(n OF g OF xm,
                                    f OF g OF xm, ym OF ymg
                                   )
                   FI;
                   treatspec(n OF l OF xm, f OF l OF xm, ym OF yml);
                   level OF l OF xm := modulelevel - level OF g OF xm
            ELSE CO decs or not found CO
                   faultp(IF type OF xml = -1
                          THEN 199
                          ELSE 160
                          FI, 0, 0, n OF l OF xm)
            FI
     FI;
     output(xm, 0)
    ),

CO<con6>:     CO
    bumodule(ident, 0),

CO<con7>:      CO
    IF t1 = 32 THEN t1 := 85 FI,


CO<subst1>:   CO
    (testsubst := substack;
     substlevel +:= 1;
     WHILE (testsubst ISNT nilsubl) ANDTH
             (proxy OF testsubst /= ident
              OREL level OF testsubst /= substlevel
             )
     DO testsubst := rest OF testsubst OD;

     IF testsubst ISNT nilsubl
     THEN faultp(198, 0, 0, ident)
            CO formal .3 used twice CO
     FI;
     substack := HEAP SUBLIST := (ident, substlevel, close, substack)
    ),

CO<subst2>:   CO
    (a OF substack := HEAP CLOSURE := (ident, NIL);
     substlevel -:= 1
    ),

CO<subst3>:    CO
    (a OF substack := close;
     substlevel -:= 2
    ),

CO<subst4>:      CO
    (a OF substack := findproxy(ident);
     substlevel -:= 1
    ),

CO<subst5>:     CO
    (tsubst := substack;
     substack := rest OF substack;
     rest OF tsubst := sublist;
     sublist := tsubst
    ),

CO<subst6>:    CO
    sublist := NIL,

CO<subst7>:    CO
    (close := HEAP CLOSURE := (proxy OF substack, sublist);
     substack := rest OF substack
    ),

CO<kl1>:  keep id CO
    (addtokl(id := findid);
     adjscope(rd OF current, level OF id, scope OF id)
    ),

CO<kl2>: keep modename CO
    addtokl(cindic),

CO<kl3>:  keep op CO
    (indic := cindic;
     IF indic IS nilind
     THEN fault(196)
            CO built-in operators may not be kept CO
     FI;
     inst1 := cinst;
     j := declarer(FALSE, scam);
     i := 0
    ),

CO<kl5>: end of keep op CO
    (WHILE (inst1 ISNT nilinst)
             ANDTH (i /= lmode OF inst1 OREL j /= rmode OF inst1)
     DO inst1 := rest OF inst1 OD;
     IF inst1 IS nilinst
     THEN IF indic ISNT nilind
            THEN faultp(161, 0, 0, compsymb := name OF indic)
                   CO op not declared for these modes CO
            FI
     ELSE adjscope(rd OF current, level OF inst1, scope OF inst1);
            addtokl(ONEOP (indic, inst1))
     FI
    ),

CO<kl4>: keep diadic op CO
    (i := j;
     j := declarer(FALSE, scam)
    ),

CO<hole1>:    CO
    (rkl := kl := NIL;
     IF rd OF current ISNT (REF RDEN (NIL))
     THEN props OF rd OF current := props OF rd OF current
                                          OR holebit
     FI;
     substack := HEAP SUBLIST := (ident, substlevel, close, NIL)
    ),

CO<hole2>:    CO
    (VECTOR[makekeepinfo(kl, FALSE, NIL, NIL, NIL)]CHAR kspec;
     VECTOR[compsize]INT decnos, modes;
     REF PROXYL p := findproxy(proxy OF substack);
     substack := rest OF substack;
     makekeepinfo(kl, TRUE, kspec, decnos, modes);
     INTTRIPLE kset := (1, IF level OF g OF xm = 0
                             THEN level OF l OF xm
                             ELSE level OF g OF xm
                             FI, 0);
     output(XSPEC (name OF p, no OF p, 1, j OF kset, kspec), 0);
     output(XCALLMODULE ((no OF p, 0), kset, decnos, 0), outlevel);
     v := (z, voidmode, NIL, NIL)
    ),


CO<mode1>: after modeind in mode dec CO
    (IF oldindichash
     THEN indics OF current := LOC VECTOR[64]REF INDIC :=
                                   indics OF current;
            oldindichash := FALSE
     FI;
     IF typechar1 /= 3 ANDTH typechar1 /= 6
     THEN faultp(154, 0, 0, compsymb);
            CO .3 is not a legal modename CO
            GOTO l
     FI;
     indic := (indics OF current)[comphash];
     WHILE (indic ISNT nilind)
             ANDTH level OF indic = level OF current
     DO IF name OF indic = compsymb
          THEN CASE u OF indic
                 IN (REF AMODE a):
                             IF modeproc OF a = 2
                             THEN am := a;
                                    GOTO out
                             FI
                 OUT SKIP
                 ESAC;
                 faultp(162, 0, 0, compsymb)
                 CO name already used at this level CO
          FI;
          indic := rest OF indic
     OD;
l:
     am := HEAP AMODE := (lastmode +:= 1, 2, NIL);
     indic := (indics OF current)[comphash]
           := LOC INDIC := (compsymb, level OF current,
                               lastid OF current, am,
                               (indics OF current)[comphash]
                              );
     modes[lastmode] := am;
out:  look := 2
    ),

 CO <sccalldec1>: rhs of mode dec  CO
    (i := mode  OF  am;
     substlevel := lastmode - i;
     untreated :=  HEAP  AMODELIST  := (am, untreated);
     j := declarer( TRUE , am);
      IF  type = 1
      THEN  fault(163)
             CO  bounds required in mode declaration  CO
      FI ;
      IF  ( BIN  (i - j)  AND  decsmask) = z
      THEN  fault(164);
             CO  mode defined as (ref to) itself  CO
            substitute(faultmode, i,firstmode)
      ELIF  j < refmark  ANDTH   CASE  modes[j]
                                 IN  ( REF  AMODE  a):
                                           IF  mode  OF  a = j
                                           THEN  am := a;
                                                  TRUE
                                           ELSE   FALSE
                                           FI
                                 OUT   FALSE
                                 ESAC
      THEN  untreated := rest  OF  untreated;
            u  OF  indic := am;
            lastmode -:= 1
      ELIF  j = lastmode  ANDTH  substlevel = 0
      THEN  modes[i] := modes[j];
            lastmode -:= 1;
            mode  OF  am := i
     ELSE   IF  i = lastmode
            THEN  lastmode -:= 1
            FI ;
           substitute(j, i,firstmode)
     FI
    ),

 CO <mdend>: at semi after mode decs  CO
    (
      FOR  i  FROM  lastmode BY -1  TO  firstmode
      DO   CASE  modes[i]
           IN  ( SAMEAS  s):
                      IF i = lastmode THEN lastmode-:=1 FI ,
               ( REF  AMODE  a):
                     (faultp(165, i, 0,  NIL );
                       CO  mode .1 not declared  CO
                      substitute(faultmode, i, firstmode);
                      modeproc  OF  a := 0
                     ),
               (REF UNN u): removedupl(flattenunion(u,()))
           OUT SKIP
           ESAC
      OD;
      IF firstmode < lastmode THEN
       accidental_eqs( (REF[]MDE(modes))[firstmode:lastmode AT firstmode])
      FI;
      FOR i FROM firstmode TO lastmode DO
       REF MDE mi = modes[i];
       CASE mi IN
         (SAMEAS): SKIP
       OUT
         FOR j FROM newmode1 TO firstmode-1 DO
          IF MODETAG mi = MODETAG modes[j] ANDTH equality(i,j,firstmode-1) THEN
            FORALL pi IN test_flex[:last_flex] DO
               substitute(jOFpi,iOFpi,firstmode)
            OD;
            GOTO end
          FI;
         end:SKIP
         OD
       ESAC
      OD;


     checkmodes(untreated);
     modevars(untreated);
     untreated :=  NIL
    ),

CO<endsc1>:CO
    (scopel(labs OF v OF vlist, labs OF external);
     GOTO exitsc
    ),

CO<endsch>: after hole as uc CO
    GOTO exitsc,

CO<sc1>: before exity CO
    (tidyv(v);
     vlist := (v, xbegin, NIL)
    ),

CO<sc2>: after each exit clause CO
    (tidyv(v);
     props OF current := props OF current AND notdontpull;
     props OF v OF vlist := props OF v OF vlist
                                       OR props OF current OR exitbit;
     vl := vlist;
     IF saveexit ISNT nilbool
     THEN saveexit := TRUE
     FI;
     WHILE rest OF vl ISNT nilvl
     DO vl := rest OF vl OD;

     rest OF vl := globvlist := (v, xexit, NIL)
    ),

CO<duc1>: after each semi CO
    (props OF current := props OF current OR semibit;
     output(XCONTROL (xsemi, 0, dybits OF current, 0), outlevel);
     dybits OF current := z
    ),

CO<dontlook>: stops lookup of indics in library CO
    (look := 0;
     IF t1 = 65
          CO mode CO
     THEN descno := 1;
            IF modedecdepth > 0
            THEN CO nested mode decs not allowed CO
                   fault(202)
            FI;
            firstmode := lastmode + 1
     FI
    ),

CO<extrasemi>: CO
    (fault(166);
     CO semicolon not needed here CO
     v := (z, faultmode, NIL, NIL)
    ),


CO<newop>:   CO
    (IF oldindichash
     THEN indics OF current := LOC VECTOR[64]REF INDIC :=
                                   indics OF current;
            oldindichash := FALSE;
            cindic := NIL
     FI;
     indic := (indics OF current)[comphash];
     WHILE (indic ISNT nilind) ANDTH level OF indic = level OF current
     DO IF name OF indic = compsymb
          THEN CASE u OF indic
                 IN (REF AMODE a):
                            faultp(183, 0, 0, compsymb)
                            CO name already mode at this level CO
                 OUT SKIP
                 ESAC
          FI;
          indic := rest OF indic
     OD;
     IF (cindic IS nilind) OREL level OF cindic < level OF current
     THEN (indics OF current)[comphash] := cindic := LOC INDIC :=
                  (compsymb, level OF current, lastid OF current,
                   LOC OPER := (IF t1 < 10
                                   THEN t1
                                   ELSE 1
                                   FI, cinst),
                   (indics OF current)[comphash]
                  )
     FI;
     indic := cindic;
     look := 2;
     id := NIL
    ),

CO<prio1>: priority dec CO
    (IF iv < 1 OREL iv > 9
     THEN fault(167);
            CO priority must lie between 1 and 9 CO
            iv := 1
     FI;
     props OF current := props OF current OR priobit;
     CASE u OF indic
     IN (REF OPER op):
                (IF prio OF op < 0
                 THEN fault(204)
                        CO priority already declared at this level CO
                 FI;
                 prio OF op := - iv
                )
     OUT SKIP
     ESAC
    ),

CO<opdec1>:  simple operator dec CO
    CASE u OF indic
    IN (REF OPER op):
                (i OF op := LOC INST := (0, 1, 0, level OF current, 0,
                                              lastid OF current, i OF op
                                             );
                 props OF current := props OF current OR decbit
                )
    OUT SKIP
    ESAC,

CO<scalldecop>: complicated operator mode CO
    (look := 2;
     props OF current := props OF current OR decbit;
     i := declarer(FALSE, scam)
    ),

CO<scalluc4>: evaluate uc in complicated op dec CO
    (uc(i);
     lastid OF current +:= 1;
     id := LOC IDDEC := (name OF indic, lastid OF current,
                            1, i, lastid OF current, NIL
                           );
     output(XIDDEC (xiddec, id), outlevel);
     j := k := decno OF id
    ),

CO<newinst>: of complicated op CO
    CASE u OF indic
    IN (REF OPER op):
              (i OF op := LOC INST := (0, 1, 0, level OF current,
                                            j, k, i OF op
                                           );
               CASE modes[i]
               IN (REF PROCP p):
                         (pl1 := pars OF p;
                          ans OF i OF op := deproc OF p;
                          IF rest OF pl1 ISNT nilml
                          THEN lmode OF i OF op := mode OF pl1;
                                 pl1 := rest OF pl1
                          FI;
                          rmode OF i OF op := mode OF pl1;
                          IF rest OF pl1 ISNT nilml
                          THEN faultp(168, 0, 0, name OF indic)
                                 CO operator has more than 2 operands CO
                          FI
                         )
               ESAC
              )
    OUT SKIP
    ESAC,

CO<biop>: CO
    (j := -iv;
     k := 0
    ),


CO<pi1>: proc dec CO
    (mode OF id := faultmode;
     scope OF id -:= 1;
     lastid OF current -:= 1;
     (REF REF IDDEC (rid)) := id;
     indic := NIL
    ),

CO<pa1>: proc var dec CO
    (mode OF id := refmark + faultmode;
     (REF REF IDDEC (rid)) := id;
     indic := NIL;
     props OF current := props OF current OR decbit OR vardecbit
    ),

CO<rden1>: before routine den CO
    (rd OF current := LOC RDEN := (nullid, z, 0, lastrd +:= 1, 0,
                                        level OF current, rd OF current
                                       );
     charpos OF xcharpos := tind;
     output(xcharpos, outlevel);
     outlevel +:= 1
    ),

CO<scalldecr3>: before parameter declarer CO
    declarer(FALSE, scam),

CO<fdec1>: declare parameter CO
    (output(XIDDEC (xfdec, id), outlevel);
     (REF REF IDDEC (rid)) := id;
     parlist := HEAP MODELIST := (mode OF id, parlist)
    ),

CO<scalldecr1>: parameter pack in routine CO
    (pl := NIL;
     WHILE parlist ISNT nilml
     DO pl1 := parlist;
          parlist := rest OF parlist;
          rest OF pl1 := pl;
          pl := pl1
     OD;
     i := declarer(FALSE, scam);
     mode OF rd OF current := j := insertprocp(i, pl);
     IF rdname ISNT nilid
     THEN mode OF rdname +:= (j - faultmode);
            IF mode OF rdname < refmark
            THEN decno OF rdname := lastrd;
                   name OF rd OF current := name OF rdname
            ELSE output(XIDDEC (xvardec, rdname), outlevel - 1)
            FI
     FI;
     IF indname ISNT nilind
     THEN name OF rd OF current := name OF indname;
            props OF rd OF current := props OF rd OF current
                                                  OR operatorbit;
            CASE u OF indname
            IN (REF OPER op):
                      (REF INST in := i OF op;
                       ans OF in := i;
                       decno OF in := lastrd;
                       IF rest OF pl ISNT nilml
                       THEN lmode OF in := mode OF pl;
                              pl := rest OF pl
                       FI;
                       rmode OF in := mode OF pl;
                       IF rest OF pl ISNT nilml
                       THEN faultp(168, 0, 0, name OF indname)
                              CO operator has more than 2 operands CO
                       FI
                      )
            OUT SKIP
            ESAC
     FI
    ),

CO<scallucr1>: body of routine CO
    (BOOL b = burestrict;
     burestrict := FALSE;
     uc(i);
     burestrict := b;
     BOOL format = name OF rd OF current = identformat;
     IF format
     THEN IF formatcaseno /= 0
            THEN outlevel +:= 3
            ELSE vlist := ((z, formatmode, NIL, NIL), 0, NIL);
                   lastrd -:= 1;
                   output(up, outlevel + 2);
                   GOTO exitsc
            FI
     FI;
     IF (rdname IS nilid) ANDTH (indname IS nilind)
     THEN props OF rd OF current := props OF rd OF current OR valbit
     FI;
     IF ABS marker(i) /= 1
     THEN props OF rd OF current :=
                                 props OF rd OF current OR dontpullbit
     FI;
     output(XCONTROL (xroutinend, 0,
                        props OF rd OF current
                                          AND (dontpullbit OR valbit), 0
                       ), outlevel);
     output(up, outlevel);
     outlevel -:= 1;
     scopel(labs OF v OF vlist, labl := NIL);
     output(rd OF current, outlevel);
     lab := labs OF v OF vlist;
     WHILE lab ISNT nillab
     DO output(XLABDEC (lab, TRUE), outlevel);
          lab := rest OF lab
     OD;
     WHILE labl ISNT nillab
     DO output(XLABDEC (lab := labl, TRUE), outlevel);
          labl := rest OF labl;
          rest OF lab := labs OF external;
          labs OF external := lab
     OD;
     output(down, outlevel);
     IF rdname IS nilid
     THEN IF indname IS nilind
            THEN vlist := ((z, IF format
                                 THEN formatmode
                                 ELSE mode OF rd OF current
                                 FI, NIL, NIL), 0, NIL)
            FI
     ELIF mode OF rdname > refmark
     THEN output(decno OF rdname, outlevel);
            output(xwass, outlevel);
            output(rdenno OF rd OF current, outlevel);
            output(XOPER (xassign, mode OF rdname, 1), outlevel);
            output(XOPER (xvoid, voidmode, 0), outlevel)
     FI;
     IF format
     THEN output(up, outlevel);
            outlevel -:= 2
     FI;
     GOTO exitsc
    ),

CO<scalldecr2>: ans mode in prc CO
    rdmode := declarer(FALSE, scam),

CO<scallscr1>: call of range for rd CO
    range(current, id, indic, NIL),

CO<rden2>: body of prc CO
    (mode OF rd OF current := j := insertprc(i := rdmode);
     IF indname ISNT nilind
     THEN faultp(170, 0, 0, name OF indname)
            CO operator must have operands CO
     ELIF rdname ISNT nilid
     THEN mode OF rdname +:= (j - faultmode);
            IF mode OF rdname < refmark
            THEN name OF rd OF current := name OF rdname;
                   decno OF rdname := lastrd
            ELSE output(XIDDEC (xvardec, rdname), outlevel - 1)
            FI
     FI
    ),


CO<scalldecu>:CO
    (ccmode := globccmode;
     m := declarer(FALSE, scam);
     CASE modes[IF m > refmark THEN int ELSE m FI]
     IN (REF UNN ru):
                (ml := modelist OF ru;
                 WHILE ml ISNT (REF MODELIST (NIL))
                 DO IF unite(NIL, mode OF ml, ccmode, 1, FALSE) = 0
                      THEN m := mode OF ml;
                             GOTO flt
                      FI;
                      ml := rest OF ml
                 OD;
                 j := - ccmode
                )
     OUT IF (j := unite(NIL, m, ccmode, 1, FALSE)) = 0
           THEN GOTO flt
           FI
     ESAC;
     output(XCONTROL (xuchoice, m, IF t1 = 32
                                          CO ident CO
                                     THEN decbit
                                     ELSE z
                                     FI, j), outlevel)
     EXIT
flt:
     faultp(171, m, ccmode, NIL);
     CO .1 not in .2 CO
     mode OF scam := faultmode
    ),

CO<endscu>:CO
    (globccmode := ccmode;
     scopel(labs OF v OF vlist, labs OF external);
     GOTO exitsc
    ),

CO<cconfid>: CO
    ((REF REF IDDEC (rid)) := id;
     output(XIDDEC (xccdec, id), outlevel)
    ),

CO<scalluc1>:CO
    v := uc(0),

CO<newid>: all identifier decs CO
    (givenmess := FALSE;
     IF oldidhash
     THEN ids OF current := LOC VECTOR[64]REF IDDEC
                             := ids OF current;
            oldidhash := FALSE
     FI;
     rid := (ids OF current)[idhash];
     id := rid;
     lastidchanged := TRUE;
     IF t1 = 32
     THEN WHILE (id ISNT nilid)
                    ANDTH level OF id = level OF current
            DO IF ident = name OF id ANDTH NOT givenmess
                 THEN givenmess := TRUE;
                        faultp(172, 0, 0, ident)
                        CO identifier already declared CO
                 FI;
                 id := rest OF id
            OD
     FI;
     lastid OF current +:= 1;
     id := LOC IDDEC := (IF t1 = 32
                            THEN ident
                            ELSE spaces
                            FI, lastid OF current, level OF current,
                            mode OF scam, lastid OF current, rid
                           )
    ),

CO<dummydec>:CO
    IF NOT (props OF current >= decbit)
    THEN lastid OF current +:= 1;
           output(XIDDEC (xdummydec,
                            LOC IDDEC := (nullid,
                                             lastid OF current,
                                             level OF current, 0,
                                             lastid OF current, NIL
                                            )
                            ), outlevel);
           props OF current := props OF current OR decbit;
           lastidchanged := TRUE
    FI,

CO<scalluc2>: before uc in identity dec CO
    (IF firstaidec
     THEN IF heap
            THEN fault(173);
                   CO heap not allowed here CO
                   heap := FALSE
            FI;
            IF type = 2
            THEN fault(174);
                   CO no bounds required in identity declaration CO
                   type := 0
            FI;
            firstaidec := FALSE
     FI;
     mode OF id := deflex(mode OF id);
     props OF current := props OF current OR decbit;
     lastid OF current -:= 1;
     IF t1 /= 92 CO biop CO
     THEN v := uc(mode OF id);
            lastid OF current := decno OF id;
            output(XIDDEC (xiddec, id), outlevel)
     FI;
     (REF REF IDDEC (rid)) := id
    ),

CO<identbiop>:CO
    (scope OF id := 0;
     decno OF id := -iv
    ),

CO<dvardec>: all var decs CO
    (props OF current := props OF current OR decbit OR vardecbit;
     IF firstaidec
     THEN IF type = 1
            THEN fault(175)
                   CO bounds required in variable declaration CO
            FI;
            firstaidec := FALSE
     FI;
     mode OF id +:= refmark;
     IF (i := (ABS (modeproc OF scam /= 0) + 1)) = 1 ANDTH heap
     THEN output(XGEN (mode OF id, FALSE), outlevel)
     FI;
     IF i /= 1
     THEN loadmodeproc(scam);
            output(NOT heap, outlevel);
            output(XOPER (xparampack, mproc(mode OF scam), 1), outlevel);
            output(XOPER (xcall, mode OF scam, 1 + ABS heap), outlevel);
            IF heap
            THEN output(XOPER (xstatgrab, mode OF id, 0), outlevel)
                   CO last parameter is ABS NOT heap CO
            ELSE props OF current := props OF current OR locdydecbit
            FI
     FI;

     IF heap OREL i /= 1
     THEN i := 2 + ABS heap;
            output(XIDDEC (IF heap
                             THEN xiddec
                             ELSE xivardec
                             FI, id), outlevel);
            IF t1 /= 11
            THEN output(XCONTROL (xsemi, 0, dontpullbit, 0), outlevel)
            FI;
            heap := FALSE
     FI
    ),

CO<scalluc3>: before uc in var dec CO
    (IF i /= 1
     THEN output(decno OF id, outlevel);
            IF ABS assmarker(mode OF scam) <= 2
            THEN output(xwass, outlevel)
            FI
     ELSE lastid OF current -:= 1
     FI;
     uc(deflex(mode OF scam));
     IF i /= 1
     THEN assign(mode OF scam);
            output(XOPER (xvoid, voidmode, 0), outlevel);
            output(XCONTROL (xsemi, 0, dybits OF current, 0), outlevel);
            props OF current := props OF current OR dybits OF current;
            dybits OF current := z
     ELSE lastid OF current +:= 1;
            output(XIDDEC (xivardec, id), outlevel)
     FI;
     IF i = 3 ANDTH t1 /= 11 THEN heap := TRUE FI;
     (REF REF IDDEC (rid)) := id
    ),

CO<vardec>: after id in uninitialised var decs CO
    (IF i = 1
     THEN output(XIDDEC (xvardec, id), outlevel)
     ELIF i = 3 ANDTH t1 /= 11
     THEN heap := TRUE
     FI;
     (REF REF IDDEC (rid)) := id
    ),

CO<labcheck>: before all iddecs CO
    IF props OF current >= labbit
    THEN fault(176);
           CO declaration not allowed after label CO
           props OF current := props OF current AND NOT labbit
    FI,

CO<labdec>:   CO
    (charpos OF xcharpos := tind;
     output(xcharpos, outlevel);
     lab := labs OF current;
     WHILE (lab ISNT nillab) ANDTH name OF lab /= ident
     DO lab := rest OF lab OD;

     IF lab IS nillab
     THEN lab := labs OF current := HEAP LABEL
                := (ident, labno +:= 1, 1, labs OF current)
     ELIF status OF lab = 0
     THEN faultp(177, 0, 0, ident)
            CO label .3 declared twice CO
     FI;

     id := (ids OF current)[idhash];
     WHILE (id ISNT nilid) ANDTH level OF id = level OF current
     DO IF ident = name OF id
          THEN faultp(205, 0, 0, ident)
                 CO label .3 already used as identifier CO
          FI;
          id := rest OF id
     OD;

     status OF lab := 0;
     props OF current := props OF current OR labbit;
     output(XLABDEC (lab, FALSE), outlevel)
    ),

CO<enq1>: CO
    IF t1 = 17
         CO bang CO
    THEN BITS b;
           IF (b := props OF v OF vlist) >= labbit
           THEN fault(178)
                  CO labels not allowed here CO
           FI;
           IF (b AND decprio) /=  z
           THEN t1 := 93
                  CO bong CO
           FI
    FI,

CO<enqsccalluc>: CO
    (enqv := v OF vlist;
     vlist := (uc(0), xbegin, NIL)
    ),

CO<scformat>:CO
    (IF formatproc = 0
     THEN formatunion := insertunion (HEAP MODELIST := (int,
                                      HEAP MODELIST := (formatmode, NIL))
                                    );
            formatproc := insertprocp(formatunion,
                                      HEAP MODELIST := (int, NIL)
                                     )
     FI;
     rd OF current := LOC RDEN := (identformat, ccbit, formatproc,
                                        lastrd +:= 1, 0,
                                        level OF current,
                                        rd OF current
                                       );
     i := formatunion;
     formatcaseno := 0
    ),

CO<do1>: CO
    (doint := 0;
     dobits := z;
     labs OF current := labs OF external;
     charpos OF xcharpos := tind;
     output(xcharpos, outlevel);
     output(xwloop, outlevel)
    ),

CO<scallscf>: dosc CO
    (vlist := range(current, NIL, NIL, NIL);
     outlevel -:= 1;
     v := IF rest OF vlist IS nilvl
          THEN v OF vlist
          ELSE (z, -1, vlist, NIL)
          FI;
     output(XCONTROL (xdo, voidmode,
                        props OF v AND notdontpull OR dybits OF current,
                        voidmode
                       ), outlevel);
     strong(v, voidmode, TRUE);
     output(XCONTROL (xsemi, 0, dybits OF current, 0), outlevel);
     output(XCONTROL (xod, 0, z, voidmode), outlevel);
     labs OF external := labs OF current;
     GOTO exitsc
    ),

CO<while>: CO
    (strong(v, bool, TRUE);
     output(up, outlevel);
     IF props OF current >= labbit
     THEN fault(169)
            CO labels not allowed after while CO
     FI;
     output(XCONTROL (xwhile, bool,
                        props OF current OR dybits OF current,
                        voidmode
                       ), outlevel - 1);
     output(down, outlevel - 1)
    ),

CO<scallucf5>: forall CO
    (rididlist := LOC RIDIDLIST := (rid, id, rididlist);
     doint +:= 1;
     lastid OF current -:= doint;
     v := uc(0);
     lastid OF current +:= doint;
     i := ABS(BIN (j := mode OF v) AND BIN refmark);
     CASE modes[j - i]
     IN (REF VCTOR rv):
               i := vecmode OF rv + i,
          (REF ARRAY ra):
               i := mode OF ra + i
     OUT faultp(179, j, 0, NIL);
           CO forall not defined for .1 CO
           i := faultmode
     ESAC;
     mode OF id := i
    ),

CO<forall>: CO
    (output(XCONTROL (xforall, 0, z, doint), outlevel);
     TO doint
     DO rest OF id OF rididlist := rid OF rididlist;
          (REF REF IDDEC (rid OF rididlist)) := id OF rididlist;
          output(XIDDEC (xforalldec, id OF rididlist), outlevel);
          rididlist := rest OF rididlist
     OD;
     outlevel +:= 1
    ),

CO<for>: CO
    (dobits := dobits OR z1;
     mode OF id := int;
     lastid OF current -:= 1
    ),

CO<scallucf2>: from CO
    (uc(int);
     dobits := dobits OR BIN 2;
     doint +:= 1
    ),

CO<scallucf3>: by CO
    (uc(int);
     dobits := dobits OR BIN 4;
     doint +:= 1
    ),

CO<scallucf4>: to CO
    (uc(int);
     dobits := dobits OR BIN 8;
     doint +:= 1
    ),

CO<ffbt>: CO
    (output(XCONTROL (xfor, 0, dobits, doint), outlevel);
     IF dobits >= z1
     THEN (REF REF IDDEC (rid)) := id;
            lastid OF current +:= 1;
            output(XIDDEC(xfordec, id), outlevel)
     FI;
     outlevel +:= 1
    ),

CO<checksemi>: CO
    IF t1 /= 11 ANDTH NOT (burestrict ANDTH t1 = 13 CO keep CO)
    THEN fault(180);
           CO declaration must be followed by semicolon CO
           v := (z, faultmode, NIL, NIL)
    ELSE charpos OF xcharpos := tind;
           output(xcharpos, outlevel);
           dybits OF current := dybits OF current OR dontpullbit
    FI,

CO<checkpars>: CO
    (IF type = 2
     THEN fault(181)
            CO bounds not allowed in parameter mode CO
     FI;
     mode OF scam := deflex(mode OF scam)
    ),

CO<lkscam>: CO
    (scam := lkscam;
     type := lktype
    ),

CO<checkequals>: CO
    IF cbiop /= biequals
    THEN fault(182)
           CO = required here CO
    FI,

CO<finish>: CO
    IF t1 = 74
    THEN GOTO endcompile
    ELSE fault(117);
           CO finish expected here CO
           supflts := fltgap
    FI

CO<syntax stack overflow>CO
    OUT abort(207)

ESAC
OD;


exitsc: IF lastid OF current > maxident
        THEN maxident := lastid OF current
        FI;
        globcurrent := external;
        vlist

END;

CO end of range CO


    outlevel := 2;
    range(globinfo, NIL, NIL, NIL);

endcompile:
    CO normal exit CO

    output(down, 0);

    { IF lastmode > 500 THEN  n_modes(lastmode)  FI; }

    IF noflts /= -1
    THEN noflts := 500;
           abort(- 1)
    FI;

endcompile2:   CO after abort CO

    WHILE labs OF globinfo ISNT nillab
    DO faultp(IF status OF labs OF globinfo = 0
                THEN CO label in outer level of decs module CO
                       194
                ELSE CO label not declared CO
                       184
                FI, 0, 0, name OF labs OF globinfo
               );
         labs OF globinfo := rest OF labs OF globinfo
    OD;

    WHILE prl ISNT nilprl
    DO faultp(185, 0, 0, name OF prl);
         CO needs: here .3 CO
         prl := rest OF prl
    OD;

    IF maxident >= startrd
    THEN fault(210)
           CO too many identifiers CO
    FI;
    IF lastrd >= startlib
    THEN fault(211)
           CO too many routines CO
    FI;
    IF nextlibno >= startkmp
    THEN fault(212)
           CO too many library identifiers CO
    FI;

    IF noflts /= -1
    THEN FOR i TO 64
           DO ri := libids[i];
                WHILE ri ISNT nilid
                DO noflts := 10;
                     IF mode OF ri = faultmode ANDTH decno OF ri /= 1
                     THEN CO undeclared .3 used .4 times CO
                            faultp(186, decno OF ri, 0, name OF ri)
                     FI;
                     ri := rest OF ri
                OD
           OD
    FI;

    noflts = -1

END;

COMMENT end of compile COMMENT

SKIP

KEEP ID, MODELIST, PRIMITIVE, PRC, UNN, PROCP, SELIST, STRCT,
       ISTRUCT, VCTOR, ARRAY, STEN, SAMEAS, MDE,
       IDDEC, RDEN, LABEL, YM, YS, INTPAIR, INTTRIPLE, CAT,
       XGEN, XCODE, XNUMBER, XALIEN, XCHARS, XSTRING, XFORMAT,
       XLOAD, XIDDEC, XLABDEC, XROUTINE, XDEC, XEDIT, XOPER,
       XCHARPOS, XPRAG, XWARN, XCONTROL, XSIZES,
       XMODINFO, YMODINFO, XSPEC, YSPEC, XOPENMODULE, XCLOSEMODULE,
       XTMODULE, XTDEC, XCALLMODULE, XCLOSURE, XINTERF, XKEEPS,
       XTDTYPE, XBUTYPE, XCOMPTYPE, OUTPUT, compile

FINISH
